#!/bin/sh
# pax		a package management system that allows the (un)loading of
#		(pre-compiled) software packages for the (XiniX) OS
#
# created	2016/08/08 by Dave Henderson (support@cliquesoft.org)
# updated	2025/12/09 by Dave Henderson (support@cliquesoft.org)
#
# Unless a valid Cliquesoft Private License (CPLv1) has been purchased for your
# device, this software is licensed under the Cliquesoft Public License (CPLv2)
# as found on the Cliquesoft website at www.cliquesoft.org.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the appropriate Cliquesoft License for details.
#
# NOTES
# - The types of packages include:
#	app	application (installer)
# 	bin	binaries						these pertain to the OS
# 	dev	development
# 	doc	documentation
#	drv	drivers
#	gir	GObject
# 	lib	libraries
# 	loc	locales
#	msc	miscellaneous
#	src	source
#
# 	app	applets							these pertain to web.de				< REMOVED - this needs to be handled by web.de itself
# 	icn	icons
# 	skn	skins
# 	thm	themes
#
# - The package extensions include:
#	code	package source code
#	cpio	ramdisk image
#	deps	dependencies list
#	hash	validation hash
#	info	package information
#	list	manifest list
#	make	compile script
#	mark	unload marker
#	newr	update available
#	repo	available in repo
#	soft	software files
#
# - The .deps files can use the following syntax:
#	dependency.i64.bin.soft						package requires this dependency (any version)
#	dependency.i32.lib.soft[1.2.3]					package requires the stated version of this dependency and will install it beside any other version; useful for software requiring different lib versions (e.g. sdl)
#	[dependency.r64.drv.soft|optional.i64.bin.soft]			package can optionally install this dependency if the device also has 'optional' installed




# REMOVED 2025/10/21 - the only function that was called was getBootcode(), which was added to this script to remove the dependency
## CHECK FOR DEPENDENCIES (no log writting here since no directory checks have been made)
#
#. /etc/software/SYSTEM/FUNCTIONS					# NOTE: this also obtains the variables set in /etc/{envars|enviro}
#
## WARNING: this MUST come after the sourced files above so shared variable values don't leak!!!
## NOTE: the RESTORE variable can contain two different values based if it is used as an ACTION or OPTION
unset ALL BOOTING COPY DOWNLOAD EXTRA FORCE IGNORE INSTALL NOLIST MAKE MODE ONLY PREFIX PROXY PURGE QUIET RESTORE SILENT TREE UNLOAD VALIDATE VERSION


# MODULE VARIABLE DEFINITIONS

DEBUG=0												# NOTE: making this a '2' will enable prompts

LIST_BOOT='$( TEMP=$(getBootcode list); ( [ "$TEMP" ] && [ -e "${REPO_PREFIX}/${TEMP}" ] ) && echo $TEMP )'	# obtains and tests for the existence of the 'list' boot code value; is blank otherwise (e.g. process the REPO_SYSTEM)
LIST_LIVE='$( TEMP=$(getBootcode list2); ( [ "$TEMP" ] && [ -e "${REPO_PREFIX}/${TEMP}" ] ) && echo $TEMP || echo optional.list )'		# obtains and tests for the existence of the 'list2' boot code value -OR- uses a default otherwise
FLAG_BOOT='${LIST_BOOT%.*}.flag'										# the flag file that blacklists included packages
FLAG_LIVE='${LIST_LIVE%.*}.flag'										# the flag file that blacklists included packages
FLAG_COPY='copy_all.flag'									# the flag file indicating ALL packages need to be copied instead of symlinked
FLAG_FIRM='copy_sys.flag'									# the flag file indicating ALL firmware packages (REPO_SYSTEM|LIST_BOOT) need to be copied instead of symlinked
# MOVED 2025/11/25 - this is auto configured in the body
#MODE='$( [ "$(getBootcode mode)" = "conservative" ] && echo link || echo copy )'		# the install mode: (sym)link, copy	NOTE: symlink if we are in a 'conservative' operation mode, copy otherwise

DIR_CONF='/etc/pax'										# directory containing any alternate/personalized configuration
DIR_LIST='/var/cache/Software/catalog'								# directory containing the total list of installed applications
DIR_INIT='/var/cache/Software/services'								# directory containing daemon/service scripts
DIR_INST='/var/cache/Software/scripts'								# directory containing other software scripts (taken from /etc/envars)
DIR_LIVE='/Users/Public/.'									# directory to install by default after bootup	NOTE: this needs to end with a '/' or '.' (so that the packages files can be (un)installed from home directories)
DIR_LOGS='/var/log'
DIR_LOOP='/tmp/pax/loop'									# directory that symlinked software needs to use as mountpoint
DIR_TEMP='/tmp/pax'

EXT_CODE='code'											# [tgz file] package source code
EXT_DEPS='deps'											# [text file] package dependency list
EXT_HASH='hash'											# [text file] package validation hash
EXT_INFO='info'											# [text file] package information
EXT_LIST='list'											# [text file] package manifest list
EXT_MAKE='make'											# [text file] package make commands
EXT_MARK='mark'											# [text file] package marker files
EXT_SOFT='soft'											# [mksquashfs file] packaged compiled software

LOG_DBUG="${DIR_LOGS}/pax.debug"								# the log file for debug output
LOG_ERRS="${DIR_LOGS}/pax.log"									# the log file for error output

OWN_GROUP='staff'										# the default 'everyone' group that all non-admin users belong (used for default group ownership on package files/dirs)
						# LEFT OFF - document the below as being able to connect to a "pax server" for remote administration (e.g. FIFO_SERVER='/sshfs/directory/device_nic_mac')
FIFO_SERVER="input"										# defines the default name that the -o action should attach for (remote) commands
ARCH_VALUES='i32|i64|a32|a64'									# the valid values for the -C option

ARCH_SCHEMA="$(uname -m | sed -r 's/i386|i686/i32/;s/x86_64/i64/;s/armv7l/r32/')"		# this can be used so the .deps files can be universal - bash.ARCH.bin.soft
FILE_SCHEMA='${PACKAGE}.${TYPE}.${ARCH}'							# the format for the package filenames		NOTE: encase in single quotes so variables are NOT expanded yet
KRNL_SCHEMA="$(uname -r | sed 's/-/_/g')"							# store the currently used kernel version (substituting '-' for '_')
LOOP_SCHEMA='${PACKAGE}.${TYPE}'		# REMOVE - this is no longer in use						# the format for the package mount point	NOTE: same as above
REPO_SCHEMA='http://repo.cliquesoft.org/vanilla/1.0/${PACKAGE/_${KERNEL}}'			# the format for remote packages		NOTE: save as above
VERS_SCHEMA='${VERSION}.${TYPE}.${ARCH}'							# the format of the versioned package name in the source remote repo (when -V is used)
VERT_SCHEMA='${PACKAGE}_${VERSION}.${TYPE}.${ARCH}'						# the format of the versioned package name in the target local repo (when -V is used)

REPO_PREFIX='/etc/software/SYSTEM/repo'
REPO_OPTION="${REPO_PREFIX}/optional"								# WARNING: this needs to reference 'optional' and REPO_SYSTEM needs to reference 'system'!!!
REPO_SYSTEM="${REPO_PREFIX}/system"								# if any dependency package(s) are not found in the (modified) REPO_OPTION, then check the 'base' location
REPO_RESTOR="/var/cache/Software/restore"
# REMOVE 2025/11/05 - replaced with REPO_SCHEMA
#REPO_REMOTE='http://repo.cliquesoft.org/vanilla/1.0/${PACKAGE/_${KERNEL}}'			# the source to obtain remote packages from when installing/downloading -AND- the target directory when copying

# -------------------- DO **NOT** EDIT BELOW THIS LINE --------------------

# [system]
EXEID="$(mktemp -u XXXXXX)"									# stores a temp execution ID (for use with (un)installing)
INDEX=0												# since no arrays can be used in this shell, this keeps track of the index within the dependency stack	NOTE: 0=no deps
TOTAL=0												# keeps track of the $DEP 'array' size
TEMP=''												# used to store information temporarily
LIBRARIES=''											# boolean indicating libraries are contained in the package and need to be loaded after installation
MODULES=''											# boolean indicating kernel modules are contained in the package and need to be loaded after installation
XML=''												# used to store XML until there's a final success/failure
XML_TAGS=''											# stores the tags that are currently opened (e.g. containing children)

KERNEL=''											# stores the currently used kernel string
RAWFILE=''			# rename to PARAMETER
PREFIX=''											# where the software should be installed: root=/ (firmware), everyone=/Users/Public, user-specific=$HOME, custom=specified
DIRECTORY=''			# rename to TARGET						# defaults to REPO_OPTION if not passed as DIRECTORY parameter
REPO_SOURCE=''			# rename to SOURCE						# if the user passed a new source via -S; defaults to REPO_OPTION if not passed		NOTE: we can NOT define a default value here since it may be different in a config file
DEPENDENCY=''											# the current iterated dependency to work with
PACKAGE=''											# the isolated name of the package (e.g. nano.bin.i32.soft > nano); value set automatically below
BASENAME=''											# the filename without the extension (e.g. nano.bin.i32); value set automatically below
FILENAME=''											# the full filename of the package (e.g. nano.bin.i32.soft); value set automatically below
FILETYPE=''											# the file type that is being processed (this is used by processDependencies())
OPTFILE=''
VERBASE=''
VERFILE=''		# MAYBE DELETE THIS

# [options]
ARCH=''												# stores the value of the ARCH_SCHEMA
MODE=''
TYPE='bin'											# the package type: bin dev doc drv gir lib loc	  NOTE: we're specifying the default value here
DEPS='default'
DRYRUN=''
PROMPT=''
OUTPUT='text'											# the output format to display: fifo, text, xml, xmLive
QUIET='default'											# the verbosity of the output: none, errors, default, verbose, all
VERSION=''
				# the below can all be erased
# UPDATED 2025/10/22 - merged -P with -U
#PURGE=0											# indicate no purging is happening by default
# REMOVED 2025/11/13 - this was merged with UNLOAD
#PURGE=''											# indicate no purging is happening by default	NOTE: keep this blank as default (indicated we are just unloading and not uninstalling)
# UPDATED 2025/11/10
#EXEID="${DIR_TEMP}/$(mktemp -u XXXXXX)"								# stores a temp execution ID (for use with (un)installing)
REPO_TARGET=''			# merge to DIRECTORY						# if the user passed a new target directory as the last passed parameter
DEPFILE=''
APPFILE=''											# e.g. 'bash.i32.bin.soft'
APPHEAD=''											# e.g. 'bash.i32.bin'	(header)
APPNAME=''											# e.g. 'bash'
APPARCH=''											# e.g. 'i32'
APPTYPE=''											# e.g. 'bin'
APPEXTN=''




# -------------------------------------------------------------------------




# DEFINE BUILT-IN FUNCTIONS FOR EXPORT




# DEFINE BUILT-IN FUNCTIONS FOR INTERNAL USE

# Usage syntax: exitGracefully [EXIT] [TARGET] [TAGS] [TAG]
# Overview:	allows the script the terminate gracefully
# Parameters:
# EXIT		[number] [optional] the exit status of this script afterwards
#			0 = success (default)
#	3		1 = failure without printing anything
#	2		2 = failure printing a generic message
#	1		3 = failure with printing ' [failure]'
#			4 = failure printing ' [failure]' and generic message
#			    NOTES:
#			    - the TAG should be passed to close XML
#			    - the TAGS value does not get passed through
# TARGET	[string] [optional] the TARGET value to send to showMsg
# TAGS		[number] [optional] the TAGS value to send to showMsg
# TAG		[string] [optional] the TAG value to send to showMsg
exitGracefully() {
# UPDATED 2025/11/13 - prevents deleted named pipes/fifo's
#	find "$DIR_TEMP" -size 0 -print0 | xargs -0 rm 2>/dev/null				# remove any blank cache file	https://stackoverflow.com/questions/3157343/how-to-delete-many-0-byte-files-in-linux
	find "$DIR_TEMP" ! -type p -size 0 -print0 | xargs -0 rm 2>/dev/null				# remove any blank cache file	https://stackoverflow.com/questions/3157343/how-to-delete-many-0-byte-files-in-linux
	rm -f "${DIR_LIST}/"*.${EXT_MARK} 2>/dev/null						# remove any .marker files
	[ $DEBUG -eq 0 ] && rm -f "${DIR_TEMP}/installs.${EXEID}" 2>/dev/null					# remove any installation temp files
	[ $DEBUG -eq 0 ] && rm -f "${DIR_TEMP}/services.${EXEID}" 2>/dev/null
	[ $DEBUG -eq 0 ] && rm -f "${DIR_TEMP}/filelist.${EXEID}" 2>/dev/null
	[ $DEBUG -eq 0 ] && rm -f "${DIR_TEMP}/unload.${EXEID}" 2>/dev/null
	[ "$MODE" = 'copy' ] && [ $1 -gt 0 ] && ( /bin/mount 2>>"$LOG_ERRS" | grep -q "${DIR_LOOP}/${BASENAME} type squashfs" ) && sudo /bin/umount -d "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1	# if we're copying and an error was encountered, then umount the package

	( [ ! "$1" ] || [ $1 -eq 0 ] ) && {
		[ "$4" ] && showMsg "$4" '' "$2" 1 $3
		exit 0
	}

	[ $1 -gt 2 ] && {
#echo "top |$3|"
		[ ! "$4" ] && showMsg 'failure' ' [failure]' "$2" 1 "$3"
		[ "$4" ] && showMsg "$4" ' [failure]' "$2" 1 5
	}
	( [ $1 -eq 2 ] || [ $1 -eq 4 ] ) && {
#echo btm
# UPDATED 2025/11/07 - this should only be displayed to the screen, as an error message will be sent to the log
		[ ! "$4" ] && showMsg 'failure' 'An error occurred while processing your request.' "$2" 1 "$3"
		[ "$4" ] && showMsg 'failure' 'An error occurred while processing your request.' "$2" 1 6
#		[ ! "$4" ] && showMsg 'failure' 'An error occurred while processing your request.' 'screen' 1 "$3"
#		[ "$4" ] && showMsg 'failure' 'An error occurred while processing your request.' 'screen' 1 1
	}
	exit $1
}


# Usage syntax: checkBootcode CODE
# Overview:	checks if a passed boot code was specified
# Parameters:
# CODE		[string] the name of the boot code to check for
checkBootcode() {
	cat /proc/cmdline | grep -qoE "${1}=[^ ]*" && return 0
	return 1
}


# Usage syntax: getBootcode CODE
# Overview:	stores the value of a passed boot code in $VALUE, or blank otherwise
# Parameters:
# CODE		[string] the name of the boot code to return its value
getBootcode() {
	cat /proc/cmdline | grep -oE "${1}=[^ ]*" | sed 's/.*=//'
	return 0
}


# Usage syntax: showMsg TAG MESSAGE [TARGET] [CR] [TAGS] [TRIM]
# Overview:	sends message to the target in the desired format
# Parameters:
# TAG		[string] the XML tag surrounding the message
#		[ NOTE ]
#			 - this value can be 'success' or 'failure' to a quick '<s><msg>MESSAGE</msg></s>' (or corresponding fail)
#			 - you can append a '|success' or '|failure' for a final message to denote the overall action status			< delete
#			 - the * represents whatever you pass as the value becomes the XML tag (e.g. 'step' becomes <step>...</step>)
#			 - the * has no effect for plain text
#			 - a blank value is also permitted, which doesn't print any tags with XML, and no prefix for plain text			< delete
#			 - a value of 'HEADER' will also print the XML header and not include the message in XML tags				< delete
# MESSAGE	[string] the message to display/store
# TARGET	[string] [optional] the target output: both (default), log, screen
#		[ NOTE ]
#			- if DEBUG>0 then 'log' will output to that log also
# CR		[boolean][optional] if the prompt needs to add a character return at the end [0=no, 1=yes (default)]
# TAGS		[number] [optional] defines XML tag encapsulation (default=1)
#		[ NOTE ]
#			 0 = none
#	1		 1 = on (one set of tags)	line 1		to	<TAG>line 1
#							line 2			      line 2</TAG>
#	3		 2 = on (tags for each line)	line 1		to	<TAG>line 1</TAG>
#							line 2			<TAG>line 2</TAG>
#	2		 3 = on (parent open) 		title		to	<TAG>title
#	5		 4 = on (parent alt open)	title		to	<TAG tag='title'>
#	4		 5 = on (parent close)		title		to	</TAG>		NOTE: this is ignored when OUTPUT='text'
#			 6 = on (closes all open)
# TRIM		[boolean][optional] if the output needs to be trimmed of spaces, tabs, newlines at the beginning and end (default=off)
showMsg() {
	local LINE=''
	local ITEM=''
	local PREFIX=''
	local SUFFIX=''
	local TAG="$1"
	local MSG="$2"
	local TARGET='both'
	local CR=''
	local TAGS=1
	local TRIM=0
	local TEMP=''
#echo "TAG  |$TAG|"
	# DEFINE DEFAULT VALUES
	[ "$3" ] && [ "$3" != '' ] && TARGET="$3"						# NOTE: we had to include the "!= ''" condition for exitGracefully (since it can pass a blank value)
	[ "$4" ] && [ $4 -eq 0 ] && CR="n"
	[ "$5" ] && TAGS=$5
	[ "$6" ] && TRIM=$6
#echo "CR   |$CR|"
#echo "TAGS |$TAGS|"
	# MAKE VARIABLE CHANGES
	[ "$TAG" = 'failure' ] && TEMP='ERROR: '						# this needs to execute regardless of OUTPUT value since this is for the logs
	[ "$TAG" = 'warning' ] && TEMP='ALERT: '						# this needs to execute regardless of OUTPUT value since this is for the logs

	# OUTPUT TO LOG
	[ "$TARGET" != 'screen' ] && {
		echo -e${CR} "${TEMP}${2}" >>"$LOG_ERRS"					# writes to log if value is: both, log		NOTE: we use $2 instead of $MSG to prevent '<br />' contamination
		[ $DEBUG -gt 0 ] && [ "$TARGET" = 'log' ] && echo -e${CR} "${TEMP}${2}" >>"$LOG_DBUG"
		[ "$TARGET" = 'log' ] && return 1							# if we're only logging messages, then we can exit
	}
# UPDATED 2025/11/29
#	( [ "$SILENT" ] || [ "$QUIET" ] ) && return 1						# if we need to be quiet or silent, then no visual, but write to log if desired
#echo "before |$2|"
	[ "$QUIET" = 'all' ] && [ "$TAG" != 'success' ] && return 1				# if we need to supress all visual output (except succes to close XML tags), then only write to the log if desired
#echo 01
	[ "$QUIET" = 'errors' ] && [ "$TAG" != 'success' ] && [ "$TAG" != 'failure' ] && return 1				# if we need to only show errors (or success to close XML tags), but this isn't one of them, then exit (writing to the log if desired)
#echo 02
# UPDATED 2025/11/20
#	[ "$QUIET" = 'default' ] && [ "$TAG" != 'failure' ] && [ "$TAG" != 'success' ] && [ "$TAG" != 'action' ] && [ "$TAG" != 'step' ] && [ "$TAG" != 'package' ] && [ "$TAG" != 'file' ] && [ "$TAG" != 'note' ] && [ "$TAG" != 'prompt' ] && return 1			# if we need to show most output, but this is excess, then exit (writing to the log if desired)
	[ "$QUIET" = 'default' ] && ( [ "$TAG" = 'dependency' ] || [ "$TAG" = 'duplicate' ] ) && return 1			# if we need to show most output (success,failure,action,step,package,file,note,prompt,issue), otherwise exit (writing to the log if desired)
#echo 03
	[ "$QUIET" = 'verbose' ] && [ "$TAG" = 'duplicate' ] && return 1			# if we need to show everything but duplicates (warnings,dependency), then exit (writing to the log if desired)
#echo 04
#echo after
	# ADJUST MESSAGE AND OUTPUT TO SCREEN
	if [ "$OUTPUT" = 'fifo' ]; then
# UPDATED 2025/10/30
#		[ $TAGS -gt 4 ] && return 1
		[ $TAGS -eq 6 ] && return 1

		[ "$TAG" = 'failure' ] && [ "$MSG" != ' [failure]' ] && PREFIX='ERROR: '	# NOTE: the MSG comparison is so that if exitGracefully() was called, then we don't need the prefix
		IFS=$'\n'
		for LINE in $(echo -e "${PREFIX}${MSG}${SUFFIX}"); do				# convert a multi-line MESSAGE (e.g. 'LINE1\nLINE2') into separate 'echo' calls
			echo "$LINE" | sed 's/^\s*//;s/\s*$//' >"${DIR_TEMP}/output"		# also strip pre/post spacing (spaces, tabs) since FIFO's can't handle any of this
		done
	elif [ "$OUTPUT" = 'text' ]; then
# UPDATED 2025/10/30
#		[ $TAGS -gt 4 ] && return 1
		[ $TAGS -eq 6 ] && return 1

		[ "$TAG" = 'failure' ] && [ "$MSG" != ' [failure]' ] && PREFIX='ERROR: '	# NOTE: the MSG comparison is so that if exitGracefully() was called, then we don't need the prefix
		echo -e${CR} "${PREFIX}${MSG}${SUFFIX}"
	elif [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ]; then
		# PROCESS OPENED TAGS
		# if the tag is present after the first one in the list, then we need to close all the tags before it
		if ( echo "$XML_TAGS" | grep -qE " $TAG " ); then
#echo inside
			for ITEM in $(echo "$XML_TAGS"); do
				TEMP="$(echo "$XML_TAGS" | sed -E 's/ $//;s/[a-z]+/\\t/g;s/ //g')" # create the proper preceeding tabs
				XML_TAGS="$(echo "$XML_TAGS" | sed "s/^${ITEM} //")"		# remove the iterated TAG from the list
				PREFIX="${PREFIX}${TEMP}</${ITEM}>\n"				# update the PREFIX to include each closing TAG
				[ "$ITEM" = "$TAG" ] && break					# exit the 'for' as soon as we process the matching TAG
			done
		fi
		# WARNING: these are two separate 'if' statements on purpose!
		# if we're opening a new tag -AND- the tag is NOT already in the opened list, then add it to the beginning of the list
		if ( [ $TAGS -eq 3 ] || [ $TAGS -eq 4 ] ) && [ "$(echo "$XML_TAGS" | cut -f 1 -d ' ')" != "$TAG" ]; then
#echo "top |$TAG|"
			XML_TAGS="$TAG $XML_TAGS"
		# if we're opening a new tag -AND- the tag IS the first one in the opened list, then close the prior one first
		elif ( [ $TAGS -eq 3 ] || [ $TAGS -eq 4 ] ) && [ "$(echo "$XML_TAGS" | cut -f 1 -d ' ')" = "$TAG" ]; then
			TEMP="$(echo "$XML_TAGS" | sed -E 's/ $//;s/[a-z]+/\\t/g;s/ //g')"
			PREFIX="${PREFIX}${TEMP}</${TAG}>\n"
		# if we're closing an open tag -AND- the tag IS the first one in the list, then delete it from the list
		elif [ $TAGS -eq 5 ] && [ "$(echo "$XML_TAGS" | cut -f 1 -d ' ')" = "$TAG" ]; then
#echo mid
			XML_TAGS="$(echo "$XML_TAGS" | sed "s/^${TAG} //")"
		fi
#echo "prefix |$PREFIX|"
#echo "XML_TAGS |$XML_TAGS|"
#echo "TEMP |$TEMP|"
		# PROCESS TAG AND INDENTATION							  NOTE: this MUST come below the 'PROCESS OPENED TAGS' section
		TEMP="$(echo "$XML_TAGS" | sed -E 's/ $//;s/[a-z]+/\\t/g;s/ //g')"
# UPDATED 2025/11/06
#		[ "$XML_TAGS" ] && [ $TAGS -lt 3 ] && TEMP="\t${TEMP}"
		[ "$XML_TAGS" ] && [ $TAGS -lt 3 ] && TEMP="\t${TEMP}"
		case "$TAGS" in
			0)	PREFIX=''							# if no tags are to be displayed (e.g. the MESSAGE contains them)
				SUFFIX=''
				;;
			1|2)	PREFIX="${PREFIX}${TEMP}<${TAG}>"				# if both opening and closing tags need to be displayed
				SUFFIX="</${TAG}>"
				;;
			3)	[ ! "$CR" ] && PREFIX="${PREFIX}${TEMP}<${TAG}>\n${TEMP}\t"	# if only the opening tag needs to be displayed
				[ "$CR" ] && PREFIX="${PREFIX}${TEMP}<${TAG}>"			#   WARNING: the CR detection here is backwards since a value of 'n' means NOT to CR!
				SUFFIX=''
				;;
			4)	PREFIX="${PREFIX}${TEMP}<${TAG} tag=\"$(echo -e "$2" | sed 's|^\s*||;s|\s*$||;/^$/d')\">"	# if only the alt opening tag needs to be displayed
				SUFFIX=''
				MSG=''								#   erase this value since it's already been added to the output
				;;
			5)	PREFIX=''							# if only the closing tag needs to be displayed; this is typically used to close an open tag on the same line (e.g. "<action>Doing some action: [done]</action>")
				SUFFIX="</${TAG}>"
				;;
			6)	PREFIX=''							# if all the closing tags need to be displayed
				for ITEM in $(echo "$XML_TAGS"); do
					SUFFIX="${SUFFIX}${TEMP}</${ITEM}>\n"
					XML_TAGS="$(echo "$XML_TAGS" | sed "s/^${ITEM} //")"
					TEMP="$(echo "$XML_TAGS" | sed -E 's/ $//;s/[a-z]+/\\t/g;s/ //g')"
				done
				[ "$OUTPUT" = 'xml' ] && XML="${XML}${SUFFIX}"
# MOVED 2025/10/30 - moved below
#				[ "$OUTPUT" = 'xmLive' ] && SUFFIX="${SUFFIX}</xml>"
				[ "$OUTPUT" = 'xmLive' ] && SUFFIX="$(echo "${SUFFIX}" | sed 's/\\n$//')"			# cleans up trailing blank line in output
				;;
		esac
#echo "P/S |$PREFIX|$SUFFIX|"
		# APPLY TRIM AND TAG ENCAPSULATE
		if [ $TRIM -eq 0 ]; then							# if we're leaving the output untrimmed, then...
#echo not-trimming
			[ $TAGS -lt 2 ] && MSG="$(echo "$MSG" | sed ':a;N;$!ba;s|\n|<br />|g')"	# replace any CR's with <br />'s		https://stackoverflow.com/questions/1251999/how-can-i-replace-each-newline-n-with-a-space-using-sed
			[ $TAGS -eq 2 ] && MSG="$(echo "$MSG" | sed ":a;N;\$!ba;s|\n|${SUFFIX}\n${PREFIX}|g")"	# replace any CR's with XML tags (plus indentation)
		else										# otherwise, do the same as above, but apply trimming
#echo trimming
			[ $TAGS -lt 2 ] && {
				MSG="$(echo "$MSG" | sed 's|^\s*||;s|\s*$||')"			# trim pre/post spacing
				MSG="$(echo -e "$MSG" | sed '/^$/d')"				# removes any blank lines
				MSG="$(echo -e "$MSG" | sed ':a;N;$!ba;s|\n\s*|<br />|g')"	# convert CR's to <br />'s
			}
			[ $TAGS -eq 2 ] && {
				MSG="$(echo "$MSG" | sed "s|^\s*||;s|\s*$||")"
				MSG="$(echo -e "$MSG" | sed '/^$/d')"
				MSG="$(echo -e "$MSG" | sed ":a;N;\$!ba;s|\n\s*|${SUFFIX}\n${PREFIX}|g")"
			}
			[ $TAGS -gt 2 ] && MSG="$(echo "$MSG" | sed 's|^\s*||;s|\s*$||')"
		fi
#echo afterwards

		# PROCESS XML
		[ "$OUTPUT" = 'xmLive' ] && {
			[ "$TAG" = 'failure' ] && [ $TAGS -eq 6 ] && PREFIX='<failure>' && SUFFIX="</failure>\n${SUFFIX}"	# for exitGracefully calls that need to close open tags while still showing <failure>
			[ "$TAG" = 'failure' ] && [ "$XML_TAGS" = '' ] && PREFIX="\t${PREFIX}"	# for inline failure calls
			[ "$TAG" = 'success' ] && [ "$XML_TAGS" = '' ] && PREFIX="${PREFIX}"	# for inline failure calls
			[ "${PREFIX}${MSG}${SUFFIX}" != '' ] && echo -e${CR} "${PREFIX}${MSG}${SUFFIX}"				# to prevent blank lines from showing in output
			( [ "$TAG" = 'success' ] || [ "$TAG" = 'failure' ] || [ $TAGS -eq 6 ] ) && echo '</xml>'
		}
		if [ "$OUTPUT" = 'xml' ]; then
			if [ "$TAG" = 'success' ]; then
				( echo "$XML" | grep -q '\\n' ) && echo -e "<s>\n    <xml>\n${XML}    </xml>\n</s>" || echo -e "<s>${XML}</s>"
			elif [ "$TAG" = 'failure' ]; then
				echo -e "<f><msg>${MSG}</msg></f>"
			else
				( ( [ $TAGS -eq 3 ] || [ $TAGS -eq 0 ] ) && [ "$CR" ] ) && CR='' || CR='\n'
#echo "cr |$CR|$MSG|"
				XML="${XML}${PREFIX}${MSG}${SUFFIX}${CR}"
#echo -e "XML:\n$XML"
			fi
		fi
	fi
#"
}


# Usage syntax: splitName NAME EXTENSION
# Overview:	seperates/creates the passed name into its various parts
# Parameters:
# NAME		[string] the name of the package to parse (e.g. bash.i64.dev.soft)
# EXTENSION	[string] [optional] the file extension to process (EXT_SOFT is default)
splitName() {
# UPDATED 2025/11/13 - this is so -o could work (i
#	local PARAMETER="${1##*/}"								# remove any directory structure and store the raw parameter value
	local PARAMETER="$(echo "$1" | sed 's|.*/||;s|^\s*||')"					# remove any directory structure and store the raw parameter value	NOTE: we also remove any preceeding spacing that gets injected when using -o for some reason
	local EXT="${EXT_SOFT}"
	local TEMP=''

	[ ! "$PARAMETER" ] && {
		showMsg 'failure' "No package names could be found." 'screen' 1 1
		return 1
	}
	[ "$2" ] && EXT="$2"

	# WARNING: this 'if' must be in the order it is to process correctly
	OPTFILE=''										#   erase any existing value from this variable to prevent bugs
#	[ $INDEX -gt 1 ] && VERBASE='' && VERFILE=''
	if ( echo "$PARAMETER" | grep -q ^'\[' ); then						# if an optional package (e.g. [xorg_3d.i32.bin.soft|xorg.bin]) was passed, then...
		VERSION=''									#   erase any existing value from this variable to prevent bugs
		OPTFILE="$(echo "$PARAMETER" | sed 's/^\[//;s/\]$//;s/.*|//')"			#   remove the brackets and store just the optional package (xorg.bin)
		PARAMETER="$(echo "$PARAMETER" | sed 's/^\[//;s/\]$//;s/|.*//')"		#   remove the brackets and store just the dependency name (xorg_3d.i32.bin.soft)
	elif ( echo "$PARAMETER" | grep -q '\]'$ ); then					# if a version number has been included (e.g. bash.bin[4.0.2]) in the name, then...
		VERSION="$(echo "$PARAMETER" | sed 's/.*\[//;s/\]$//')"				#   store just the included version number (4.0.2)
# MOVED 2025/12/02 - at the top of this block
#		OPTFILE=''									#   erase any existing value from this variable to prevent bugs
		PARAMETER="${PARAMETER%%[*}"							#   remove the version number and store just the name (bash.bin)
# MOVED 2025/12/02 - at the top of this block
#	else
#		VERSION=''
#		OPTFILE=''
	fi

	PARAMETER="$(echo $PARAMETER | sed "s/KERNEL/${KERNEL}/")"				# perform KERNEL substitution first thing so ALL the various names have the change
	if ( echo "$PARAMETER" | grep -q "$EXT"$ ); then					# if the whole filename was passed, then...
		TEMP="${FILE_SCHEMA#*\}}"							#   remove just the package name portion from the package filename 'schema' - everything before the first '}' character
#echo "temp |$TEMP|"
		TEMP="$(echo "$TEMP" | sed 's/\./\\\\\./g;s/${TYPE}/.../')"			#   escape any periods in the schema and replace TYPE with three dots (to match any TYPE - bin,dev,doc,...)
# UPDATED 2025/10/31 - so that the VERFILE assignment below works correctly
#		eval TEMP="${TEMP}\\\\.${EXT_SOFT}"						#   eval the variable to get any variable substitution done (except TYPE which was replaced by three dots) and add the extension
		eval TEMP="${TEMP}"								#   eval the variable to get any variable substitution done (except TYPE which was replaced by three dots)
#echo "temp2 |$TEMP|"
# UPDATED 2025/10/31 - so that the VERFILE assignment below works correctly
#		PACKAGE="$(echo $PARAMETER | sed "s/${TEMP}$//")"				#   remove the TEMP string that was just created to isolate just the package name
		PACKAGE="$(echo $PARAMETER | sed "s/${TEMP}\.${EXT}$//")"			#   remove the TEMP string that was just created to isolate just the package name
# MERGED 2025/11/05
#		BASENAME="$(echo $PARAMETER | sed "s/.${EXT_SOFT}$//")"				#   remove the file extension from the name
#		BASENAME="$(echo $BASENAME | sed "s/KERNEL/${KERNEL}/")"			#   lastly, perform the KERNEL keyword substitution
# UPDATED 2025/12/04 - kernel substituion needs to be first
#		BASENAME="$(echo $PARAMETER | sed "s/.${EXT}$//;s/KERNEL/${KERNEL}/")"		#   remove the file extension from the name and perform the KERNEL keyword substitution
		BASENAME="$(echo $PARAMETER | sed "s/.${EXT}$//")"				#   remove the file extension from the name and perform the KERNEL keyword substitution
		FILENAME="$PARAMETER"

# UPDATED 2025/11/05
#		# this is for the VERFILE assignment below
#		TEMP="$(echo $FILENAME | sed "s/^${PACKAGE}//")"				#   remove the PACKAGE name from the FILENAME and store it
	else											# otherwise just the package name was, so...
# REMOVED 2025/10/31 - this is supposed to be for just the package names being passed so no altering should be necessary
#		TEMP="${FILE_SCHEMA#*\}}"							#   remove just the package name portion from the package filename 'schema' - everything before the first '}' character
#		eval TEMP="${TEMP}.${EXT_SOFT}"							#   combine the 'schema' (less the package name) values and the file extension value (e.g. i32.bin.soft)
#echo "temp |$TEMP|"
#echo $PARAMETER | sed "s/${TEMP}//"
#		PACKAGE="$(echo $PARAMETER | sed "s/${TEMP}//")"				#   remove that combination from the passed package name (in case it was passed like bash.i32.bin.soft) to isolate just the package name (e.g. bash)
# UPDATED 2025/10/31 - FILENAME would not have a value yet
#		FILENAME="$(echo $FILENAME | sed "s/KERNEL/${KERNEL}/")"			#   perform the KERNEL keyword substitution
# UPDATED 2025/12/04 - kernel substituion needs to be first
#		PACKAGE="$(echo $PARAMETER | sed "s/KERNEL/${KERNEL}/")"			#   perform the KERNEL keyword substitution against the passed package name
		PACKAGE="$PARAMETER"
		eval BASENAME="${FILE_SCHEMA}"							#   eval the variable to get any variable substitution done
		FILENAME="${BASENAME}.${EXT}"

# UPDATED 2025/11/05
#		# this is for the VERFILE assignment below
#		TEMP="${FILE_SCHEMA#*\}}"							#   remove just the package name portion from the package filename 'schema' - everything before the first '}' character
#		eval TEMP="${TEMP}.${EXT_SOFT}"							#   combine the package filename 'schema' (less the package name) and the file extension value (e.g. i32.bin.soft)
	fi
	FILETYPE="$(echo "$FILENAME" | grep -oE '[\._\-](bin|dev|doc|drv|gir|lib|loc)' | head -n 1 | sed -E 's/^[\._\-]//')"			# search for any variation of known type abbreviations and remove the preceeding separation character
	[ "$FILETYPE" = '' ] && FILETYPE="$TYPE"					#   if the line above did not return any value, then default to whatever is specified as TYPE

# UPDATED 2025/12/02
#	[ "$VERSION" ] && VERBASE="${VERSION}$(echo $BASENAME | sed "s/^${PACKAGE}//")" || VERBASE=''				# replace the package name with the version number (e.g. 2025.04.10.i32.bin.soft)	WARNING: this MUST come after the above assignments so the proper values are created
## UPDATED 2025/11/05
##	[ "$VERSION" ] && VERFILE="${VERSION}${TEMP}" || VERFILE=''				# replace the package name with the version number (e.g. 2025.04.10.i32.bin.soft)	WARNING: this MUST come after the above assignments so the proper values are created
#	[ "$VERSION" ] && VERFILE="${VERBASE}.${EXT}" || VERFILE=''				# replace the package name with the version number (e.g. 2025.04.10.i32.bin.soft)	WARNING: this MUST come after the above assignments so the proper values are created
# UPDATED 2025/12/05
#	[ "$VERSION" ] && ( [ $INDEX -eq 0 ] || ( [ $INDEX -eq 1 ] && [ $TOTAL -gt 1 ] ) ) && VERBASE="${VERSION}$(echo $BASENAME | sed "s/^${PACKAGE}//")" || VERBASE=''				# replace the package name with the version number (e.g. 2025.04.10.i32.bin.soft)	WARNING: this MUST come after the above assignments so the proper values are created
	[ "$VERSION" ] && ( [ $INDEX -eq 0 ] || ( [ $INDEX -eq 1 ] && [ $TOTAL -gt 1 ] ) ) && eval VERBASE="${VERS_SCHEMA}" || VERBASE=''				# replace the package name with the version number (e.g. 2025.04.10.i32.bin.soft)	WARNING: this MUST come after the above assignments so the proper values are created
# UPDATED 2025/11/05
#	[ "$VERSION" ] && VERFILE="${VERSION}${TEMP}" || VERFILE=''				# replace the package name with the version number (e.g. 2025.04.10.i32.bin.soft)	WARNING: this MUST come after the above assignments so the proper values are created
	[ "$VERSION" ] && ( [ $INDEX -eq 0 ] || ( [ $INDEX -eq 1 ] && [ $TOTAL -gt 1 ] ) ) && VERFILE="${VERBASE}.${EXT}" || VERFILE=''				# replace the package name with the version number (e.g. 2025.04.10.i32.bin.soft)	WARNING: this MUST come after the above assignments so the proper values are created

#echo "name |$PACKAGE|"
#echo "base |$BASENAME|"
#echo "file |$FILENAME|"
#echo "type |$FILETYPE|"
#echo "optf |$OPTFILE|"
#echo "ver  |$VERSION|"
#echo "verb |$VERBASE|"
#echo "verf |$VERFILE|"

return 0
# REMOVED 2025/10/21 - to now be more versatile with package names
	local RAWFILE="${1##*/}"								# remove any directory structure and store the raw parameter value

	if ( echo "$RAWFILE" | grep -q ^'\[' ); then						# if an optional package (e.g. [xorg_3d.i32.bin.soft|xorg.bin]) was passed, then...
		APPFILE="$(echo "$RAWFILE" | sed 's/^\[//;s/\]$//;s/|.*//')"			#   store just the name (xorg_3d.i32.bin.soft)
		OPTFILE="$(echo "$RAWFILE" | sed 's/^\[//;s/\]$//;s/.*|//')"			#   store just the optional package (xorg.bin)
		VERSION=''									#   erase any existing value from this variable to prevent bugs
	elif ( echo "$RAWFILE" | grep -q '\]'$ ); then						# if a version number has been included (e.g. bash.bin[4.0.2]) in the name, then...
		APPFILE="${1%%[*}"								#   store just the name (bash.bin)
		OPTFILE=''									#   erase any existing value from this variable to prevent bugs
		VERSION="$(echo "$1" | sed 's/.*\[//;s/\]$//')"					#   store just the included version number (4.0.2)
	else
		APPFILE="$1"									#   store just the name (bash.bin)
		OPTFILE=''									#   erase any existing values from these variables to prevent bugs
		VERSION=''
	fi

	[ "${APPFILE##*.}" != 'soft' ] && APPFILE="${APPFILE}.${CPU}.bin.soft"			# if the user only entered the name (e.g. pax -d bash), then we need to apply best-guesses to the other parts of the filename
	APPFILE="${APPFILE/CPU/${CPU}}"								# perform the CPU keyword substitution 			WARNING: these must be processed in the order shown
	APPFILE="${APPFILE/KERNEL/${KERNEL}}"							# perform the KERNEL keyword substitution
	APPHEAD="${APPFILE%.*}"									# e.g. 'bash.i32.bin'		header
	APPNAME="$(echo "$APPFILE" | head -c -14)"						# e.g. 'bash'			package name
	APPARCH="$(echo "$APPFILE" | tail -c 13 | head -c 3)"					# e.g. 'i32'			package CPU architecture
	APPTYPE="${APPHEAD##*.}"								# e.g. 'bin'			package type
	APPEXTN="${APPFILE##*.}"								# e.g. 'soft'			package extension
	[ "$VERSION" ] && VERFILE="${VERSION}.${APPARCH}.${APPTYPE}.${APPEXTN}" || VERFILE=''	# WARNING: this MUST come after the above assignments so the proper values are created
}


# Usage syntax: addDependency FILENAME
# Overview:	adds the passed package name onto the top of the stack of dependencies
# Parameters:
# FILENAME	[string] the package name that needs to be added to the stack
addDependency() {
	[ $DEBUG -gt 0 ] && echo -e "addDependency (old):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|" >>"$LOG_DBUG"

#echo "INDEX is 1 |$INDEX|"
	INDEX=$(( INDEX + 1 ))
#echo "INDEX is 2 |$INDEX|"
	TOTAL=$(( TOTAL + 1 ))
	eval "DEP${INDEX}=$1"									# NOTE: since busybox shell (ash) can't handle arrays (ugh!), we have to use this work around...
	eval "DEPENDENCY=\$DEP${INDEX}"

	[ $DEBUG -gt 0 ] && echo -e "addDependency (new):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|" >>"$LOG_DBUG"
}


# Usage syntax: deleteDependency [DECREASE]
# Overview:	deletes the top-most (last added) package from the stack of dependencies
# Parameters:
# DECREASE	[boolean] if the INDEX variable needs to be decreased by 1
deleteDependency() {
	[ $DEBUG -gt 0 ] && echo -e "deleteDependency (old):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|" >>"$LOG_DBUG"

	eval "unset DEP${INDEX}"
	[ "$1" ] && INDEX=$(( INDEX - 1 ))							# if we need to decrease the INDEX value, then do so!
	[ $INDEX -eq 0 ] && {									# if there isn't anything in the stack, delete the variable and exit
		unset DEPENDENCY
		[ $DEBUG -gt 0 ] && echo -e "deleteDependency (new):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  ||" >>"$LOG_DBUG"
		return 0
	}
	[ "$1" ] && eval "DEPENDENCY=\$DEP${INDEX}"

	[ $DEBUG -gt 0 ] && echo -e "deleteDependency (new):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|" >>"$LOG_DBUG"
}


# Usage syntax: inDependencies FILENAME
# Overview:	checks if the package is already in the list of to-be-processed dependencies
# FILENAME	[string] the package name that needs to be looked up
inDependencies() {
	local I

	for I in $(seq 1 $INDEX); do						# check if the dependencies has already been added to the list to be processed, so...
		eval TEMP="\$DEP${I}"						#   since busybox 'sh' does not support arrays, we have to use this method to check each stored dependency
#echo "comparing |$TEMP|$1|"
		[ "$TEMP" = "$1" ] && return 0					#   if the iterated dependency is already in the list (including any specific version number), then...
	done
#echo 'nope in list'
	return 1
}


# Usage syntax: listDependencies
# Overview:	lists the currently stored dependencies
listDependencies() {
	local I=$INDEX
	local D=' '

	TEMP="$DEPENDENCY"

	while [ "$D" ]; do
		I=$(( I - 1 ))
		eval "D=\$DEP${I}"
		TEMP="${D}\n${TEMP}"
		[ $I -eq 1 ] && unset D
#echo "TEMP |$TEMP|$I|, press any key..."
#read
	done
	echo -e $TEMP
}


# Usage syntax: processDependencies PACKAGE [INDENT]
# Overview:	adds all the dependencies for the passed package onto the stack of dependencies to be installed
# Notes:	pwd is mostly irrelevent to this function as it will dynamically change internally					< DELETE this
# Notes:	the directory containing the file(s)-to-copy should already be entered BEFORE calling this function!
# Parameters:
# PACKAGE	[string] the package name that is being installed
# INDENT	[string] [optional] passed tabs (e.g. '\t\t') to indent the output (for the -t switch)
processDependencies() {
	local SOURCE=''
#	local TARGET=''
#	local RELEASE										# used to indicate that the iterated dependency is released to be unloaded
#	local DIR=''
	local DEPFILE
	local DEPBASE
	local DEPNAME
	local DEPTYPE
	local INDENT="$2"

	splitName "$1"
#echo "package |$PACKAGE|$FILENAME|"

# UPDATED 2025/10/31 - replace APP* variables
#	[ $DEBUG -gt 0 ] && { echo -en "processDependencies:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:\n\tOPTFILE :${OPTFILE}:\n\tSOURCE  :${SOURCE}:\n\tTARGET  :${TARGET}:\n\tpwd     " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }
	[ $DEBUG -gt 0 ] && { echo -en "processDependencies:\n\tRAWFILE     |${RAWFILE}|\n\tPASSED      |${1}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${ARCH}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\tOPTFILE     |${OPTFILE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

# UPDATED 2025/11/04 - we are now using DIRECTORY
#	[ "$REPO_TARGET" ] && TARGET="$REPO_TARGET" || TARGET="$REPO_OPTION"			# if a different target was specified, then store that as the target, otherwise use the default value
# UPDATED 2025/10/31 - replace APP* variables
#	DIR="${APPNAME/_${KERNEL}}"								# set the default value while removing any KERNEL value from the (directory) name
#	[ "$APPTYPE" = 'app' ] && DIR="web.de/_apps/${APPNAME}"					# if we're dealing with a web.de applet, set DIR to the package name for proper repo URI navigation
#	[ "$APPTYPE" = 'icn' ] && DIR="web.de/_icons/${APPNAME}"				# or an icon set
#	[ "$APPTYPE" = 'skn' ] && DIR="web.de/_skins/${APPNAME}"				# or a skin
#	[ "$APPTYPE" = 'thm' ] && DIR="web.de/_themes/${APPNAME}"				# or a theme
# REMOVED 2025/11/04 - the DIR value was added to REPO_REMOTE and the app,icn,skn,thm packages will need to be handled through web.de itself
#	DIR="${PACKAGE/_${KERNEL}}"								# set the default value to the package name, while removing the _KERNEL keyword
#	[ "$TYPE" = 'app' ] && DIR="web.de/_apps/${PACKAGE}"					# if we're dealing with a web.de applet, set DIR to the package name for proper repo URI navigation
#	[ "$TYPE" = 'icn' ] && DIR="web.de/_icons/${PACKAGE}"					# or an icon set
#	[ "$TYPE" = 'skn' ] && DIR="web.de/_skins/${PACKAGE}"					# or a skin
#	[ "$TYPE" = 'thm' ] && DIR="web.de/_themes/${PACKAGE}"					# or a theme

	# get us into the correct directory to process the request
# UPDATED 2025/11/04 - we now only use REPO_SOURCE and DIRECTORY, no more checking here and there...
## UPDATED 2025/10/31 - replace APP* variables
##	if [ ! "$REPO_SOURCE" ] && [ -e "./${APPFILE}" ]; then									# if no source was provided via '-S' and the pwd has the file (e.g. from a restore point), then...
#	if [ ! "$REPO_SOURCE" ] && [ -e "./${FILENAME}" ]; then							# if no source was provided via '-S' and the pwd has the file (e.g. from a restore point), then...
#		SOURCE='local '
#	elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'http' || echo "$REPO_SOURCE"|grep -q ^'ftp' ); then		# if a different SOURCE was provided -AND- it is remote, then...
#		cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1										# NOTE: we cd into this directory just as a precaution
#		SOURCE='remote'
## UPDATED 2025/10/31 - replace APP* variables
##	elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'/' || echo "$REPO_SOURCE"|grep -q ^'./' ) && [ -e "${REPO_SOURCE}/${APPFILE}" ]; then	# if a different SOURCE was provided -AND- it is a directory -AND- the iterated package exists in the REPO directory, then...
#	elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'/' || echo "$REPO_SOURCE"|grep -q ^'./' ) && [ -e "${REPO_SOURCE}/${FILENAME}" ]; then	# if a different SOURCE was provided -AND- it is a directory -AND- the iterated package exists in the REPO directory, then...
#		cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1
#		SOURCE='local '
## UPDATED 2025/10/31 - replace APP* variables
##	elif [ -e "${REPO_SYSTEM}/${APPFILE}" ]; then										# otherwise check that the file exists in the REPO_SYSTEM...
#	elif [ -e "${REPO_SYSTEM}/${FILENAME}" ]; then										# otherwise check that the file exists in the REPO_SYSTEM...
#		cd "$REPO_SYSTEM" >>"$LOG_ERRS" 2>&1
#		SOURCE='local '
#	else															# and lastly change to the default REPO_OPTION as a last resort to find/store the software
#		cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1
## UPDATED 2025/10/31 - replace APP* variables
##		[ -e "${REPO_OPTION}/${APPFILE}" ] && SOURCE='local ' || SOURCE='remote'
#		[ -e "${REPO_OPTION}/${FILENAME}" ] && SOURCE='local ' || SOURCE='remote'
#	fi
# UPDATED 2025/11/06
#	( echo "$REPO_SOURCE"|grep -q ^'http' || echo "$REPO_SOURCE"|grep -q ^'ftp' ) && SOURCE='remote' || SOURCE=' local'	# determine if the SOURCE is remote or local, then...
# MOVED 2025/11/07 - this was moved below and made to be dynamic
#	( echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) && SOURCE='remote' || SOURCE=' local'					# determine if the SOURCE is remote or local, then...

# MOVED 2025/11/05 - this is now done in the main part of the script
#	cd "$DIRECTORY" >>"$LOG_ERRS" 2>&1											# now cd into the DIRECTORY where the packages are

	# perform a few basic checks...
# UNTESTED
# UPDATED 2025/11/04 - we are now using DIRECTORY
#	if [ ! "$REPO_TARGET" ] && ( grep -qw "$RAWFILE" "${REPO_PREFIX}/${LIST_FLAG}" 2>/dev/null ); then				# if we're using an 'internal repo' (optional or system) -AND- the package IS listed as being flagged to not load, then...
	if [ "$BOOTING" ] && ( grep -qwE ^"${PACKAGE}|${FILENAME}"$ "${REPO_PREFIX}/${FLAG_BOOT}" 2>/dev/null ); then		# if the package (by its PACKAGE name -or- complete FILENAME) IS listed as being flagged to not load, then...
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage flagged from loading..." >>"$LOG_DBUG"
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[ FLAG ] ${APPNAME}.${APPTYPE}"
		showMsg 'dependency' "[ FLAG ] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
# UPDATED 2025/12/04
#		showMsg 'failure' "The package is flagged from being loaded." 'log'
#		return 1
		return 0													# NOTE: to prevent issues during a bootup, just skip this package
	fi
	if [ ! "$BOOTING" ] && ( grep -qwE ^"${PACKAGE}|${FILENAME}"$ "${REPO_PREFIX}/${FLAG_LIVE}" 2>/dev/null ); then		# if the package (by its PACKAGE name -or- complete FILENAME) IS listed as being flagged to not load, then...
		showMsg 'dependency' "[ FLAG ] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is flagged from being loaded." 'log'
# DEV NOTE: you can force an install to just skip processing this package
		if [ "$FORCE" ]; then
			return 0
		else
			showMsg 'failure' "The package is flagged from being loaded." 'log'
			return 1
		fi
	fi

	[ "$OPTFILE" ] && [ "$DEPS" != 'all' ] && {								# if we've encountered a conditional package -AND- we are not using the '-D all' option, then we can safely skip it!
		showMsg 'dependency' "[option] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0												# NOTE: don't error with exit status for a conditional package
	}

#( inDependencies $OPTFILE ) && echo 'deps is in list' || echo 'dep is NOT in list'
#echo "|$FILENAME|$OPTFILE|"

# MERGED 2025/11/26 - this is now -D all
#	[ "$OPTFILE" ] && [ ! "$ALL" ] && [ ! -e "${DIR_LIST}/${OPTFILE}" ] && {						# if we've encountered a conditional package -AND- we are not using the -A option -AND- it's dependency is not installed, then we can safely skip it!
	[ "$OPTFILE" ] && [ "$DEPS" = 'all' ] && [ ! -e "${DIR_LIST}/${OPTFILE}" ] && ( ! inDependencies $OPTFILE ) && {	# if we've encountered a conditional package -AND- we are using the '-D all' option -AND- it's dependency is not installed -AND- it's not in the to-be-processed list, then we can safely skip it!
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage conditional missing..." >>"$LOG_DBUG"
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[absent] ${APPNAME}.${APPTYPE}"
		showMsg 'dependency' "[absent] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'warning' "The conditional package is not installed." 'log'
		return 0												# NOTE: don't error with exit status for a conditional package
	}

	# perform checks for the action...
	[ "$COPY" ] && [ ! -e "${REPO_SOURCE}/${FILENAME}" ] && {							# if we're copying or downloading -AND- not forcing -AND- the package exists in the target DIRECTORY, then...
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is missing..." >>"$LOG_DBUG"
		showMsg 'dependency' "[absent] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is missing from REPO_SOURCE." 'log'
		return 1
	}
	[ "$COPY" ] && ( echo ",${IGNORE}," | grep -qE ",(${PACKAGE}|${FILENAME})," ) && {							# if the iterated dependency is ignored -AND- we are unloading/uninstalling it, then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tThe package was passed in the ignore list..." >>"$LOG_DBUG"			# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'dependency' "[ignore] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0
	}
# MERGED 2025/11/05 - plus this should work for any action
## UPDATED 2025/10/31 - replace APP* variables and using showMsg()
##	[ "$COPY" ] && [ ! "$FORCE" ] && [ -e "${TARGET}/${APPFILE}" ] && {
##		[ $DEBUG -gt 0 ] && echo -e "\tPackage already exists..." >>"$LOG_DBUG"
##		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[exists] ${APPNAME}"
## UPDATED 2025/11/04 - we are now using DIRECTORY
##	[ "$COPY" ] && [ ! "$FORCE" ] && [ -e "${TARGET}/${FILENAME}" ] && {
#	[ "$COPY" ] && [ ! "$FORCE" ] && [ -e "${FILENAME}" ] && {							# if we're copy -AND- not forcing -AND- the package exists in the target DIRECTORY, then...
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage already exists..." >>"$LOG_DBUG"
#		showMsg 'step' "[exists] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
#		return 0
#	}
## UPDATED 2025/10/31 - replace APP* variables and using showMsg()
##	[ "$DOWNLOAD" ] && [ ! "$FORCE" ] && [ -e "${APPFILE}" ] && {
##		[ $DEBUG -gt 0 ] && echo -e "\tPackage already downloaded..." >>"$LOG_DBUG"
##		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[exists] ${APPNAME}.${APPTYPE}"
#	[ "$DOWNLOAD" ] && [ ! "$FORCE" ] && [ -e "${FILENAME}" ] && {							# if we're downloading a package -AND- not forcing -AND- the package exists in the target DIRECTORY, then...
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage already downloaded..." >>"$LOG_DBUG"
#		showMsg 'step' "[exists] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
#		return 0
#	}
	( [ "$COPY" ] || [ "$DOWNLOAD" ] ) && [ ! "$FORCE" ] && [ -e "${FILENAME}" ] && {				# if we're copying or downloading -AND- not forcing -AND- the package exists in the target DIRECTORY, then...
		[ $DEBUG -gt 0 ] && echo -e "\tPackage already exists in the target location." >>"$LOG_DBUG"					# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'dependency' "[exists] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0												# NOTE: do NOT return error, we will just simply skip the file so the user isn't forced to pass '-F' a lot
	}

	[ "$DOWNLOAD" ] && ( echo ",${IGNORE}," | grep -qE ",(${PACKAGE}|${FILENAME})," ) && {							# if the iterated dependency is ignored -AND- we are unloading/uninstalling it, then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tThe package was passed in the ignore list..." >>"$LOG_DBUG"			# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'dependency' "[ignore] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0
	}

	[ "$EXTRACT" ] && ( echo ",${IGNORE}," | grep -qE ",(${PACKAGE}|${FILENAME})," ) && {							# if the iterated dependency is ignored -AND- we are unloading/uninstalling it, then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tThe package was passed in the ignore list..." >>"$LOG_DBUG"			# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'dependency' "[ignore] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0
	}
# UNTESTED
# MERGED 2025/11/05 - plus this should work for any action
## UPDATED 2025/10/31 - replace APP* variables and using showMsg()
##	[ "$INSTALL" ] && [ ! "$FORCE" ] && [ ! "$RESTORE" ] && [ -e "${DIR_LIST}/${APPFILE}" ] && {			# if we're installing -AND- not updating (by forcing or creating a restore point) -AND- the software is already installed, then...
##		[ $DEBUG -gt 0 ] && echo -e "\tPackage already installed..." >>"$LOG_DBUG"
##		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[exists] ${APPNAME}.${APPTYPE}"
## UPDATED 2025/11/04 - unsure why RESTORE was added here since it doesn't have anything to do with installation
##	[ "$INSTALL" ] && [ ! "$FORCE" ] && [ ! "$RESTORE" ] && [ -e "${DIR_LIST}/${FILENAME}" ] && {			# if we're installing -AND- not forcing -AND- the software is already installed, then...
#	[ "$INSTALL" ] && [ ! "$FORCE" ] && [ -e "${DIR_LIST}/${FILENAME}" ] && {					# if we're installing -AND- not forcing -AND- the software is already installed, then...
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage already installed..." >>"$LOG_DBUG"
#		showMsg 'step' "[exists] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
#		return 0
#	}
## UPDATED 2025/10/31 - replace APP* variables and using showMsg()
##	[ "$RESTORE" ] && [ ! "$FORCE" ] && [ -e "${DIR_LIST}/${APPFILE}" ] && {					# if the iterated dependency is already installed, then go to the next one!
##		[ $DEBUG -gt 0 ] && echo -e "\tPackage currently installed..." >>"$LOG_DBUG"
##		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[exists] ${APPNAME}.${APPTYPE}"
#	[ "$RESTORE" ] && [ ! "$FORCE" ] && [ -e "${DIR_LIST}/${FILENAME}" ] && {					# if we're restoring from a restore point -AND- not forcing -AND- the software is already installed, then...
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage currently installed..." >>"$LOG_DBUG"
#		showMsg 'step' "[exists] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
#		return 0
#	}
# UPDATED 2025/12/01
#	( [ "$INSTALL" ] || [ "$RESTORE" ] ) && [ ! "$FORCE" ] && [ -e "${DIR_LIST}/${FILENAME}" ] && {			# if we're installing or restoring -AND- not forcing -AND- the software is already installed, then...
	[ "$INSTALL" ] && [ ! "$FORCE" ] && [ -e "${DIR_LIST}/${FILENAME}" ] && {			# if we're installing -AND- not forcing -AND- the software is already installed, then...
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage currently installed..." >>"$LOG_DBUG"
		showMsg 'dependency' "[exists] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		[ $INDEX -eq 0 ] && {
			showMsg 'failure' "The package is currently installed." 'log'
			return 1
		}
		echo -e "\tThe dependency is currently installed." >>"$LOG_DBUG"
		return 0												# NOTE: this has to be a 0 because already installed packages (e.g. dependencies) would trigger failure
	}
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#	[ "$RESTORE" ] && [ ! -e "${APPFILE}" ] && {									# if the dependency is not in the restore point directory (pwd), then it must be already in 'optional' as a dep for another software
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is not in restore point..." >>"$LOG_DBUG"
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[absent] ${APPNAME}.${APPTYPE}"
	[ "$RESTORE" ] && [ ! -e "${REPO_SOURCE}/${FILENAME}" ] && {									# if the package/dependency is not in the restore point directory, then...
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is not in restore point..." >>"$LOG_DBUG"
		showMsg 'dependency' "[absent] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is not in the restore point." 'log'
		return 1
	}
# UPDATED 2025/10/22 - merged -P with -U
#	[ "$UNLOAD" ] && [ ! -e "${DIR_LIST}/${APPFILE}" ] && [ "$PURGE" -eq '0' ] && {					# if the iterated dependency is already unloaded -AND- we aren't uninstalling it, then go to the next one!
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#	[ "$UNLOAD" ] && [ ! -e "${DIR_LIST}/${APPFILE}" ] && [ "$PURGE" = '' ] && {					# if the iterated dependency is already unloaded -AND- we aren't uninstalling it, then go to the next one!
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage already unloaded..." >>"$LOG_DBUG"
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[absent] ${APPNAME}.${APPTYPE}"
# UPDATED 2025/11/3
#	[ "$UNLOAD" ] && [ ! -e "${DIR_LIST}/${FILENAME}" ] && [ "$PURGE" = '' ] && {					# if the iterated dependency is already unloaded -AND- we aren't uninstalling it, then go to the next one!
	[ "$UNLOAD" = 'unload' ] && [ ! -e "${DIR_LIST}/${FILENAME}" ] && {					# if the iterated dependency is already unloaded -AND- we are just unloading (not uninstalling it: delete or purge), then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tThe package is already unloaded." >>"$LOG_DBUG"				# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'dependency' "[absent] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0
	}
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#	[ "$UNLOAD" ] && ( echo ",$IGNORE" | grep -q ",$APPHEAD" ) && {							# if the iterated dependency is ignored -AND- we are unloading/uninstalling it, then go to the next one!
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is being ignored..." >>"$LOG_DBUG"
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[ignore] ${APPNAME}.${APPTYPE}"
# UPDATED 2025/11/04 - broadened the search range to be either a PACKAGE name or full FILENAME
#	[ "$UNLOAD" ] && ( echo ",${IGNORE}," | grep -q ",${BASENAME}," ) && {							# if the iterated dependency is ignored -AND- we are unloading/uninstalling it, then go to the next one!
	[ "$UNLOAD" ] && ( echo ",${IGNORE}," | grep -qE ",(${PACKAGE}|${FILENAME})," ) && {							# if the iterated dependency is ignored -AND- we are unloading/uninstalling it, then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tThe package was passed in the ignore list..." >>"$LOG_DBUG"			# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'dependency' "[ignore] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0
	}
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#	[ "$UNLOAD" ] && ( [ -L "${DIR_LIST}/${APPHEAD}.soft" ] || [ ! -s "${DIR_LIST}/${APPHEAD}.soft" ] ) && {	# if the iterated dependency is on DATA (via symlink) or BOOT (via 0 byte file), then go to the next one!
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is being ignored (BOOT)..." >>"$LOG_DBUG"
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[ BOOT ] ${APPNAME}.${APPTYPE}"
# UPDATED 2025/11/17 - had to remove the symlink check since this is the new way of
#	[ "$UNLOAD" ] && ( [ -L "${DIR_LIST}/${FILENAME}" ] || [ ! -s "${DIR_LIST}/${FILENAME}" ] ) && {	# if the iterated dependency is on DATA (via symlink) or BOOT (via 0 byte file), then go to the next one!
	[ "$UNLOAD" ] && [ ! -s "${DIR_LIST}/${FILENAME}" ] && {	# if the iterated dependency is on DATA (via symlink) or BOOT (via 0 byte file), then go to the next one!
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is being ignored (FIRMWARE package)..." >>"$LOG_DBUG"
		[ $DEBUG -gt 0 ] && echo -e "\tWARNING:    The package is part of the base OS and can't be modified." >>"$LOG_DBUG"
		showMsg 'dependency' "[SYSTEM] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
# REMOVED 2025/11/18 - this is no longer a failure
#		showMsg 'failure' "The package is part of the base OS and can't be modified." 'log'
		return 0												# NOTE: we don't exit with failure since this could just be a dependency and left installed
	}
# UPDATED 2025/11/07 - removed COPY since it would already error out with the other check above; also we simply need to check if it's local or not
#	( [ "$COPY" ] || [ "$UNLOAD" ] || [ "$VALIDATE" ] ) && [ "$SOURCE" = 'remote' ] && {				# if we are copying, unloading/uninstalling, or validating -AND- the iterated dependency is considered 'remote' (can't be found due to needing a proper -S value) then, go to the next one!
	( [ "$UNLOAD" ] || [ "$VALIDATE" ] ) && [ ! -e "${REPO_SOURCE}/${FILENAME}" ] && {				# if we are copying, unloading/uninstalling, or validating -AND- the iterated dependency is not present, then go to the next one!
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is missing..." >>"$LOG_DBUG"
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[absent] ${APPNAME}.${APPTYPE}"
		showMsg 'dependency' "[absent] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is missing from REPO_SOURCE." 'log'
		return 1
	}
# LEFT OFF - can we merge some of these common checks?
	[ "$VALIDATE" ] && ( echo ",${IGNORE}," | grep -qE ",(${PACKAGE}|${FILENAME})," ) && {							# if the iterated dependency is ignored -AND- we are unloading/uninstalling it, then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tThe package was passed in the ignore list..." >>"$LOG_DBUG"			# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'dependency' "[ignore] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0
	}

	# check that the dependency is not already in the list to be processed
# UPDATED 2025/11/05 - to reduce duplicates once they've been proceeded
#	if [ ! "$TREE" ] && [ ! "$VALIDATE" ]; then						# if we're not displaying a dependency tree -OR- validating packages, then...
# REMOVED 2025/12/04 - this can be adjusted via the -Q option
#	if [ ! "$TREE" ]; then									# if we're not displaying a dependency tree, then...
		[ $DEBUG -gt 0 ] && echo -en "\tChecking if dependency is already marked for processing:" >>"$LOG_DBUG"
#echo 'checking deps listing'
#		if [ "$UNLOAD" ]; then
if [ "$UNLOAD" ] && ( ! echo "${UNLOAD}" | grep -q 2 ); then
			[ -e "${DIR_TEMP}/unload.${EXEID}" ] && ( grep -q "$FILENAME" "${DIR_TEMP}/unload.${EXEID}" ) && {
				[ $DEBUG -gt 0 ] && echo " [yes]" >>"$LOG_DBUG"
# UPDATED 2025/11/19
#				showMsg 'step' "[duplct] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1			# other possible values: marked, double, listed
				showMsg 'duplicate' "[duplct] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1			# other possible values: marked, double, listed
				return 0
			}
		else
				if ( inDependencies $FILENAME ); then
# UPDATED 2025/11/26
#			for DEPFILE in $(seq 1 $INDEX); do						# check if the dependencies has already been added to the list to be processed, so...
#				eval TEMP="\$DEP$DEPFILE"						#   since busybox 'sh' does not support arrays, we have to use this method to check each stored dependency
##echo "comparing |$TEMP|$FILENAME|"
## UPDATED 2025/11/05 - updated to be the full filename to prevent any issues with different TYPEs
##				if [ "$TEMP" = "$RAWFILE" ]; then					#   if the iterated dependency is already in the list (including any specific version number), then...
#				if [ "$TEMP" = "$FILENAME" ]; then					#   if the iterated dependency is already in the list (including any specific version number), then...
					[ $DEBUG -gt 0 ] && echo " [yes]" >>"$LOG_DBUG"

# UPDATED 2025/11/19
#					[ "$VALIDATE" ] && showMsg 'step' "[duplicate] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1	# other possible values: processed
					[ "$VALIDATE" ] && showMsg 'duplicate' "[duplicate] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1	# other possible values: processed
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#					( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[marked] ${APPNAME}.${APPTYPE}"
	#				showMsg 'step' "[marked] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
# UPDATED 2025/11/19
#					[ ! "$VALIDATE" ] && showMsg 'step' "[duplct] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1			# other possible values: marked, double, listed
					[ ! "$VALIDATE" ] && showMsg 'duplicate' "[duplct] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1			# other possible values: marked, double, listed
					return 0
				fi
#			done
		fi
		[ $DEBUG -gt 0 ] && echo " [no]" >>"$LOG_DBUG"
#	fi

	# --- IF WE HAVE MADE IT HERE, THEN DO SOME WORK ---

if [ 1 -eq 0 ]; then
	if [ "$UNLOAD" ] && [ ! "$FORCE" ]; then						# if we're unloading the package, then...
# REMOVED 2025/11/07
#		RELEASE=1									#   (re)set the value
# UPDATED 2025/10/31
#		for DEPFILE in $(ls -1 "$DIR_LIST" 2>/dev/null | grep 'soft'$); do		#   for each currently installed package we need to see if any depend on the package to be unloaded, so...
		for DEPFILE in $(ls -1 "$DIR_LIST" 2>/dev/null | grep "${EXT_SOFT}"$); do		#   for each currently installed package we need to see if any depend on the package to be unloaded, so...
# UPDATED 2018/11/29
#			DEPNAME="$(echo "$DEPFILE" | head -c -5)"				#   since the files in DIR_INST are just NAME.TYPE, we need to split to form a whole filename
#			DEPTYPE="${DEPFILE##*.}"
# UPDATED 2025/10/31 - to use FILENAME
#			DEPNAME="$(echo "$DEPFILE" | head -c -14)"				#   since the files in DIR_LIST are NAME.ARCH.TYPE.EXTN, we need to split to form a whole filename
#			DEPTYPE="$(echo "$DEPFILE" | tail -c 9 | head -c 3)"
#
#			[ -e "${DIR_LIST}/${DEPNAME}.${CPU}.${DEPTYPE}.mark" ] && continue	# if the iterated dependency is already marked to be unloaded, then go to the next one
#			[ -e "${REPO_OPTION}/${DEPNAME}.${CPU}.${DEPTYPE}.deps" ] || continue	# if no .deps file exists for the iterated installed package, then continue since it does not depend on the package we are trying to unload
#
#			# if there is an EXEID -AND- the requested package is a dependency for the iterated installed software -AND- that iterated installed software is not in the EXEID file that can be uninstalled, then..
#			[ "$EXEID" ] && ( grep -q ^"$RAWFILE" "${REPO_OPTION}/${DEPNAME}.${CPU}.${DEPTYPE}.deps" ) && ( ! grep -q ^"${DEPNAME}.${CPU}.${DEPTYPE}.soft" "$EXEID" >/dev/null 2>&1 ) && {
#				[ $DEBUG -gt 0 ] && echo -e "\tOther software depends on this dependency..." >>"$LOG_DBUG"
#				( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[depend] [${DEPNAME}.${DEPTYPE}] ${APPNAME}.${APPTYPE}"
#				RELEASE=0							#   indicate that the dependency can not be removed
#				break								#   now break from the 'for' loop to conserve resources
#			}

# LEFT OFF - make sure this works with the installPackage() processing to prevent dependencies of other packages from getting uninstalled; can probably get rid of the files generated by installPackage()
			TEMP="${FILE_SCHEMA#*\}}"						#   remove just the package name portion from the package filename 'schema' - everything before the first '}' character
			eval TEMP="${TEMP}.${EXT_SOFT}"						#   combine the 'schema' (less the package name) values and the file extension value (e.g. i32.bin.soft)
			DEPNAME="$(echo $DEPFILE | sed "s/${TEMP}//")"				#   remove that combination from the passed package name (in case it was passed like bash.i32.bin.soft) to isolate just the package name (e.g. bash)
			DEPBASE="$(echo $DEPFILE | sed "s/.${EXT_SOFT}$//")"			#   remove the file extension from the name
			DEPTYPE="$(echo "$DEPFILE" | grep -oE '[\._\-](bin|dev|doc|drv|gir|lib|loc)' | sed -E 's/^[\._\-]//')"	# search for any variation of known type abbreviations and remove the preceeding separation character
			[ "$DEPTYPE" = '' ] && DEPTYPE='bin'					#   if the line above did not return any value, then default to 'bin'

			[ -e "${DIR_LIST}/${DEPBASE}.${EXT_MARK}" ] && continue			# if the iterated dependency is already marked to be unloaded, then go to the next one
# UPDATED 2025/11/04 - we are now using DIRECTORY
#			[ ! -e "${REPO_OPTION}/${DEPBASE}.deps" ] || continue			# if no .deps file exists for the iterated installed package, then continue since it does not depend on the package we are trying to unload
			[ ! -e "${DIRECTORY}/${DEPBASE}.${EXT_DEPS}" ] || continue		# if no .deps file exists for the iterated installed package, then continue since it does not depend on the package we are trying to unload

			# if there is an EXEID -AND- the requested package is a dependency for the iterated installed software -AND- that iterated installed software is not in the EXEID file that can be uninstalled, then..
# UPDATED 2025/11/04 - we are now using DIRECTORY
#			[ "$EXEID" ] && ( grep -q ^"$RAWFILE" "${REPO_OPTION}/${DEPBASE}.${EXT_DEPS}" ) && ( ! grep -q ^"${DEPFILE}" "$EXEID" >/dev/null 2>&1 ) && {
# UPDATED 2025/11/10
#			[ "$EXEID" ] && ( grep -q ^"$RAWFILE" "${DIRECTORY}/${DEPBASE}.${EXT_DEPS}" ) && ( ! grep -q ^"${DEPFILE}" "$EXEID" >/dev/null 2>&1 ) && {
# UPDATED 2025/11/12 - the filename has changed, and removed the beginning condition sine EXEID will always have a value
#			[ "$EXEID" ] && ( grep -q ^"$RAWFILE" "${DIRECTORY}/${DEPBASE}.${EXT_DEPS}" ) && ( ! grep -q ^"${DEPFILE}" "${DIR_TEMP}/${EXEID}" >/dev/null 2>&1 ) && {
			( grep -q ^"$RAWFILE" "${DIRECTORY}/${DEPBASE}.${EXT_DEPS}" ) && ( ! grep -q ^"${DEPFILE}" "${DIR_TEMP}/installed.${EXEID}" >/dev/null 2>&1 ) && {
				[ $DEBUG -gt 0 ] && echo -e "\tOther software depends on this dependency..." >>"$LOG_DBUG"			# NOTE: we left this line like this since this is not a failure, but just a package to skip
				showMsg 'step' "[depend] [(${DEPTYPE}) ${DEPNAME}] (${FILETYPE})${INDENT} ${PACKAGE}" 'both' 1 1
# REMOVED 2025/11/07
#				RELEASE=0							#   indicate that the dependency can not be removed
#				break								#   now break from the 'for' loop to conserve resources
				return 0
			}
		done
# REMOVED 2025/11/07
#		[ "$RELEASE" = '0' ] && return 0						#   if the dependency has NOT been released to unload, then don't!
	fi
fi

	# determine if the SOURCE is remote or local, then...					# NOTE: for any actions that must perform locally, an error would have already been issued above
	[ -e "${REPO_SOURCE}/${FILENAME}" ] && SOURCE=' local'
	[ ! -e "${REPO_SOURCE}/${FILENAME}" ] && {
		( echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) || {
			showMsg 'step' "[!REPO!] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
			showMsg 'failure' "The package needs to be downloaded, but the REPO_SOURCE is local." 'log'
			return 1
		}
		SOURCE='remote'
	}

	# display the package name to the output targets
	if [ "$TREE" ]; then
# UPDATED 2025/11/05 - replaced the APP* variables
#		echo "${INDENT}${APPNAME}.${APPTYPE}"
# UPDATED 2025/12/05
#		[ ! "$OPTFILE" ] && echo "${INDENT}${PACKAGE} (${FILETYPE})"
#		[ "$OPTFILE" ] && echo "${INDENT}${PACKAGE} (${FILETYPE}) [optional]"
		[ ! "$INDENT" ] && [ ! "$OPTFILE" ] && showMsg 'package' "${INDENT}${PACKAGE} (${FILETYPE})" 'screen' 1 4	# if this is the package being processed, then...
		[ "$INDENT" ] && [ ! "$OPTFILE" ] && showMsg 'file' "${INDENT}${PACKAGE} (${FILETYPE})" 'screen' 1 1		# if this is a depends/dependency package, then...
		[ "$OPTFILE" ] && showMsg 'file' "${INDENT}${PACKAGE} (${FILETYPE}) [optional]" 'screen' 1 1			# if this is an optional depends/dependency package, then...
	elif [ "$VALIDATE" ]; then
# REMOVED 2025/11/07 - this would be caught in the checks above
#		[ "$SOURCE" = 'remote' ] && showMsg 'step' "[ missing ] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
# UPDATED 2025/11/05 - replaced the APP* variables
#		[ -e "${DIR_LIST}/${APPFILE}" ] && showMsg 'step' "[installed] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		[ -e "${DIR_LIST}/${FILENAME}" ] && showMsg 'step' "[installed] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
# REMOVED 2025/11/14
#	elif [ "$UNLOAD" ]; then
#		showMsg 'step' "[marked] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
	else
# UPDATED 2025/11/19
#		showMsg 'step' "[${SOURCE}] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'dependency' "[${SOURCE}] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
	fi

	# add the passed dependency to the stack
# UPDATED 2025/11/17
#	[ ! "$UNLOAD" ] && addDependency "${FILENAME}"								# add the passed package to the stack to be processed outside of this function
	[ ! "$TREE" ] && ( [ ! "$UNLOAD" ] || ( echo "${UNLOAD}" | grep -q 2 ) ) && addDependency "${FILENAME}"								# if we're NOT unloading -OR- we're on the 2nd stage of unloading, then add the passed package to the stack to be processed outside of this function
	[ ! "$TREE" ] && ( [ ! "$UNLOAD" ] || ( echo "${UNLOAD}" | grep -q 2 ) ) && [ $DEBUG -gt 0 ] && echo "processDependencies (returned):" >>"$LOG_DBUG"

# REMOVED 2025/11/14 - we're changing how this works
#	[ "$INSTALL" ] && echo "$FILENAME" >>"${DIR_TEMP}/installed.${EXEID}"			# add the dependency to the listing for the package
# UPDATED 2025/11/17
#	[ "$UNLOAD" ] && echo "$FILENAME" >>"${DIR_TEMP}/unload.${EXEID}"			# add the dependency to the listing for all packages to unload
	[ "$UNLOAD" ] && ( ! echo "${UNLOAD}" | grep -q 2 ) && echo "$FILENAME" >>"${DIR_TEMP}/unload.${EXEID}"			# if we ARE unloading -AND- it's the first stage, then add the dependency to the listing for all packages to unload
	[ "$UNLOAD" ] && ( ! echo "${UNLOAD}" | grep -q 2 ) && [ $DEBUG -gt 0 ] && echo -e "\tAdding dependency to the unload list: [done]" >>"$LOG_DBUG"

# MERGED 2025/11/26 - this is now -D none
#	[ "$ONLY" ] && {									# if we are only affecting the package itself and not any dependencies, then...
	[ "$DEPS" = 'none' ] && {									# if we are only affecting the package itself and not any dependencies, then...
# UPDATED 2025/11/24 - to be more generic
#		[ $DEBUG -gt 0 ] && echo -e "\tDownloading only the package, not any dependencies..." >>"$LOG_DBUG"
		[ $DEBUG -gt 0 ] && echo -e "\tProcessing only the package, not any dependencies..." >>"$LOG_DBUG"
# UPDATED 2025/11/05 - updated to be the full filename to prevent any issues with different TYPEs
#		addDependency "${RAWFILE}"							#   add the passed package to the stack to be processed outside of this function
# REMOVED 2025/11/07 - re-arranged the code so that this step is already taken above
#		addDependency "${FILENAME}"							#   add the passed package to the stack to be processed outside of this function
		return 0									#   now exit this function!
	}

	# obtain or copy the software .deps file
# UPDATED 2025/11/04 - turn this into the actions that do use this; also implement REPO_SOURCE and directory
#	if [ ! "$UNLOAD" ] && [ ! "$TREE" ] && [ ! "$VALIDATE" ] && [ "$SOURCE" = 'remote' ]; then		# if copying, downloading, or installing from an external source, then...	NOTE: this can NOT be '[ "$DOWNLOAD" ]' since more than one ACTION can utilize remote sources
#		cd "$TARGET" >>"$LOG_ERRS" 2>&1							# change into the desired TARGET directory before executing the download
#		[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.deps\"" >>"$LOG_DBUG"
#		wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.deps" >>"$LOG_ERRS" 2>&1				#   get any .deps file for the dependency itself
#	elif [ "$COPY" ] && [ -e "./${APPHEAD}.deps" ]; then					# NOTE: only the COPY will apply to this section
#		[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.deps\" \"${TARGET}\"" >>"$LOG_DBUG"
#		[ -e "./${APPHEAD}.deps" ] && cp -f "./${APPHEAD}.deps" "${TARGET}" >>"$LOG_ERRS" 2>&1
#	fi

# REMOVED 2025/12/05 - we are now calling downPackage() to handle this aspect
#	[ "$VERSION" ] && [ $INDEX -eq 1 ] && BASENAME="$VERBASE"

# UPDATED 2025/11/07 - copy is strictly offline
#	if ( [ "$COPY" ] || [ "$DOWNLOAD" ] || [ "$INSTALL" ] ) && [ "$SOURCE" = 'remote' ]; then # if copying, downloading, or installing from an external source, then...	NOTE: we are already in the target storage directory
# UPDATED 2025/11/14
#	if ( [ "$COPY" ] || [ "$DOWNLOAD" ] || [ "$INSTALL" ] ); then 				# if copying, downloading, or installing from an external source, then...	NOTE: we are already in the target storage directory
# UPDATED 2025/11/24
#	if ( [ "$COPY" ] || [ "$DOWNLOAD" ] || [ "$INSTALL" ] || [ "$UNLOAD" ] ); then 				# if we're copying, downloading, installing, or unloading, then...	NOTE: we are already in the target storage directory
# REMOVED 2025/12/04 - only these actions use this function anyways
#	if ( [ "$COPY" ] || [ "$DOWNLOAD" ] || [ "$EXTRACT" ] || [ "$INSTALL" ] || [ "$UNLOAD" ] ); then 				# if we're copying, downloading, installing, or unloading, then...	NOTE: we are already in the target storage directory
# UPDATED 2025/12/02
#		if [ ! "$COPY" ] && [ "$SOURCE" = 'remote' ]; then
		if ( [ "$DOWNLOAD" ] || [ "$INSTALL" ] ) && [ "$SOURCE" = 'remote' ]; then
# UPDATED 2025/12/05 - we are letting downloadPackage() handle this
#			eval SOURCE="${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}"				#   re-purpose SOURCE (since we're done using it for its original intention) incase REPO_SOURCE has any variables in it
#			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    wget -cq \"${SOURCE}\"" >>"$LOG_DBUG"
#			wget -cq "${SOURCE}" >/dev/null 2>&1 || return 0				#   get any .deps file for the dependency itself	NOTE: we can't exit with an error since some packages do not have one of these files
			downloadPackage DEPS || return 0				#   get any .deps file for the dependency itself	NOTE: we can't exit with an error since some packages do not have one of these files
			[ $DEBUG -gt 0 ] && echo "processDependencies (returned):" >>"$LOG_DBUG"
# UPDATED 2025/12/02 - swapped locations so we don't have to copy .deps files
#		elif ( [ "$COPY" ] || [ "$EXTRACT" ] ) && [ -e "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" ]; then		# if we're copying and the dependency has a .deps file, then copy it over too!
		elif [ "$COPY" ] && [ -e "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" ]; then		# if we're copying and the dependency has a .deps file, then copy it over too!
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}\" './'" >>"$LOG_DBUG"
			cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" './' >/dev/null 2>&1 || {	#   copy the corresponding deps file
				showMsg 'failure' "The package deps file copy failed (${BASENAME}.${EXT_DEPS})." 'log'
				return 1
			}
		fi
#echo "checking |${BASENAME}.${EXT_DEPS}|"
#pwd

		# process all the dependencies of the passed software
		[ $DEBUG -gt 0 ] && echo -en "\tChecking for package dependency file:" >>"$LOG_DBUG"
		[ ! -e "${BASENAME}.${EXT_DEPS}" ] && [ $DEBUG -gt 0 ] && echo -e " [absent] [done]" >>"$LOG_DBUG"
		if [ -e "${BASENAME}.${EXT_DEPS}" ]; then
			[ $DEBUG -gt 0 ] && echo -e " [exists] [processing]" >>"$LOG_DBUG"
#echo "BASENAME |$BASENAME|" >>$LOG_DBUG
# UPDATED 2025/11/14 - so that DRYRUN would work correctly
#			for DEPFILE in $(cat "./${BASENAME}.${EXT_DEPS}" 2>/dev/null); do			# if the passed dependency also has dependencies, then...
			# NOTE: we have to include DRYRUN as part of the command so the file gets deleted correctly; BASENAME would only have the name of the last dependency for an after-for-loop removal
			for DEPFILE in $(cat "./${BASENAME}.${EXT_DEPS}" 2>/dev/null && [ "$DRYRUN" ] && ( [ "$COPY" ] || [ "$DOWNLOAD" ] ) && rm -f "./${BASENAME}.${EXT_DEPS}" 2>>"$LOG_ERRS"); do			# if the passed dependency also has dependencies, then...
#echo "DEPFILE |$DEPFILE|" >>$LOG_DBUG
				processDependencies "$DEPFILE" "$INDENT  " || return 1				# WARNING: this line needs to execute no matter the outcome of the 'wget' call above (so the addDependency() call can be made if needed) -AND- it needs to be the unaltered DEPFILE variable with any contained version number!!!
			done
		fi
#	fi

	# add the passed dependency to the stack
# MOVED/UPDATED 2025/11/04 - moved above since we need to repurpose SOURCE and swapped APP* variables
#	if [ "$TREE" ]; then
#		echo "${INDENT}${APPNAME}.${APPTYPE}"
#	elif [ "$VALIDATE" ]; then
#		[ "$SOURCE" = 'remote' ] && echo "[ missing ] ${APPNAME}.${APPTYPE}"
#		[ -e "${DIR_LIST}/${APPFILE}" ] && echo "[installed] ${APPNAME}.${APPTYPE}"
#	elif [ "$UNLOAD" ]; then
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[marked] ${APPNAME}.${APPTYPE}"
#	else
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[${SOURCE}] ${APPNAME}.${APPTYPE}"
#	fi
# UPDATED 2025/11/05 - updated to be the full filename to prevent any issues with different TYPEs
#	addDependency "${RAWFILE}"								# at least add the passed package to the stack to be processed outside of this function
# MOVED 2025/11/07 - this was moved above the "obtain or copy the software .deps file" section
#	addDependency "${FILENAME}"								# add the passed package to the stack to be processed outside of this function
## UPDATED 2025/11/04 - replaced APP*
##	[ ! -f "${APPHEAD}.deps" ] && return 0							# if no dependency file exists for the passed package, then no need to process anything else in this function!	NOTE: we must put this here instead of the top since we need to (at least) process the first passed package!
##	[ "$UNLOAD" ] && touch "${DIR_LIST}/${APPHEAD}.mark"
# REMOVED 2025/11/05 - this is no longer required since the re-arrangement of code
#	[ ! -f "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" ] && return 0				# if no dependency file exists for the passed package, then no need to process anything else in this function!	NOTE: we must put this here instead of the top since we need to (at least) process the first passed package!
# REMOVED 2025/11/14
#	[ "$UNLOAD" ] && touch "${DIR_LIST}/${BASENAME}.${EXT_MARK}"

# MOVED 2025/11/07 - moved into the "obtain or copy the software .deps file" section
#	# process all the dependencies of the passed software
## UPDATED 2025/11/04 - replaced APP*
##	for DEPFILE in $(cat "${APPHEAD}.deps" 2>/dev/null); do					# if the passed dependency also has dependencies, then...
## UPDATED 2025/11/07 - this should process the just-downloaded .deps file
##	for DEPFILE in $(cat "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" 2>/dev/null); do		# if the passed dependency also has dependencies, then...
#	for DEPFILE in $(cat "./${BASENAME}.${EXT_DEPS}" 2>/dev/null); do			# if the passed dependency also has dependencies, then...
#		processDependencies "$DEPFILE" "$INDENT  " || return 1				# WARNING: this line needs to execute no matter the outcome of the 'wget' call above (so the addDependency() call can be made if needed) -AND- it needs to be the unaltered DEPFILE variable with any contained version number!!!
#	done
	return 0
}


# Usage syntax: copyPackage
# Overview:	copies the .soft and .hash files from a local directory to another local directory
# Notes:	the directory containing the file(s)-to-copy should already be entered BEFORE calling this function!
#		no need to copy the .deps file since that was handled via processDependencies().
copyPackage() {
	[ $DEBUG -gt 0 ] && { echo -en "copyPackage:\n\tRAWFILE     |${RAWFILE}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${ARCH}|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	[ "$REPO_SOURCE" = "$DIRECTORY" ] && {
		showMsg 'failure' "The source and target locations are the same."
		return 1
	}

	showMsg 'file' " [pack]" 'both' 0 0
	[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"${REPO_SOURCE}/${BASENAME}.${EXT_SOFT}\" './'" >>"$LOG_DBUG"
# UPDATED 2025/11/10
#	cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_SOFT}" './' >>"$LOG_ERRS" 2>&1 || {		# copy the .soft file from the source directory
	[ ! "$DRYRUN" ] && ( cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_SOFT}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {	# copy the .soft file from the source directory
		showMsg 'failure' "The package copy failed (${BASENAME}.${EXT_SOFT})." 'log'
		return 1
	}

	showMsg 'file' " [hash]" 'both' 0 0
	[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"${REPO_SOURCE}/${BASENAME}.${EXT_HASH}\" './'" >>"$LOG_DBUG"
# UPDATED 2025/11/10
#	cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_HASH}" './' >>"$LOG_ERRS" 2>&1 || {		# copy the corresponding hash file
	[ ! "$DRYRUN" ] && ( cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_HASH}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {	# copy the corresponding hash file
		showMsg 'failure' "The package hash file copy failed (${BASENAME}.${EXT_HASH})." 'log'
		return 1
	}

	if [ -e "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" ] && [ ! -e "./${BASENAME}.${EXT_DEPS}" ]; then						# NOTE: this had to be added in case '-D none' was passed
		showMsg 'file' " [deps]" 'both' 0 0
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}\" './'" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && ( cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {	# copy the corresponding hash file
			showMsg 'failure' "The package hash file copy failed (${BASENAME}.${EXT_DEPS})." 'log'
			return 1
		}
	fi

	if [ "$EXTRA" ]; then
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'code' ]; then
			if [ -e "${REPO_SOURCE}/${BASENAME}.${EXT_CODE}" ]; then
				showMsg 'file' " [code]" 'both' 0 0
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.${EXT_CODE}\" './'" >>"$LOG_DBUG"
# UPDATED 2025/11/10
#				cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_CODE}" './' >>"$LOG_ERRS" 2>&1 || {	# copy the corresponding code file
				[ ! "$DRYRUN" ] && ( cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_CODE}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {	# copy the corresponding code file
					showMsg 'failure' "The package source code file copy failed (${BASENAME}.${EXT_CODE})." 'log'
					return 1
				}
			fi
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'cpio' ]; then
			if [ -e "${REPO_SOURCE}/${BASENAME}.cpio" ]; then
				showMsg 'file' " [cpio]" 'both' 0 0
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.cpio\" './'" >>"$LOG_DBUG"
# UPDATED 2025/11/10
#				cp -f "${REPO_SOURCE}/${BASENAME}.cpio" './' >>"$LOG_ERRS" 2>&1 || {		# copy the corresponding cpio file
				[ ! "$DRYRUN" ] && ( cp -f "${REPO_SOURCE}/${BASENAME}.cpio" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {		# copy the corresponding cpio file
					showMsg 'failure' "The package cpio file copy failed (${BASENAME}.cpio)." 'log'
					return 1
				}
			fi
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'info' ]; then
			if [ -e "${REPO_SOURCE}/${BASENAME}.${EXT_INFO}" ]; then
				showMsg 'file' " [info]" 'both' 0 0
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.${EXT_INFO}\" './'" >>"$LOG_DBUG"
# UPDATED 2025/11/10
#				cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_INFO}" './' >>"$LOG_ERRS" 2>&1 || {	# copy the corresponding info file
				[ ! "$DRYRUN" ] && ( cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_INFO}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {	# copy the corresponding info file
					showMsg 'failure' "The package info file copy failed (${BASENAME}.${EXT_INFO})." 'log'
					return 1
				}
			fi
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'list' ]; then
			if [ -e "${REPO_SOURCE}/${BASENAME}.${EXT_LIST}" ]; then
				showMsg 'file' " [list]" 'both' 0 0
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.${EXT_LIST}\" './'" >>"$LOG_DBUG"
# UPDATED 2025/11/10
#				cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_LIST}" './' >>"$LOG_ERRS" 2>&1 || {	# copy the corresponding list file
				[ ! "$DRYRUN" ] && ( cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_LIST}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {	# copy the corresponding list file
					showMsg 'failure' "The package manifest file copy failed (${BASENAME}.${EXT_LIST})." 'log'
					return 1
				}
			fi
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'make' ]; then
			if [ -e "${REPO_SOURCE}/${BASENAME}.${EXT_MAKE}" ]; then
				showMsg 'file' " [make]" 'both' 0 0
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.${EXT_MAKE}\" './'" >>"$LOG_DBUG"
# UPDATED 2025/11/10
#				cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_MAKE}" './' >>"$LOG_ERRS" 2>&1 || {	# copy the corresponding make file
				[ ! "$DRYRUN" ] && ( cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_MAKE}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {	# copy the corresponding make file
					showMsg 'failure' "The package make file copy failed (${BASENAME}.${EXT_MAKE})." 'log'
					return 1
				}
			fi
		fi
	fi

	return 0




# UPDATED 2025/11/04
	local TARGET=''
	[ "$REPO_TARGET" ] && TARGET="$REPO_TARGET" || TARGET="$REPO_OPTION"			# if a different target was specified, then store that as the target, otherwise use the default value

	[ $DEBUG -gt 0 ] && { echo -en "copyPackage:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tTARGET  :${TARGET}:\n\tpwd     " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.soft\" \"$TARGET\"" >>"$LOG_DBUG"
	cp -f "./${APPHEAD}.soft" "$TARGET" >>"$LOG_ERRS" 2>&1 || {				# copy the .soft file from the source directory
		[ "$SILENT" ] || echo "ERROR: package copy failed (${APPHEAD}.soft)." >>"$LOG_ERRS"
		return 1
	}
	[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.hash\" \"$TARGET\"" >>"$LOG_DBUG"
	cp -f "./${APPHEAD}.hash" "$TARGET" >>"$LOG_ERRS" 2>&1 || {				# copy the corresponding hash file
		[ "$SILENT" ] || echo "ERROR: package hash copy failed (${APPHEAD}.hash)." >>"$LOG_ERRS"
		return 1
	}

	if [ "$EXTRA" ]; then
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'info' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.info\" \"$TARGET\"" >>"$LOG_DBUG"
			[ -e "./${APPHEAD}.info" ] && cp -f "./${APPHEAD}.info" "$TARGET" >>"$LOG_ERRS" 2>&1	# copy the corresponding info file
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'list' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.list\" \"$TARGET\"" >>"$LOG_DBUG"
			[ -e "./${APPHEAD}.list" ] && cp -f "./${APPHEAD}.list" "$TARGET" >>"$LOG_ERRS" 2>&1	# copy the corresponding list file
		fi
	fi

	return 0
}


# Usage syntax: downloadPackage DEPS
# Overview:	downloads the .soft and .hash files from the repo and compares the package checksum to validate the download
# Notes:	the directory to store the obtained file(s) should already be entered BEFORE calling this function!
#		no need to copy the .deps file since that was handled via processDependencies().
# Parameters:
# DEPS		[boolean] if we just need to get the .deps file for the package (via a processDependencies() call)
downloadPackage() {
# UPDATED 2025/12/05
#	local BASE="${BASENAME}"
#	local FILE="${BASENAME}.${EXT_SOFT}"
#	[ "$VERBASE" ] && BASE="$VERBASE"
#	[ "$VERFILE" ] && FILE="$VERFILE"
	local BASE_SOURCE="${BASENAME}"
	local FILE_SOURCE="${BASENAME}.${EXT_SOFT}"
	[ "$VERBASE" ] && eval BASE_SOURCE="${VERBASE}"
	[ "$VERFILE" ] && eval FILE_SOURCE="${VERFILE}"
	local BASE_TARGET="${BASENAME}"
	local FILE_TARGET="${BASENAME}.${EXT_SOFT}"
	[ "$VERBASE" ] && eval BASE_TARGET="${VERT_SCHEMA}"
	[ "$VERFILE" ] && eval FILE_TARGET="${BASE_TARGET}.${EXT_SOFT}"
	eval REPO_SOURCE="${REPO_SCHEMA}"							# eval REPO_SOURCE incase it has any variables in it
#echo "BASE_SOURCE |$BASE_SOURCE|"
#echo "FILE_SOURCE |$FILE_SOURCE|"
#echo "BASE_TARGET |$BASE_TARGET|"
#echo "FILE_TARGET |$FILE_TARGET|"

	[ $DEBUG -gt 0 ] && { echo -en "downloadPackage:\n\tRAWFILE     |${RAWFILE}|\n\tFILENAME    |${FILE}|\n\tBASENAME    |${BASE_SOURCE}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${ARCH}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\tOPTFILE     |${OPTFILE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	( echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) || {					# make sure the SOURCE is remote
		showMsg 'failure' "A non-Internet value is set for REPO_SOURCE." 'log'
		return 1
	}

	if [ "$1" ]; then
		[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_DEPS}\" -O \"./${BASE_TARGET}.${EXT_DEPS}\"" >>"$LOG_DBUG"
		wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_DEPS}" -O "./${BASE_TARGET}.${EXT_DEPS}" >/dev/null 2>&1
		[ ! -e "./${BASE_TARGET}.${EXT_DEPS}" ] && return 1				# if no .deps file exists, then exit so processDependencies() knows to exit

		BASENAME="${BASE_TARGET}"							# adjust the name so processDependencies() can perform the last step before this variable value gets overwritten
#echo "basename |$BASENAME|"
		return 0
	fi

	showMsg 'file' " [pack]" 'both' 0 0
	[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_SOFT}\" -O \"./${BASE_TARGET}.${EXT_SOFT}\"" >>"$LOG_DBUG"
# UPDATED 2025/11/07 - updated to output to the log correctly
#	wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_SOFT}" >>"$LOG_ERRS" 2>&1 || {			# download the package file from the repo
#	( [ ! -e "${BASE_SOURCE}.${EXT_SOFT}" ] || [ ! -s "${BASE_SOURCE}.${EXT_SOFT}" ] ) && {		# if the file wasn't downloaded, or it's a zero byte file, then...	NOTE: this uses the 'pwd' as the download directory via 'wget'
	[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_SOFT}" -O "./${BASE_TARGET}.${EXT_SOFT}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the package file from the repo	NOTE: the string of commands outputs to the pax.log correctly while still returning a proper exit code from wget
		showMsg 'failure' "The package file download failed (${BASE_SOURCE}.${EXT_SOFT})." 'log'
		return 1
	}

	showMsg 'file' " [hash]" 'both' 0 0
	[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_HASH}\" -O \"./${BASE_TARGET}.${EXT_HASH}\"" >>"$LOG_DBUG"
# UPDATED 2025/11/07 - updated to output to the log correctly
#	wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_HASH}" >>"$LOG_ERRS" 2>&1			# download the corresponding hash file
#	( [ ! -e "${BASE_SOURCE}.${EXT_HASH}" ] || [ ! -s "${BASE_SOURCE}.${EXT_HASH}" ] ) && {
	[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_HASH}" -O "./${BASE_TARGET}.${EXT_HASH}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the corresponding hash file
		showMsg 'failure' "The package hash file download failed (${BASE_SOURCE}.${EXT_HASH})." 'log'
		return 1
	}

	# if we ARE installing a specific version of the software, then...
# UPDATED 2025/12/05
#	[ $DEBUG -gt 0 ] && [ "$VERSION" ] && echo -e "\tCalling: sed -i \"s/^${PACKAGE}/${VERSION}/\" \"${BASE_SOURCE}.${EXT_HASH}\"" >>"$LOG_DBUG"
#	[ "$VERSION" ] && sed -i "s/^${PACKAGE}/${VERSION}/" "${BASE_SOURCE}.${EXT_HASH}"		# changing the package name to match the version number in the hash file
	[ $DEBUG -gt 0 ] && [ ! "$DRYRUN" ] && [ "$VERFILE" ] && echo -e "\tCalling: sed -i \"s/  ${PACKAGE}/  ${PACKAGE}_${VERSION}/\" \"./${BASE_TARGET}.${EXT_HASH}\"" >>"$LOG_DBUG"
	[ ! "$DRYRUN" ] && [ "$VERFILE" ] && sed -i "s/  ${PACKAGE}/  ${PACKAGE}_${VERSION}/" "./${BASE_TARGET}.${EXT_HASH}"		# changing the package name to match the version number in the hash file

	if [ "$EXTRA" ]; then
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'code' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_CODE}\" -O \"./${BASE_TARGET}.${EXT_CODE}\"" >>"$LOG_DBUG"
# UPDATED 2025/11/07 - updated to output to the log correctly
#			wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_CODE}" >>"$LOG_ERRS" 2>&1	# download the corresponding source code file
#			( [ ! -e "${BASE_SOURCE}.${EXT_INFO}" ] || [ ! -s "${BASE_SOURCE}.${EXT_CODE}" ] ) && {
			[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_CODE}" -O "./${BASE_TARGET}.${EXT_CODE}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the corresponding source code file
				showMsg 'warning' "The package source code file download failed (${BASE_SOURCE}.${EXT_CODE})." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
			[ -e "./${BASE_SOURCE}.${EXT_CODE}" ] && showMsg 'file' " [code]" 'both' 0 0
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'cpio' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.cpio\" -O \"./${BASE_TARGET}.cpio\"" >>"$LOG_DBUG"
# UPDATED 2025/11/07 - updated to output to the log correctly
#			wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.cpio" >>"$LOG_ERRS" 2>&1	# download the corresponding info file
#			( [ ! -e "${BASE_SOURCE}.cpio" ] || [ ! -s "${BASE_SOURCE}.cpio" ] ) && {
			[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.cpio" -O "./${BASE_TARGET}.cpio" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {		# download the corresponding cpio file
				showMsg 'warning' "The package cpio file download failed (${BASE_SOURCE}.cpio)." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
			[ -e "./${BASE_SOURCE}.cpio" ] && showMsg 'file' " [cpio]" 'both' 0 0
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'info' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_INFO}\" -O \"./${BASE_TARGET}.${EXT_INFO}\"" >>"$LOG_DBUG"
# UPDATED 2025/11/07 - updated to output to the log correctly
#			wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_INFO}" >>"$LOG_ERRS" 2>&1	# download the corresponding info file
#			( [ ! -e "${BASE_SOURCE}.${EXT_INFO}" ] || [ ! -s "${BASE_SOURCE}.${EXT_INFO}" ] ) && {
			[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_INFO}" -O "./${BASE_TARGET}.${EXT_INFO}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the corresponding info file
				showMsg 'warning' "The package info file download failed (${BASE_SOURCE}.${EXT_INFO})." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
			[ -e "./${BASE_SOURCE}.${EXT_INFO}" ] && showMsg 'file' " [info]" 'both' 0 0
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'list' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_LIST}\" -O \"./${BASE_TARGET}.${EXT_LIST}\"" >>"$LOG_DBUG"
# UPDATED 2025/11/07 - updated to output to the log correctly
#			wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_LIST}" >>"$LOG_ERRS" 2>&1	# download the corresponding list file
#			( [ ! -e "${BASE_SOURCE}.${EXT_LIST}" ] || [ ! -s "${BASE_SOURCE}.${EXT_LIST}" ] ) && {
			[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_LIST}" -O "./${BASE_TARGET}.${EXT_LIST}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the corresponding manifest file
				showMsg 'warning' "The package manifest file download failed (${BASE_SOURCE}.${EXT_LIST})." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
			[ -e "./${BASE_SOURCE}.${EXT_LIST}" ] && showMsg 'file' " [list]" 'both' 0 0
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'make' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_MAKE}\" -O \"./${BASE_TARGET}.${EXT_MAKE}\"" >>"$LOG_DBUG"
			[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_MAKE}" -O "./${BASE_TARGET}.${EXT_MAKE}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the corresponding manifest file
				showMsg 'warning' "The package make file download failed (${BASE_SOURCE}.${EXT_MAKE})." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
			[ -e "./${BASE_SOURCE}.${EXT_MAKE}" ] && showMsg 'file' " [make]" 'both' 0 0
		fi
	fi

	return 0




# REMOVED 2025/11/06 - the DIR value was added to REPO_REMOTE and the app,icn,skn,thm packages will need to be handled through web.de itself
	local DIR="${APPNAME/_${KERNEL}}"							# set the default value while removing any KERNEL value from the (directory) name
	[ "$APPTYPE" = 'app' ] && DIR="web.de/_apps/${APPNAME}"					# if we're dealing with a web.de applet, set DIR to the package name for proper repo URI navigation
	[ "$APPTYPE" = 'icn' ] && DIR="web.de/_icons/${APPNAME}"				# or an icon set
	[ "$APPTYPE" = 'skn' ] && DIR="web.de/_skins/${APPNAME}"				# or a skin
	[ "$APPTYPE" = 'thm' ] && DIR="web.de/_themes/${APPNAME}"				# or a theme

	[ $DEBUG -gt 0 ] && { echo -en "downloadPackage:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:\n\tDIR     :${DIR}:\n\tpwd     " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.soft\"" >>"$LOG_DBUG"
	wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.soft" >>"$LOG_ERRS" 2>&1			# download the .soft file from the repo
	( [ ! -e "${APPHEAD}.soft" ] || [ ! -s "${APPHEAD}.soft" ] ) && {			# if the file wasn't downloaded, or it's a zero byte file, then...	NOTE: this uses the 'pwd' as the download directory via 'wget'
		[ "$SILENT" ] || echo "ERROR: package download failed (${APPHEAD}.soft)." >>"$LOG_ERRS"
		return 1
	}
	# if we are NOT installing a specific version of the software, then...
	[ $DEBUG -gt 0 ] && [ ! "$VERSION" ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.hash\"" >>"$LOG_DBUG"
	[ ! "$VERSION" ] && wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.hash" >>"$LOG_ERRS" 2>&1		# download the corresponding hash file
	# otherwise we are, so...
	[ $DEBUG -gt 0 ] && [ "$VERSION" ] && echo -e "\tCalling: wget -cq -O - \"${REPO_REMOTE}/${DIR}/${APPHEAD}.hash\" | sed \"s/${VERSION}/${APPNAME}/\" >\"${APPHEAD}.hash\"" >>"$LOG_DBUG"
	[ "$VERSION" ] && wget -cq -O - "${REPO_REMOTE}/${DIR}/${APPHEAD}.hash" 2>>"$LOG_ERRS" | sed "s/${VERSION}/${APPNAME}/" >"${APPHEAD}.hash"		# download the corresponding hash file changing the name to match the version number
	( [ ! -e "${APPHEAD}.hash" ] || [ ! -s "${APPHEAD}.hash" ] ) && {			# if the file wasn't downloaded, or it's a zero byte file, then...
		[ "$SILENT" ] || echo "ERROR: package hash download failed (${APPHEAD}.hash)." >>"$LOG_ERRS"
		return 1
	}

	if [ "$EXTRA" ]; then
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'info' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.info\"" >>"$LOG_DBUG"
			wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.info" >>"$LOG_ERRS" 2>&1	# download the corresponding info file
			( [ ! -e "${APPHEAD}.info" ] || [ ! -s "${APPHEAD}.info" ] ) && {	# if the file wasn't downloaded, or it's a zero byte file, then...
				( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "WARNING: package info does not exist or download failed (${APPHEAD}.info)." >>"$LOG_ERRS"
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'list' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.list\"" >>"$LOG_DBUG"
			wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.list" >>"$LOG_ERRS" 2>&1	# download the corresponding list file
			( [ ! -e "${APPHEAD}.list" ] || [ ! -s "${APPHEAD}.list" ] ) && {	# if the file wasn't downloaded, or it's a zero byte file, then...
				( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "WARNING: package list does not exist or download failed (${APPHEAD}.list)." >>"$LOG_ERRS"
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
		fi
	fi

	return 0
}


# Usage syntax: installPackage
# Overview:	performs the actual work of installing the contents of the package to the system via copy or symlink
# Notes:	pwd is irrelevent to this function										< UPDATED - this is no longer true as of 2018/11/27
# 		the directory containing the package(s) should already be entered BEFORE calling this function!
#		this can also performs package validation
#		all the necessary packages should already be obtained and in REPO_SOURCE (via COPY or DOWNLOAD)
installPackage() {
#	local SUCCESS=0										# indicates if the copy-to-RAM was successful (if that is desired)
#	local MARKER=''										# used to convert the install marker (/usr/local/tce.installed) to the XiniX naming convention
#	local SCRIPT=''										# used to convert the service script (/usr/local/etc/init.d) to the XiniX naming convention
	local SOURCE=''
	local TARGET=''
#	local OUTPUT=0
#	local PERM=0
#	local MODE=''
	local TARGET_ROOT
	local TARGET_LIVE
	local TARGET_HOME

# UPDATED 2025/11/06 - replace APP* variables
#	[ $DEBUG -gt 0 ] && { echo -en "installPackage:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:\n\tpwd     " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }
# UPDATED 2025/11/07
#	[ $DEBUG -gt 0 ] && { echo -en "installPackage:\n\tRAWFILE     |${RAWFILE}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${CPU}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tOPTFILE     |${OPTFILE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }
	[ $DEBUG -gt 0 ] && { echo -en "installPackage:\n\tRAWFILE     |${RAWFILE}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${ARCH}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\tOPTFILE     |${OPTFILE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	[ "$DRYRUN" ] && showMsg 'package' " [dryrun]" 'both' 0 0
	showMsg 'package' " [validate]" 'both' 0 0
# UPDATED 2025/11/07
#	md5sum -c "${APPHEAD}.hash" >/dev/null 2>>"$LOG_ERRS" || {				# validate the package checksum before we install anything!!!
#		[ "$SILENT" ] || echo "ERROR: package failed hash checksum (${APPFILE})!" >>"$LOG_ERRS"
#		rm -f "${APPHEAD}".* >>"$LOG_ERRS" 2>&1						# remove the files if they fail (since something is wrong with the package)
#		return 1
#	}
# UPDATED 2025/11/12
#	md5sum -c "${BASENAME}.${EXT_HAS}" >/dev/null 2>>"$LOG_ERRS" || {				# validate the package checksum before we install anything!!!
	( md5sum -c "${BASENAME}.${EXT_HASH}" >/dev/null 2>&1 | sed "s/^${FILENAME}: OK//;s/^m/ \[failure\]\nm/" | tee -a "$LOG_ERRS" | grep -q ^'md5sum: ' ) && {
		showMsg 'failure' "The package file failed hash checksum (${BASENAME}.${EXT_HASH})." 'log'
# REMOVED 2025/11/18 - this was removed so the user could take care of this.  nothing will be installed as long as the hash doesn't match the package
#		[ ! "$DRYRUN" ] && rm -f "${BASENAME}".* >>"$LOG_ERRS" 2>&1						# remove the package files if they fail (since something is wrong with the package)
		return 1
	}

# UNTESTED
# UPDATED 2025/10/08
#	if [ -e "${DIR_LIST}/${APPFILE}" ] && [ "$RESTORE" ]; then				# if we are updating the installed package with a restore point, then...
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [restore] [creating]"
#		uninstallPackage || return 1
#	if
# UPDATED 2025/12/08
#	if [ -e "${DIR_LIST}/${FILENAME}" ]; then						# if we are updating the installed package, then...
	if [ ! "$VALIDATE" ] && [ -e "${DIR_LIST}/${FILENAME}" ]; then						# if we are updating the installed package, then...
		showMsg 'step' " [unloading]" 'both' 0 0
		unloadPackage || return 1							#   unload the package first no matter what
# UPDATED 2025/11/24 - this is now an opt-out
#		[ "$RESTORE" ] && {								#   if we're creating a restore point, then...
# REMOVED 2025/12/01 - there is currently no way to prevent this
#		[ ! "$NORESTORE" ] && {								#   if we're creating a restore point, then...

# MOVED 2025/11/13 - moved this into uninstallPackage
#			showMsg 'step' " [archiving]" 'both' 0 0
			uninstallPackage || return 1						#      we need to uninstall of the package too
#		}
	fi

# UPDATED 2025/11/07
#	# since we have to do this step no matter what, lets setup and mount the package now
#	[ ! -d "${DIR_LOOP}/${APPNAME}.${APPTYPE}" ] && /bin/mkdir -p "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1	# make the mounting directory if it doesn't exist
#	if ( ! /bin/mount 2>>"$LOG_ERRS" | grep -q "/${APPNAME}.${APPTYPE} type squashfs" ); then					# if the package is NOT already mounted and symlinked, then...
#		sudo /bin/mount -t squashfs -o loop,ro,bs=4096 "$APPFILE" "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 || return 1
#	fi
#	find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -type d -name modules 2>>"$LOG_ERRS" | grep -q . && MODULES=TRUE			# if the package has a [/lib/]'modules' directory, then we need to indicate we need to load those modules later
#	find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -type d -name lib 2>>"$LOG_ERRS" | grep -q . && LIBRARIES=TRUE			# if the package has a [/../]'lib' directory, then we need to indicate we need to load them later
	[ ! -d "${DIR_LOOP}/${BASENAME}" ] && /bin/mkdir -p "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1	# make the mounting directory if it doesn't exist
	if ( ! /bin/mount 2>>"$LOG_ERRS" | grep -q "${DIR_LOOP}/${BASENAME} type squashfs" ); then					# if the package is NOT already mounted and symlinked, then...
		sudo /bin/mount -t squashfs -o loop,ro,bs=4096 "${REPO_SOURCE}/${FILENAME}" "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || return 1
	fi
	# check if the package has any libs we need to load later						  NOTE: we check this way because simply checking for the directory can produce false positives
	( ls -1p "${DIR_LOOP}/${BASENAME}/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE				# NOTE: the "grep -qv '/'$" removes directories from the listing so only files remain (otherwise /lib/modules/ would provide a false positive)
	( ls -1p "${DIR_LOOP}/${BASENAME}/lib64" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	( ls -1p "${DIR_LOOP}/${BASENAME}/usr/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	( ls -1p "${DIR_LOOP}/${BASENAME}/usr/local/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	# check if the package has a [/usr[/local]]'/lib/modules' directory to indicate we need to load modules later
	[ -d "${DIR_LOOP}/${BASENAME}/lib/modules" ] || [ -d "${DIR_LOOP}/${BASENAME}/usr/lib/modules" ] || [ -d "${DIR_LOOP}/${BASENAME}/usr/local/lib/modules" ] && MODULES=TRUE	# NOTE: we CAN simply check for directories here since files would be packaged under them
# UPDATED 2018/07/14 - since TC packages do NOT adhere to this, we need a more robust solution
#	[ "$APPTYPE" = 'lib' ] && LIBRARIES=TRUE										# if the package has dynamic libraries, then indicate we need to add those to the cache file later

# TEMP CHANGE - this is for TC Compatibility - use config files to differenciate between distros
#MARKER="$(ls -1 "${DIR_LOOP}/${APPNAME}.${APPTYPE}/usr/local/tce.installed" 2>/dev/null)"
#SCRIPT="$(ls -1 "${DIR_LOOP}/${APPNAME}.${APPTYPE}/usr/local/etc/init.d" 2>/dev/null)"
# UPDATED 2025/11/07
#	MARKER="$(ls -1 "${DIR_LOOP}/${APPNAME}.${APPTYPE}${DIR_INST}" 2>/dev/null)"						# NOTE: since XiniX uses different package names than TC, this renames the 'installed marker' to be appropriate; this can be removed once we start adjusting the contents of each package
#	SCRIPT="$(ls -1 "${DIR_LOOP}/${APPNAME}.${APPTYPE}${DIR_INIT}" 2>/dev/null)"						# same, but with the service script
# MOVED 2025/11/10 - below
#	MARKER="$(ls -1 "${DIR_LOOP}/${BASENAME}${DIR_INST}" 2>/dev/null)"							# check for installation scripts
#	SCRIPT="$(ls -1 "${DIR_LOOP}/${BASENAME}${DIR_INIT}" 2>/dev/null)"							# same, but with the service script

# MOVED 2025/11/12 - this is better placed outside of this function
#	# if '-M copy' was passed to this script -OR- the copy-everything-to-RAM file exists -OR- { the copy the system directory (REPO_SYSTEM) contents to RAM file exists -and- we're using that directory (e.g. booting) -and- REPO_SYSTEM and REPO_OPTION are NOT the same (to prevent TC from erroneously loading everything to RAM since those two would be the same) }, then...
#	if [ "$MODE" = 'copy' ] || [ -e "${REPO_PREFIX}/copy_all.flag" ] || ( [ -e "${REPO_PREFIX}/copy_sys.flag" ] && [ "$REPO_SOURCE" = "$REPO_SYSTEM" ] && [ "$REPO_SYSTEM" != "$REPO_OPTION" ] ); then
#echo top
#		[ $DEBUG -gt 0 ] && echo -e "\tInstall by copying..." >>"$LOG_DBUG"
#		showMsg 'step' " [copy]" 'both' 0 0
#		MODE='copy'
#	else
#echo btm
#		[ $DEBUG -gt 0 ] && echo -e '\tInstall using symlinks...' >>"$LOG_DBUG"
#		showMsg 'step' " [link]" 'both' 0 0
#		MODE='link'
#	fi
	showMsg 'step' " [${MODE}]" 'both' 0 0
	[ "$VALIDATE" ] && showMsg 'step' " [${VALIDATE}] ..." 'both' 1 0
#echo "DBUG Install"
#return 0

	TEMP=''											# set a default value
# UPDATED 2025/12/08 - added another -v value
#	( [ "$FORCE" ] || [ "$VALIDATE" ] ) && {						# if we've been instructed to force (overwrite) -OR- are validating (which always overwrites), then...
	( [ "$FORCE" ] || [ "$VALIDATE" = 'fix' ] ) && {						# if we've been instructed to force (overwrite) -OR- are validating (which always overwrites), then...
		showMsg 'step' " [overwrite]" 'both' 0 0					#   indicate this to the user
		TEMP='f'									#   store the force flag for usage below
		unalias cp >/dev/null 2>&1							#   remove anything existing that would force prompting for overwritting (e.g. alias cp='cp -i')
		unalias ln >/dev/null 2>&1
	}

	# if we only need to copy specified files out of the package, then lets obtain that list
	# NOTES:
	#	- if the passed file does NOT exist, it will NOT be in the filelist.txt
	#	- the final sed adds the directory to the listing so the 'for' loop below works correctly (since it needs preceeding directories, then files)
	#	  EXPLAINED: stores the entire line (with the filename) in the hold buffer; removes the filename from the line (leaving just the directory); prints the line; prints the hold buffer
	#	  SEE: https://stackoverflow.com/questions/12833714/the-concept-of-hold-space-and-pattern-space-in-sed
# UPDATED 2025/11/07
#	if [ "$FILELIST" ]; then
#		find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" ! -type d -name $(echo "$FILELIST" | sed 's/,/ -o -name /g') >"${DIR_TEMP}/filelist.txt" 2>>"$LOG_ERRS"
#	fi
	[ "$FILELIST" ] && find "${DIR_LOOP}/${BASENAME}" ! -type d -name $(echo "$FILELIST" | sed 's/,/ -o -name /g') | sed 'h;s|[^/]*$||;p;x' >"${DIR_TEMP}/filelist.${EXEID}" 2>>"$LOG_ERRS"

	# if a filelist.EXEID file does NOT exist, then we need to process all files in the package, otherwise -N was passed so only certain ones need to be
	# NOTES:
	#	- the sub-shell was constructed using to different conditions so the failure of a prior execution did not erroneously trigger an '||' execution
	#	- the '| tail -n +2' skips the first line of output, which is the current directory and should NOT be processed
	#	- we use EXEID here so simultaneous pax executions can operate without issues
	# WARNING: multiple problems occurred trying to use 'cp' (with these params: -aisL, -LRis, -HRis) but the task failed for one reason or another; the below was used instead
#echo before
	for SOURCE in $([ ! -e "${DIR_TEMP}/filelist.${EXEID}" ] && find "${DIR_LOOP}/${BASENAME}" | tail -n +2; [ -e "${DIR_TEMP}/filelist.${EXEID}" ] && cat "${DIR_TEMP}/filelist.${EXEID}"); do
#echo "iterating |$SOURCE|"
		TARGET_ROOT="$(echo "$SOURCE" | sed "s|^${DIR_LOOP}/${BASENAME}||")"
		TARGET_LIVE="${DIR_LIVE}${TARGET_ROOT}"
		TARGET_HOME="${HOME}${TARGET_ROOT}"
		TARGET="${DIRECTORY}${TARGET_ROOT}"			# (re)set the value; remove the loopback mount point prefix to store only the target '/directory/filename' string
#echo "target |$TARGET|"
		if [ ! -d "$SOURCE" ]; then							# for each file...
#echo "[F] |$SOURCE|"
			( [ ! "$FORCE" ] && [ ! "$VALIDATE" ] ) && [ -e "${DIRECTORY}${TARGET}" ] && continue	#   if we're NOT forcing -AND- we're NOT validating -AND- the file does exist then go to the next file

			# NOE: the PREFIX will already be part of DIRECTORY (assigned at the beginning of the script processing)
# UPDATED 2025/12/08
#			if [ "$MODE" = 'copy' ]; then
			if ( [ "$INSTALL" ] || [ "$VALIDATE" = 'fix' ] ) && [ "$MODE" = 'copy' ]; then
				# NOTE: if the package installation is done with root, the USER:GROUP ownership is preserved (e.g. when installing to /), otherwise it will default to the user and their default group (e.g. when installing to /Users/Public or $HOME)
# UPDATED 2025/12/09 - this is now done once above
#				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -dp${TEMP} \"${SOURCE}\" \"${DIRECTORY}${TARGET}\"" >>"$LOG_DBUG"
#				[ ! "$DRYRUN" ] && ( cp -dp${TEMP} "${SOURCE}" "${DIRECTORY}${TARGET}" 2>&1 | sed "s/^cp: can't preserve ownership.*//;/^$/d;s/^c/ \[failure\]\nc/" | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {		# copy the file from the source directory
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -dp${TEMP} \"${SOURCE}\" \"${TARGET}\"" >>"$LOG_DBUG"
				[ ! "$DRYRUN" ] && ( cp -dp${TEMP} "${SOURCE}" "${TARGET}" 2>&1 | sed "s/^cp: can't preserve ownership.*//;/^$/d;s/^c/ \[failure\]\nc/" | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {		# copy the file from the source directory
					showMsg 'failure' "The package file copy failed (${SOURCE})." 'log'
					return 1
				}
# UPDATED 2025/12/08
#			else
			elif ( [ "$INSTALL" ] || [ "$VALIDATE" = 'fix' ] ) && [ "$MODE" = 'link' ]; then
# UPDATED 2025/12/09 - this is now done once above
#				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    ln -s${TEMP} \"${SOURCE}\" \"${DIRECTORY}${TARGET}\"" >>"$LOG_DBUG"
#				[ ! "$DRYRUN" ] && ( ln -s${TEMP} "${SOURCE}" "${DIRECTORY}${TARGET}" 2>&1 | sed 's/^l/ \[failure\]\nl/' | tee -a "$LOG_ERRS" | grep -q ^'ln: ' ) && {	# symlink the file from the source directory
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    ln -s${TEMP} \"${SOURCE}\" \"${TARGET}\"" >>"$LOG_DBUG"
				[ ! "$DRYRUN" ] && ( ln -s${TEMP} "${SOURCE}" "${TARGET}" 2>&1 | sed 's/^l/ \[failure\]\nl/' | tee -a "$LOG_ERRS" | grep -q ^'ln: ' ) && {	# symlink the file from the source directory
					showMsg 'failure' "The package file symlink failed (${SOURCE})." 'log'
					return 1
				}
#echo done >>$LOG_DBUG
			elif [ ! "$INSTALL" ] && ( [ "$VALIDATE" = 'data' ] || [ "$VALIDATE" = 'hash' ] ); then
				showMsg 'file' "  $TARGET:" 'both' 0 3 1

				if [ ! -e "$TARGET" ] && [ ! -e "$TARGET_ROOT" ] && [ ! -e "$TARGET_LIVE" ] && [ ! -e "$TARGET_HOME" ]; then					# if the file doesn't exist, then...
					showMsg 'issue' " !missing!" 'both' 0 0
				else								# otherwise it does, so perform other checks...
					# determine where the file is located (in case the package was installed one place [e.g. HOME] and a dependency in another [e.g. ROOT])
					if [ -e "$TARGET" ]; then				# if it's in the passed DIRECTORY, then...
						showMsg 'step' " [misc]" 'both' 0 0
					elif [ -e "$TARGET_ROOT" ]; then			# if it's in the root of the OS, then...
						TARGET="$TARGET_ROOT"
						showMsg 'step' " [root]" 'both' 0 0
					elif [ -e "$TARGET_LIVE" ]; then			# if it's in DIR_LIVE, then...
						TARGET="$TARGET_LIVE"
						showMsg 'step' " [live]" 'both' 0 0
					elif [ -e "$TARGET_HOME" ]; then			# if it's in HOME, then...
						TARGET="$TARGET_HOME"
						showMsg 'step' " [home]" 'both' 0 0
					fi

					if [ "$MODE" = 'copy' ]; then
						if [ ! -L "$SOURCE" ] && [ -L "$TARGET" ]; then
							showMsg 'issue' " !symlink!" 'both' 0 0
							showMsg 'file' ' [done]' 'both' 1 5
							continue
						else
							# check for possible malicious (malware?) replacements with mismatched file sizes or hashing
							[ "$VALIDATE" = 'data' ] && ( [ "$(stat -c %s "$SOURCE" 2>/dev/null)" = "$(stat -c %s "$TARGET" 2>/dev/null)" ] && showMsg 'step' " [size]" 'both' 0 0 || showMsg 'issue' " !size!" 'both' 0 0 )
							[ "$VALIDATE" = 'hash' ] && ( [ "$(md5sum "$SOURCE" | sed 's/  .*//')" = "$(md5sum "$TARGET" | sed 's/  .*//')" ] && showMsg 'step' " [hash]" 'both' 0 0 || showMsg 'issue' " !hash!" 'both' 0 0 )
							# check the file permissions match those in the package
							[ "$(stat -c %a "$SOURCE" 2>/dev/null)" = "$(stat -c %a "$TARGET" 2>/dev/null)" ] && showMsg 'issue' " [perm]" 'both' 0 0 || showMsg 'issue' " !perm!" 'both' 0 0
						fi
					elif [ "$MODE" = 'link' ]; then
#echo "|${DIRECTORY}${TARGET}|$(readlink "${DIRECTORY}${TARGET}")|$SOURCE|"
						[ "$(readlink "${TARGET}")" = "$SOURCE" ] && showMsg 'issue' " [link]" 'both' 0 0 || showMsg 'issue' " !link!" 'both' 0 0				# if the symlink isn't pointing to the source file, then...
						[ "$(stat -c %a "$TARGET" 2>/dev/null)" = '777' ] && showMsg 'issue' " [perm]" 'both' 0 0 || showMsg 'issue' " !perm!" 'both' 0 0		# if the symlink permissions aren't correct, then...
					fi

#					if [ "$MODE" != 'copy' ] && [ ! -L "$TARGET" ]; then
						if [ "$DIRECTORY" = '/' ]; then					# if the package was installed in the root of the filesystem, then make sure the ownership is root
							[ "$(stat -c %G "$TARGET" 2>/dev/null)" = 'root' ] && showMsg 'issue' " [owner]" 'both' 0 0 || showMsg 'issue' " !owner!" 'both' 0 0
# UPDATED 2025/12/08
#						# if the package was installed anywhere else (/Users/Public or HOME), then it should match whats in the squashfs package (which should be 'software' so anyone with that group should be able to manipulate the package)
#						elif [ "$DIRECTORY" != '/' ] && [ "$(stat -c %G "$SOURCE" 2>/dev/null)" != "$(stat -c %G "$TARGET" 2>/dev/null)" ]; then
						# if the package was installed anywhere else (/Users/Public or HOME), then it should match the default group of the user account that installed the software (e.g. 'everyone')
						elif [ "$DIRECTORY" != '/' ]; then
							 [ "$(stat -c %G "$TARGET" 2>/dev/null)" = "$OWN_GROUP" ] && showMsg 'issue' " [owner]" 'both' 0 0 || showMsg 'issue' " !owner!" 'both' 0 0
						fi
#					fi
				fi

				showMsg 'file' ' [done]' 'both' 1 5
			fi
			continue
		fi

		# if we're validating, we can skip checks on directories
		[ "$VALIDATE" ] && continue

#echo "[D] |${DIRECTORY}${TARGET}|"
		# if we've made it here, then we're dealing with a directory, so...
# UPDATED 2025/12/09 - this is now done once above
#		( [ ! "$FORCE" ] && [ ! "$VALIDATE" ] ) && [ -e "${DIRECTORY}${TARGET}" ] && continue	#   if we're NOT forcing -AND- we're NOT validating -AND- the directory does exist then cycle the 'for' loop
#
#		if [ ! -e "${DIRECTORY}${TARGET}" ]; then						# create the directory
##echo creating
#			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    mkdir -p \"${DIRECTORY}${TARGET}\"" >>"$LOG_DBUG"
#			[ ! "$DRYRUN" ] && ( mkdir -p "${DIRECTORY}${TARGET}" 2>&1 | sed 's/^m/ \[failure\]\nm/' | tee -a "$LOG_ERRS" | grep -q ^'mkdir: ' ) && {
#				showMsg 'failure' "The package directory creation failed (${DIRECTORY}${TARGET})." 'log'
		( [ ! "$FORCE" ] && [ ! "$VALIDATE" ] ) && [ -e "${TARGET}" ] && continue	#   if we're NOT forcing -AND- we're NOT validating -AND- the directory does exist then cycle the 'for' loop

		if [ ! -e "${TARGET}" ]; then						# create the directory
#echo creating
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    mkdir -p \"${TARGET}\"" >>"$LOG_DBUG"
			[ ! "$DRYRUN" ] && ( mkdir -p "${TARGET}" 2>&1 | sed 's/^m/ \[failure\]\nm/' | tee -a "$LOG_ERRS" | grep -q ^'mkdir: ' ) && {
				showMsg 'failure' "The package directory creation failed (${TARGET})." 'log'
				 return 1;
			}
		fi
	done
#echo "afterwards |$MODE|"

	# remove any -N filelist files
	[ -e "${DIR_TEMP}/filelist.${EXEID}" ] && rm -f "${DIR_TEMP}/filelist.${EXEID}" 2>>"$LOG_ERRS"

	# unmount if we copied -OR- are doing a dryrun
	( [ "$MODE" = 'copy' ] || [ "$DRYRUN" ] ) && ( sudo /bin/umount -d "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || return 1 )

# REMOVED 2025/11/10 - this doesn't look like it's necessary, but left until confirmed
#	MARKER="$(ls -1 "${DIR_LOOP}/${BASENAME}${DIR_INST}" 2>/dev/null)"							# check for installation scripts
#	[ "$MARKER" ] && {											# if a marker is included in the package, then...
#		rm "${DIR_INST}/${MARKER}" >>"$LOG_ERRS" 2>&1								#   remove the symlink created above
#		ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}/${DIR_INST}/${MARKER}" "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1	#   re-symlink using the XiniX naming convention
#	}
#
#	SCRIPT="$(ls -1 "${DIR_LOOP}/${BASENAME}${DIR_INIT}" 2>/dev/null)"							# same, but with the service script
#	[ "$SCRIPT" ] && {											# same with the service script
#		rm "${DIR_INIT}/${SCRIPT}" >>"$LOG_ERRS" 2>&1
#		ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}${DIR_INIT}/${SCRIPT}" "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>&1
#	}

# MOVED 2025/11/12 - this was moved into the main loop below so EVERY file it depends on is added
#	# add the package to the list of dependencies							  NOTE: this lists EVERY dependency for every dependency in one list; not just the dependencies for the requested package!
#	echo "$FILENAME" >>"${DIR_TEMP}/installed.${EXEID}"						# add the package to the cache file for future unloading/uninstalling information

	# update the "install" list
# UPDATED 2025/12/01
#	# if we are NOT validating -AND- installing a requested package [INDEX==1] (not a dependency for it [INDEX>1]) -AND- it needs to be added to the optional.list -AND- the package isn't already in the LIST, then add the package to the LIST file
#	[ ! "$VALIDATE" ] && [ "$INDEX" -eq 1 ] && [ ! "$NOLIST" ] && ( ! grep -q $RAWFILE "${REPO_PREFIX}/${LIST_BOOT}" 2>>"$LOG_ERRS" ) && echo "$FILENAME" >>"${REPO_PREFIX}/${LIST_BOOT}" 2>>"$LOG_ERRS"
	# if we are NOT validating -AND- installing a requested package [INDEX==1] (not a dependency for it [INDEX>1]) -AND- it needs to be added to a list -AND- the package isn't already in the LIST, then add the package to the LIST file
	[ ! "$VALIDATE" ] && [ "$INDEX" -eq 1 ] && [ "$PACKLIST" = 'boot' ] && ( ! grep -q $RAWFILE "${REPO_PREFIX}/${LIST_BOOT}" 2>>"$LOG_ERRS" ) && echo "$FILENAME" >>"${REPO_PREFIX}/${LIST_BOOT}" 2>>"$LOG_ERRS"
	[ ! "$VALIDATE" ] && [ "$INDEX" -eq 1 ] && [ "$PACKLIST" = 'live' ] && ( ! grep -q $RAWFILE "${REPO_PREFIX}/${LIST_LIVE}" 2>>"$LOG_ERRS" ) && echo "$FILENAME" >>"${REPO_PREFIX}/${LIST_LIVE}" 2>>"$LOG_ERRS"

	# defer the execution of any related marker/service scripts from the package(s) until everything is installed - if we are not validating package data!
	[ ! "$VALIDATE" ] && [ -x "${DIR_INST}/${BASENAME}" ] && ( ! grep -q "${DIR_INST}/${BASENAME}" ${DIR_TEMP}/installs.${EXEID} 2>/dev/null ) && echo "${BASENAME}" >>${DIR_TEMP}/installs.${EXEID} 2>>"$LOG_ERRS"
	[ ! "$VALIDATE" ] && [ -e "${DIR_INIT}/${BASENAME}" ] && ( ! grep -q "${DIR_INIT}/${BASENAME}" ${DIR_TEMP}/services.${EXEID} 2>/dev/null ) && echo "${BASENAME}" >>${DIR_TEMP}/services.${EXEID} 2>>"$LOG_ERRS"

	# now add to the 'catalog' of installed packages
	[ ! "$VALIDATE" ] && [ ! "$DRYRUN" ] && ln -sf "${REPO_SOURCE}/${FILENAME}" "${DIR_LIST}/${FILENAME}" 2>>"$LOG_ERRS"
	[ ! "$VALIDATE" ] && [ ! "$DRYRUN" ] && [ -e "${BASENAME}.${EXT_HASH}" ] && ln -sf "${REPO_SOURCE}/${BASENAME}.${EXT_HASH}" "${DIR_LIST}/${BASENAME}.${EXT_HASH}" 2>>"$LOG_ERRS"
	[ ! "$VALIDATE" ] && [ ! "$DRYRUN" ] && [ -e "${BASENAME}.${EXT_DEPS}" ] && ln -sf "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" "${DIR_LIST}/${BASENAME}.${EXT_DEPS}" 2>>"$LOG_ERRS"

	return 0




	# if '-M copy' was passed to this script -OR- the copy-everything-to-RAM file exists -OR- the copy all system directories (REPO_OPTION and REPO_SYSTEM) contents to RAM file exists -and- we're using one of those directories, then...
	if [ "$MODE" = 'copy' ] || [ -e "${REPO_PREFIX}/copy_all.flag" ] || ( [ -e "${REPO_PREFIX}/copy_sys.flag" ] && [ ! "$REPO_TARGET" ] ); then
		[ $DEBUG -gt 0 ] && echo -e "\tInstall by copying..." >>"$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [copy]"
		[ "$VALIDATE" ] && { ( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [overwrite]"; }

		# NOTE: the below 'if' prevents the GNU tar from being a dependency during the boot process (but later for the 2nd stage loading)
		if [ ! "$BOOTING" ]; then							# if we are NOT booting, then GNU tar should be available so use it!
			( [ "$FORCE" ] || [ "$VALIDATE" ] ) && TEMP='-U --overwrite' || TEMP=''

			# NOTE: we use tar instead of cp to implement ownership in the copy process; the '-h' was removed on the extraction because it interferred with overwriting (even though -U was being issued too)
			if [ ! "$FILELIST" ]; then						# if we're copying all files out of the package, then...
				tar -C "${DIR_LOOP}/${APPNAME}.${APPTYPE}" --group=$GROUP . -cf - 2>>"$LOG_ERRS" | tar -C "${PREFIX}/" $TEMP -pxf - 2>>"$LOG_ERRS"
			else									# otherwise we only need to copy certain ones, so...
				tar -C "${DIR_LOOP}/${APPNAME}.${APPTYPE}" --group=$GROUP -T "${DIR_TEMP}/filelist.txt" -cf - 2>>"$LOG_ERRS" | tar -C "${PREFIX}/" $TEMP -pxf - 2>>"$LOG_ERRS"
			fi
		else										# otherwise we are booting and only have access to BB tar and can't execute the above lines, so use copy with the 'core' packages
			cp -dpR "${DIR_LOOP}/${APPNAME}.${APPTYPE}" "${PREFIX}/" 2>>"$LOG_ERRS"
		fi
		if [ $? -ne 0 ]; then
			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "WARNING: The (copy) install failed for ${APPFILE}!" >>"$LOG_ERRS"		# now we will fall back to the symlinking below this segment
			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [error] [attempting]"
		else
# REMOVED 2019/11/9 - we now have the compatibility package created
# LEFT OFF - TEMP CHANGE - this is for TC Compatibility and can remove this 'if' block once we create the tc_compatability package		maybe institute a -c(ompatibility) switch to 'pax' temporarily so it can work with TC packages
#if [ -d '/usr/local/tce.installed' ]; then						# LEFT OFF - do the same for SCRIPTS
#	mv /usr/local/tce.installed/* "$DIR_INST" 2>>"$LOG_ERRS"
#	rm -Rf /usr/local/tce.installed 2>>"$LOG_ERRS"
#	ln -s "$DIR_INST" /usr/local/tce.installed 2>>"$LOG_ERRS"
#fi
#if [ -d '/usr/local/etc/init.d' ]; then
#	mv /usr/local/etc/init.d/* "$DIR_INIT" 2>>"$LOG_ERRS"
#	rm -Rf /usr/local/etc/init.d 2>>"$LOG_ERRS"
#	ln -s "$DIR_INIT" /usr/local/etc/init.d 2>>"$LOG_ERRS"
#fi
			[ "$MARKER" = '' ] && MARKER="$APPNAME"								# if no default marker was included in the package, then default to its name
			[ $DEBUG -gt 0 ] && echo -e "\tMARKER :${MARKER}:\n\tSCRIPT :${SCRIPT}:" >>"$LOG_DBUG"

			# now update the naming conventions of the marker/script
			mv "${DIR_INST}/${MARKER}" "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>/dev/null
			[ "$SCRIPT" != '' ] && mv "${DIR_INIT}/${SCRIPT}" "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>/dev/null
			sudo /bin/umount -d "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 && rmdir "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1				# now that we have successfully copied the package contents to RAM, lets unmount and remove the mount point
			SUCCESS=1												# this indicates we do NOT need to symlink below (but we do need to do the other things down there...)
		fi
	fi

	# if we don't have SUCCESS at this point, then we need to symlink the package contents into the OS (either on purpose or as a fail-safe to the segment above)
	# WARNING: this MUST be two separate 'if' statements so if the one above fails, this one can still be entered!
	if [ $SUCCESS -eq 0 ]; then
		[ $DEBUG -gt 0 ] && echo -e '\tInstall using symlinks...' >>"$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [link]"

		( [ "$FORCE" ] || [ "$VALIDATE" ] ) && TEMP='f' || TEMP=''

		# WARNING: multiple problems occurred trying to use 'cp' (with these params: -aisL, -LRis, -HRis) but the task failed for one reason or another; the below was used instead
# UPDATED 2025/10/23 - this can now symlink specific files specified via -N
#		for SOURCE in $(find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -name '*'); do
		# if a filelist.txt file does NOT exist, then we need to symlink all files in the package, otherwise -N was passed so only certain ones need to be symlinked
		# NOTE: the sub-shell was constructed using to different conditions so the failure of a prior execution did not erroneously trigger an '||' execution
		for SOURCE in $([ ! -e "${DIR_TEMP}/filelist.txt" ] && find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -name '*'; [ -e "${DIR_TEMP}/filelist.txt" ] && cat "${DIR_TEMP}/filelist.txt"); do
			TARGET="$(echo $SOURCE | sed "s:^${DIR_LOOP}/${APPNAME}.${APPTYPE}::")"		# (re)set the value
			[ ! "$TARGET" ] && continue
			if [ ! -d "$SOURCE" ]; then							# for each file...
				if [ ! "$VALIDATE" ]; then						#   if this is a typical package install, then...
					[ -e "$TARGET" ] && [ ! "$FORCE" ] && continue			#     if the file doesn't exist -AND- we aren't forcing the install, then go to the next file
				else									#   otherwise, we are validating so...
					[ -e "$TARGET" ] && [ "$(readlink $TARGET)" = "$SOURCE" ] && [ "$(stat -c %G $TARGET 2>/dev/null)" = "$GROUP" ] && [ "$(stat -c %a $TARGET 2>/dev/null)" = '777' ] && continue	# if it exists and points to the correct source file -AND- the ownership and permissions are correct, then go to the next one	WARNING: do NOT implement PREFIX here!!!
					( [ "$SILENT" ] || [ "$QUIET" ] ) || {				#   if we made it here then there was a problem, so...
						[ $OUTPUT -eq 0 ] && { echo " [detected]"; OUTPUT=1; }
						echo -e "   Misconfigured: $TARGET"
					}
				fi
				ln -s$TEMP "$SOURCE" "${PREFIX}${TARGET}" >>"$LOG_ERRS" 2>&1 || return 1	#   if the file does NOT exist, then symlink
				continue								#   skip further processing
			fi

			# if we've made it here, then we're dealing with a directory, so...
			if [ ! "$VALIDATE" ]; then
				[ -e "$TARGET" ] && continue						# if the directory already exists, skip further processing
			else
				[ -e "$TARGET" ] && [ "$(stat -c %G $TARGET 2>/dev/null)" = "$GROUP" ] && [ "$(stat -c %a $TARGET 2>/dev/null)" = "$(stat -c %a $SOURCE 2>/dev/null)" ] && continue
				( [ "$SILENT" ] || [ "$QUIET" ] ) || {
					[ $OUTPUT -eq 0 ] && { echo " [detected]"; OUTPUT=1; }
						echo -e "   Misconfigured: $TARGET"
				}
			fi
			PERM=$(stat -c %a "$SOURCE" 2>/dev/null || echo 755)				# get the permissions of the original directory from the squashfs file
			[ ! -e "${PREFIX}$TARGET" ] && { mkdir -p "${PREFIX}${TARGET}" >>"$LOG_ERRS" 2>&1 || return 1; }		# create the directory in the OS	NOTE: we had to add the '-e' check since VALIDATE can go here even if the directory exists (owner or perm can be wrong)
			chown -h :$GROUP "${PREFIX}${TARGET}" >>"$LOG_ERRS" 2>&1				# apply the appropriate group and permissions
			chmod $PERM "${PREFIX}${TARGET}" >>"$LOG_ERRS" 2>&1
		done

		[ "$MARKER" != '' ] && {											# if a marker is included in the package, then...
			rm "${DIR_INST}/${MARKER}" >>"$LOG_ERRS" 2>&1								#   remove the symlink created above
# TEMP CHANGE - this is for TC Compatibility - use config files to differenciate between distros
#ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}/usr/local/tce.installed/${MARKER}" "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1
			ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}/${DIR_INST}/${MARKER}" "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1	#   re-symlink using the XiniX naming convention
		}
		[ "$SCRIPT" != '' ] && {											# same with the service script
			rm "${DIR_INIT}/${SCRIPT}" >>"$LOG_ERRS" 2>&1
# TEMP CHANGE - this is for TC Compatibility - use config files to differenciate between distros
#ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}/usr/local/etc/init.d/${SCRIPT}" "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>&1
			ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}${DIR_INIT}/${SCRIPT}" "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>&1
		}
	fi

	# remove any -N filelist files
	[ -e "${DIR_TEMP}/filelist.txt" ] && rm -f "${DIR_TEMP}/filelist.txt" 2>>"$LOG_ERRS"

	# remove the 0-byte marker/scripts (since we now have the catalog directory)
	[ ! -s "${DIR_INIT}/${APPNAME}.${APPTYPE}" ] && rm "${DIR_INIT}/${APPNAME}.${APPTYPE}" 2>/dev/null
	[ ! -s "${DIR_INST}/${APPNAME}.${APPTYPE}" ] && rm "${DIR_INST}/${APPNAME}.${APPTYPE}" 2>/dev/null

	# now add to the 'catalog' of installed packages
	ln -sf "$(pwd)/${APPFILE}" "${DIR_LIST}/${APPFILE}" 2>>"$LOG_ERRS"
	ln -sf "$(pwd)/${APPHEAD}.hash" "${DIR_LIST}/${APPHEAD}.hash" 2>>"$LOG_ERRS"
	ln -sf "$(pwd)/${APPHEAD}.deps" "${DIR_LIST}/${APPHEAD}.deps" 2>>"$LOG_ERRS"

	# update the appropriate list contents
# UPDATED 2025/11/10
#	( ! grep -q "$APPFILE" "${DIR_TEMP}/"* 2>>"$LOG_ERRS" ) && echo "$APPFILE" >> "$EXEID"		# if the package isn't already part of an existing list, then add the package to the cache file for future uninstalling information
	( ! grep -q "$APPFILE" "${DIR_TEMP}/"* 2>>"$LOG_ERRS" ) && echo "$APPFILE" >> "${DIR_TEMP}/${EXEID}"		# if the package isn't already part of an existing list, then add the package to the cache file for future uninstalling information

# UPDATED 2025/10/23 - the -L option is now a negation
#	[ ! "$VALIDATE" ] && [ "$INDEX" -eq 1 ] && [ "$NOLIST" ] && ( ! grep -q $RAWFILE "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS" ) && echo "$RAWFILE" >> "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS"	# if we are updating the system from (one of the) requested packages and not one of its dependencies (via INDEX==1) -AND- we're installing -AND- we're not only loading (no adjustment to LIST) -AND- the package isn't already in the LIST, then add the package to the LIST file
	[ ! "$VALIDATE" ] && [ "$INDEX" -eq 1 ] && [ ! "$NOLIST" ] && ( ! grep -q $RAWFILE "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS" ) && echo "$RAWFILE" >> "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS"	# if we are updating the system from (one of the) requested packages and not one of its dependencies (via INDEX==1) -AND- we're installing -AND- we're not only loading (no adjustment to LIST) -AND- the package isn't already in the LIST, then add the package to the LIST file

	# defer the execution of any related marker/service scripts from the package(s) until everything is installed - if we are not validating package data!
	[ ! "$VALIDATE" ] && [ -x "${DIR_INST}/${APPNAME}.${APPTYPE}" ] && ( ! grep -q "${DIR_INST}/${APPNAME}.${APPTYPE}" ${DIR_TEMP}/installs.list 2>/dev/null ) && echo "${DIR_INST}/${APPNAME}.${APPTYPE}" >> ${DIR_TEMP}/installs.list 2>>"$LOG_ERRS"		# if the package has an 'initialize' script post-install, then...
	[ ! "$VALIDATE" ] && [ -e "${DIR_INIT}/${APPNAME}" ] && ( ! grep -q "${DIR_INIT}/${APPNAME}" ${DIR_TEMP}/services.list 2>/dev/null ) && echo "${DIR_INIT}/${APPNAME}" >> ${DIR_TEMP}/services.list 2>>"$LOG_ERRS"		# if the package has a services start/stop script, then...
	return 0
}


# Usage syntax: proxyAction
# Overview:	proxy's the action by creating a temporary shell script to execute on another device
# Notes:	https://unix.stackexchange.com/questions/22623/extract-middle-section-of-lines-of-a-text-file
#		https://unix.stackexchange.com/questions/2072/whats-the-best-way-to-take-a-segment-out-of-a-text-file
proxyAction() {
	( [ -e "${DIR_TEMP}/proxy.sh" ] || [ -e "${PROXY}/proxy.sh" ] ) && return 0		# if the script is already generated, we can skip re-creating it again

	echo '#!/bin/sh' > "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo '# Variable Declarations' >> "${DIR_TEMP}/proxy.sh"
	echo -e "COPY=${COPY}\nDOWNLOAD=${DOWNLOAD}${INSTALL}\nDEBUG=0\nEXTRA=${EXTRA}\nINDEX=0\nTOTAL=0\n" >> "${DIR_TEMP}/proxy.sh"
	echo -e "LOG_ERRS=\"\$(pwd)/proxy.log\"\nFLAG='proxy.flag'\nTEMP=''\n" >> "${DIR_TEMP}/proxy.sh"
	echo -e "REPO_PREFIX=\"\$(pwd)\"\nREPO_OPTION=\"\${REPO_PREFIX}/Software\"\nREPO_SYSTEM=\"\${REPO_PREFIX}/Software\"\nREPO_REMOTE='${REPO_REMOTE}'\nREPO_SOURCE='${REPO_SOURCE}'\nREPO_TARGET='${REPO_TARGET}'\n" >> "${DIR_TEMP}/proxy.sh"
	echo -e "CPU='${CPU}'\nKERNEL='${KERNEL}'\n" >> "${DIR_TEMP}/proxy.sh"
	echo -e "DEPENDENCY=''\nVERSION=''\nVERFILE=''\nRAWFILE=''\nOPTFILE=''\nDEPFILE=''\nAPPFILE=''\nAPPHEAD=''\nAPPNAME=''\nAPPARCH=''\nAPPTYPE=''\nAPPEXTN=''" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo '# Function Declarations' >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^exitGracefully()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"				# https://stackoverflow.com/questions/6916856/can-bash-show-a-functions-definition
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^splitName()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^addDependency()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^deleteDependency()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^processDependencies()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^copyPackage()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^downloadPackage()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo '# Directory Checks' >> "${DIR_TEMP}/proxy.sh"
	echo "if [ ! -d \"\$REPO_OPTION\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "	mkdir -p \"\$REPO_OPTION\" >>\"\$LOG_ERRS\" 2>&1 || { echo \"ERROR: The storage directory (REPO_OPTION) does not exist and could not be created.\" | tee -a \$LOG_ERRS; exit 1; }" >> "${DIR_TEMP}/proxy.sh"
	echo "fi" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo '# Start Execution' >> "${DIR_TEMP}/proxy.sh"
	echo "for RAWFILE in \$(cat proxy.list); do" >> "${DIR_TEMP}/proxy.sh"
	echo "	processDependencies \"\${RAWFILE}\"" >> "${DIR_TEMP}/proxy.sh"
	echo "	[ ! \"\$DEPENDENCY\" ] && continue" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo "	while [ \"\$DEPENDENCY\" ] && [ \$INDEX -gt 0 ]; do" >> "${DIR_TEMP}/proxy.sh"
	echo "		splitName \"\$DEPENDENCY\"" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo "		if [ ! \"\$REPO_SOURCE\" ] && [ -e \"./\${APPFILE}\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "			SOURCE='local'" >> "${DIR_TEMP}/proxy.sh"
	echo "		elif [ \"\$REPO_SOURCE\" ] && ( echo \"\$REPO_SOURCE\"|grep -q ^'http' || echo \"\$REPO_SOURCE\"|grep -q ^'ftp' ); then" >> "${DIR_TEMP}/proxy.sh"
	echo "			cd \"\$REPO_OPTION\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			DOWNLOAD=TRUE" >> "${DIR_TEMP}/proxy.sh"
	echo "		elif [ \"\$REPO_SOURCE\" ] && ( echo \"\$REPO_SOURCE\"|grep -q ^'/' || echo \"\$REPO_SOURCE\"|grep -q ^'./' ) && ( [ -e \"\${REPO_SOURCE}/\${APPFILE}\" ] || [ -f \"\${REPO_SOURCE}/\${VERFILE}\" ] ); then" >> "${DIR_TEMP}/proxy.sh"
	echo "			cd \"\$REPO_SOURCE\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			unset DOWNLOAD" >> "${DIR_TEMP}/proxy.sh"
	echo "		elif [ -e \"\${REPO_SYSTEM}/\${APPFILE}\" ] || [ -f \"\${REPO_SYSTEM}/\${VERFILE}\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "			cd \"\$REPO_SYSTEM\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			unset DOWNLOAD" >> "${DIR_TEMP}/proxy.sh"
	echo "		else" >> "${DIR_TEMP}/proxy.sh"
	echo "			cd \"\$REPO_OPTION\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			( [ -e \"\${REPO_OPTION}/\${APPFILE}\" ] || [ -f \"\${REPO_OPTION}/\${VERFILE}\" ] ) && unset DOWNLOAD || DOWNLOAD=TRUE" >> "${DIR_TEMP}/proxy.sh"
	echo "		fi" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo "		if [ \"\$DOWNLOAD\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "			( [ \"\$SILENT\" ] || [ \"\$QUIET\" ] ) || echo -n \"\${APPFILE}: [remote] [download]\"" >> "${DIR_TEMP}/proxy.sh"
	echo "			[ \"\$REPO_TARGET\" ] && cd \"\$REPO_TARGET\" >>\$LOG_ERRS 2>&1 || cd \"\$REPO_OPTION\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			downloadPackage || exitGracefully 1" >> "${DIR_TEMP}/proxy.sh"
	echo "		elif [ \"\$COPY\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "			( [ \"\$SILENT\" ] || [ \"\$QUIET\" ] ) || echo -n \"\${APPFILE}: [local] [copy]\"" >> "${DIR_TEMP}/proxy.sh"
	echo "			copyPackage || exitGracefully 1" >> "${DIR_TEMP}/proxy.sh"
	echo "		fi" >> "${DIR_TEMP}/proxy.sh"
	echo "		( [ \"\$SILENT\" ] || [ \"\$QUIET\" ] ) || echo \" [done]\"" >> "${DIR_TEMP}/proxy.sh"
	echo "		deleteDependency TRUE" >> "${DIR_TEMP}/proxy.sh"
	echo "	done">> "${DIR_TEMP}/proxy.sh"
	echo "done">> "${DIR_TEMP}/proxy.sh"

	chmod 755 "${DIR_TEMP}/proxy.sh"
}


# Usage syntax: unloadPackage PACKAGE
# Overview:	performs the actual work of deleting the package contents from the system no matter if they were copied or symlinked - with the option of a complete uninstallation
# Notes:	the package unload-able checking is performed in processDependencies()
# 		the directory containing the package(s) should already be entered BEFORE calling this function!
#		if [ "$RAWFILE" != "$APPFILE" ] then a specific version was passed
#		http://forum.tinycorelinux.net/index.php/topic,5012.msg26650.html#msg26650
# Parameters:
# PACKAGE	[string] the package name that is being installed
unloadPackage() {
	local PARAMS=''
	local FILE=''
	local MODE='copy'

	splitName "$1"

	[ $DEBUG -gt 0 ] && { echo -en "unloadPackage:\n\tRAWFILE     |${RAWFILE}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${ARCH}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\tOPTFILE     |${OPTFILE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	showMsg 'file' "[ local] (${FILETYPE}) ${PACKAGE}" 'both' 1 1

	[ "$UNLOAD" != 'unload2' ] && [ ! -e "${DIR_LIST}/${FILENAME}" ] && {				# if the package has been marked for uninstallation (delete or purge) -AND- it currently is NOT installed, then...
		uninstallPackage || return 1							#   uninstall the package files
		return 0									#   no need to process anything further!
	}

	# if the package has a service start/stop script, then stop the service before continuing
	if [ -e "${DIR_INIT}/${PACKAGE}" ]; then
		[ $DEBUG -gt 0 ] && echo -e "\tPackage has service script...\n\tCalling:    \"${DIR_INIT}/${PACKAGE}\" stop" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && ( "${DIR_INIT}/${PACKAGE}" stop >>"$LOG_ERRS" 2>&1 || return 1 )
	fi

	# determine how the package was installed (copied or symlinked) -AND- make sure it's not in use by something else
	if ( /bin/mount 2>>"$LOG_ERRS" | grep -q "${DIR_LOOP}/${BASENAME} type squashfs" ); then	# if the package has been mounted and symlinked, then...
		MODE='link'
		[ $DEBUG -gt 0 ] && echo -e "\tPackage is symlinked...\n\tCalling:    sudo /bin/umount -d \"${DIR_LOOP}/${BASENAME}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && ( sudo /bin/umount -d "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || return 1 )				#   umount the squashfs file to make sure no contents are being used by other software (thanks Marco Caminati)
	elif [ $DEBUG -gt 0 ]; then
		echo -e "\tPackage is copied..." >>"$LOG_DBUG"
	fi
# UPDATED 2025/11/17 - now using MODE
#		[ $DEBUG -gt 0 ] && echo -e "\tCalling: sudo /bin/mount \"./${FILENAME}\" \"${DIR_LOOP}/${BASENAME}\" -t squashfs -o loop,ro,bs=4096" >>"$LOG_DBUG"
#		[ ! "$DRYRUN" ] && sudo /bin/mount "./${FILENAME}" "${DIR_LOOP}/${BASENAME}" -t squashfs -o loop,ro,bs=4096 >>"$LOG_ERRS" 2>&1 || return 1			# remount it again for further processing
#	else											# otherwise it was a copy-to-RAM, so...
		# NOTE: some of these actions can take place even if it's a DRYRUN
		[ ! -e "${DIR_LOOP}/${BASENAME}" ] && {			# if the mount point doesn't exist, then create it!
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    mkdir -p \"${DIR_LOOP}/${BASENAME}\"" >>"$LOG_DBUG"
			mkdir -p "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || return 1
		}

		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    sudo /bin/mount \"./${FILENAME}\" \"${DIR_LOOP}/${BASENAME}\" -t squashfs -o loop,ro,bs=4096" >>"$LOG_DBUG"
		( [ ! "$DRYRUN" ] || ( [ "$DRYRUN" ] && [ "$MODE" = 'copy' ] ) ) && ( sudo /bin/mount "./${FILENAME}" "${DIR_LOOP}/${BASENAME}" -t squashfs -o loop,ro,bs=4096 >>"$LOG_ERRS" 2>&1 || return 1 )			# now mount it for processing
	if [ ! "$DRYRUN" ] && [ "$MODE" = 'copy' ]; then
# UPDATED 2025/11/17 - now using MODE
#		if [ ! "$DRYRUN" ]; then
			for FILE in $(find "${DIR_LOOP}/${BASENAME}" ! -type d 2>>"$LOG_ERRS" | sed "s|^${DIR_LOOP}/${BASENAME}||"); do		# scan to make sure that no software in the package is being used
				fuser "$FILE" >>"$LOG_ERRS" 2>&1 && return 1				#   if one of the files in the package is currently in use, then exit this function	https://liquidat.wordpress.com/2015/08/26/short-tip-show-processes-accessing-a-file-fuser-lsof/   http://unix.stackexchange.com/questions/60492/whats-the-difference-between-lsof-and-fuser-uvm
			done
#		fi
	fi

	# check if the package has any libs we need to unload later						  NOTE: we check this way because simply checking for the directory can produce false positives
	[ $DEBUG -gt 0 ] && echo -en "\tChecking for libraries and modules:" >>"$LOG_DBUG"
	( ls -1p "${DIR_LOOP}/${BASENAME}/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE				# NOTE: the "grep -qv '/'$" removes directories from the listing so only files remain (otherwise /lib/modules/ would provide a false positive)
	( ls -1p "${DIR_LOOP}/${BASENAME}/lib64" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	( ls -1p "${DIR_LOOP}/${BASENAME}/usr/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	( ls -1p "${DIR_LOOP}/${BASENAME}/usr/local/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	# check if the package has a [/usr[/local]]'/lib/modules' directory to indicate we need to load modules later
	[ -d "${DIR_LOOP}/${BASENAME}/lib/modules" ] || [ -d "${DIR_LOOP}/${BASENAME}/usr/lib/modules" ] || [ -d "${DIR_LOOP}/${BASENAME}/usr/local/lib/modules" ] && MODULES=TRUE	# NOTE: we CAN simply check for directories here since files would be packaged under them
	[ $DEBUG -gt 0 ] && [ "$LIBRARIES" ] && echo -n " [libraries]" >>"$LOG_DBUG"
	[ $DEBUG -gt 0 ] && [ "$MODULES" ] && echo -n " [modules]" >>"$LOG_DBUG"
	[ $DEBUG -gt 0 ] && echo " [done]" >>"$LOG_DBUG"

	# if we've made it here, delete all the files/dirs contained in the package from the OS
	[ "$UNLOAD" != 'purge2' ] && PARAMS='! -path "*/etc/*"'					# if we have been instructed to NOT purge any 'etc' files, then add these parameters to the 'find' calls below   http://www.cyberciti.biz/faq/find-command-exclude-ignore-files/

	[ $DEBUG -gt 0 ] && echo -e "\tRemoving package contents from filesystem..." >>"$LOG_DBUG"
	for FILE in $(eval find "${DIR_LOOP}/${BASENAME}" $PARAMS 2>>"$LOG_ERRS" | sed "s|^${DIR_LOOP}/${BASENAME}/||" | sort -r); do		# NOTE: we 'sort -r' to place the file above the directories since they have to be removed first!
		if [ ! -d "$FILE" ]; then						#   if the iterated FILE is anything but a directory (e.g. device file, symlink, text file, ...), then delete it!
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rm -f \"${DIRECTORY}${FILE}\"" >>"$LOG_DBUG"
			[ ! "$DRYRUN" ] && ( rm -f "${DIRECTORY}/${FILE}" >>"$LOG_ERRS" 2>&1 || return 1 )
		elif [ -d "$FILE" ] && [ ! "$(ls -A "$FILE" 2>/dev/null)" ]; then				#   otherwise it is a directory, so check if it's empty and delete it if so!
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rmdir \"${DIRECTORY}${FILE}\"" >>"$LOG_DBUG"
			[ ! "$DRYRUN" ] && rmdir "${DIRECTORY}${FILE}" >>"$LOG_ERRS" 2>&1			#   NOTE: we do NOT error out here if we can't delete it!
		fi
	done

	[ -e "${DIR_LIST}/${FILENAME}" ] && {
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rm -f \"${DIR_LIST}/${FILENAME}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/${FILENAME}" >>"$LOG_ERRS" 2>&1		# delete the installed marker
	}
	[ -e "${DIR_LIST}/${BASENAME}.${EXT_HASH}" ] && {
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rm -f \"${DIR_LIST}/${BASENAME}.${EXT_HASH}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/${BASENAME}.${EXT_HASH}" >>"$LOG_ERRS" 2>&1
	}
	[ -e "${DIR_LIST}/${BASENAME}.${EXT_DEPS}" ] && {
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rm -f \"${DIR_LIST}/${BASENAME}.${EXT_DEPS}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/${BASENAME}.${EXT_DEPS}" >>"$LOG_ERRS" 2>&1
	}
	if [ ! "$DRYRUN" ] || ( [ "$DRYRUN" ] && [ "$MODE" = 'copy' ] ); then
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    sudo /bin/umount -d \"${DIR_LOOP}/${BASENAME}\"" >>"$LOG_DBUG"
		sudo /bin/umount -d "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || return 1					# finally umount the package

		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rmdir \"${DIR_LOOP}/${BASENAME}\"" >>"$LOG_DBUG"
		rmdir "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1								# delete the packages mount point
	fi

	# if we also need to uninstall (delete or purge), then...
	[ "$UNLOAD" != 'unload2' ] && {
		showMsg 'step' " [uninstall]" 'both' 0 0
		uninstallPackage || return 1											# if the package has been marked for uninstallation, then...
	}
# LEFT OFF - when installing, and a file exists (e.g. grep symlink to busybox), then rename to FILE.-PACK.TYPE (or 'SYS' if not part of package); when the PACK.TYPE is uninstalled and one of those files exists, restore it
#		is this necessary if we are creating restore points?

	return 0




	[ $DEBUG -gt 0 ] && echo -e "unloadPackage:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:" >>"$LOG_DBUG"

# UPDATED 2025/10/22 - merged -P with -U
#	[ $PURGE -gt 0 ] && [ ! -e "${DIR_LIST}/${APPFILE}" ] && {				# if the package has been marked for uninstallation -AND- it currently is NOT installed, then...
	[ "$PURGE" != '' ] && [ ! -e "${DIR_LIST}/${APPFILE}" ] && {				# if the package has been marked for uninstallation -AND- it currently is NOT installed, then...
		uninstallPackage || return 1							#   uninstall the package files
		return 0									#   no need to process anything further!
	}
# UPDATED 2025/10/22 - merged -P with -U
#	[ $PURGE -eq 1 ] && PARAMS='! -path "*/etc/*"'						# if we have been instructed to NOT delete any 'etc' files, then add these parameters to the 'find' calls below   http://www.cyberciti.biz/faq/find-command-exclude-ignore-files/
# UPDATED 2025/10/2 - merged with -u
#	[ "$PURGE" = 'app' ] && PARAMS='! -path "*/etc/*"'					# if we have been instructed to NOT delete any 'etc' files, then add these parameters to the 'find' calls below   http://www.cyberciti.biz/faq/find-command-exclude-ignore-files/
	[ "$PURGE" = 'delete' ] && PARAMS='! -path "*/etc/*"'					# if we have been instructed to NOT purge any 'etc' files, then add these parameters to the 'find' calls below   http://www.cyberciti.biz/faq/find-command-exclude-ignore-files/

	if [ -e "${DIR_INIT}/${APPNAME}" ]; then						# if the package has a service start/stop script, then indicate we need to execute it before continuing
		[ $DEBUG -gt 0 ] && echo -e "\tPackage has service script...\n\tCalling: \"${DIR_INIT}/${APPNAME}\" stop" >>"$LOG_DBUG"
		"${DIR_INIT}/${APPNAME}" stop >>"$LOG_ERRS" 2>&1 || return 1
	fi

	if ( /bin/mount 2>>"$LOG_ERRS" | grep -q "/${APPNAME}.${APPTYPE} type squashfs" ); then	# if the package has been mounted and symlinked, then...
		[ $DEBUG -gt 0 ] && echo -e "\tPackage is symlinked...\n\tCalling: sudo /bin/umount \"${DIR_LOOP}/${APPNAME}.${APPTYPE}\"" >>"$LOG_DBUG"
		sudo /bin/umount "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 || return 1				#   umount the squashfs file to make sure no contents are being used by other software (thanks Marco Caminati)

		[ $DEBUG -gt 0 ] && echo -e "\tCalling: sudo /bin/mount \"./$APPFILE\" \"${DIR_LOOP}/${APPNAME}.${APPTYPE}\" -t squashfs -o loop,ro,bs=4096" >>"$LOG_DBUG"
		sudo /bin/mount "./$APPFILE" "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -t squashfs -o loop,ro,bs=4096 >>"$LOG_ERRS" 2>&1 || return 1			# remount it again for further processing
	else											# otherwise it was a copy-to-RAM, so...
		[ ! -e "${DIR_LOOP}/${APPNAME}.${APPTYPE}" ] && { mkdir -p "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 || return 1; }			# if the mount point doesn't exist, then create it!

		[ $DEBUG -gt 0 ] && echo -e "\tPackage is in the RAM...\n\tCalling: sudo /bin/mount \"./$APPFILE\" \"${DIR_LOOP}/${APPNAME}.${APPTYPE}\" -t squashfs -o loop,ro,bs=4096" >>"$LOG_DBUG"
		sudo /bin/mount "./$APPFILE" "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -t squashfs -o loop,ro,bs=4096 >>"$LOG_ERRS" 2>&1 || return 1			# now mount it for processing

		for FILE in $(find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" ! -type d 2>>"$LOG_ERRS" | sed "s:${DIR_LOOP}/${APPNAME}.${APPTYPE}::"); do		# scan to make sure that no software in the package is being used
			fuser "$FILE" >>"$LOG_ERRS" 2>&1 && return 1				#   if one of the files in the package is currently in use, then exit this function	https://liquidat.wordpress.com/2015/08/26/short-tip-show-processes-accessing-a-file-fuser-lsof/   http://unix.stackexchange.com/questions/60492/whats-the-difference-between-lsof-and-fuser-uvm
		done
	fi

	[ $DEBUG -gt 0 ] && echo -e "\tChecking for modules..." >>"$LOG_DBUG"
	find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -type d -name modules 2>>"$LOG_ERRS" | grep -q . && MODULES=TRUE			# if the package has a [/lib/]'modules' directory, then we need to indicate we need to unload those modules later
	find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -type d -name lib 2>>"$LOG_ERRS" | grep -q . && LIBRARIES=TRUE			# if the package has a [/../]'lib' directory, then we need to indicate we need to load them later
# UPDATED 2018/07/14 - since TC packages do NOT adhere to this, we need a more robust solution
#	[ "$APPTYPE" = 'lib' ] && LIBRARIES=TRUE										# if the package has dynamic libraries, then indicate we need to remove those from the cache file later

	[ $DEBUG -gt 0 ] && echo -e "\tRemoving package contents from filesystem..." >>"$LOG_DBUG"
	for FILE in $(eval find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" $PARAMS 2>>"$LOG_ERRS" | sed "s:${DIR_LOOP}/${APPNAME}.${APPTYPE}::" | sort -r); do		# if we've made it here, delete all the files/dirs contained in the package from the OS
		if [ ! -d "$FILE" ]; then rm -f "$FILE" >>"$LOG_ERRS" 2>&1 || return 1						#   if the iterated FILE is anything but a directory (e.g. device file, symlink, text file, ...), then delete it!
		elif [ ! "$(ls -A "$FILE" 2>/dev/null)" ]; then rmdir "$FILE" >>"$LOG_ERRS" 2>&1; fi				#   otherwise it is a directory, so check if it's empty and delete it if so! NOTE: we do NOT error out here if we can't delete it!
	done

	[ -e "${DIR_INIT}/${APPNAME}" ] && rm -f "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>&1					# delete any service script (if it hasn't already above; in the event we have a script with a different name than the package [e.g. a specific version number])
	[ -e "${DIR_INST}/${APPNAME}.${APPTYPE}" ] && rm -f "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1		# delete the tce.installed marker (if it hasn't already above; in the event we have a marker with a different name than the package [e.g. a specific version number])
	sudo /bin/umount -d "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 || return 1					# finally umount the package
	rmdir "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1								# delete the packages mount point

# UPDATED 2025/10/22 - merged -P with -U
#	[ "$PURGE" -gt '0' ] && {
	[ "$PURGE" != '' ] && {
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [uninstall]"
		uninstallPackage || return 1											# if the package has been marked for uninstallation, then...
	}
# LEFT OFF - when installing, and a file exists (e.g. grep symlink to busybox), then rename to FILE.-PACK.TYPE (or 'SYS' if not part of package); when the PACK.TYPE is uninstalled and one of those files exists, restore it
#		is this necessary if we are creating restore points?

	[ -e "${DIR_LIST}/${APPFILE}" ] && rm -f "${DIR_LIST}/${APPHEAD}."* >>"$LOG_ERRS" 2>&1					# delete the 'catalog' item
# UPDATED 2025/11/10
#	[ "$EXEID" ] && sed -i "/${RAWFILE}/d" "${EXEID%/*}/"*									# remove the package from all the cache files (since it was just unloaded!)	  NOTE: this was if a dep is in another list, but it doesn't have any deps and can be unloaded too
	[ "$EXEID" ] && sed -i "/${RAWFILE}/d" "${DIR_TEMP}/"*									# remove the package from all the cache files (since it was just unloaded!)	  NOTE: this was if a dep is in another list, but it doesn't have any deps and can be unloaded too

# UPDATED 2025/10/22 - merged -P with -U
#	[ "$INDEX" -eq 1 ] && [ "$PURGE" -gt '0' ] && sed -i "/${RAWFILE}/d" "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS"		# if we are updating the system from (one of the) requested packages and not one of its dependencies (via INDEX==1) -AND- we're unloading -AND- we're are actually purging (uninstalling), then remove the package from the onboot.lst file
	[ "$INDEX" -eq 1 ] && [ "$PURGE" != '' ] && sed -i "/${RAWFILE}/d" "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS"		# if we are updating the system from (one of the) requested packages and not one of its dependencies (via INDEX==1) -AND- we're unloading -AND- we're are actually purging (uninstalling), then remove the package from the onboot.lst file
	return 0
}


# Usage syntax: uninstallPackage
# Overview:	performs the work of the actual removal of the package files (not contents - see unloadPackage()), optionally to a restore point
# Notes:	this should be called after the package has been unloaded first!!!
# 		the directory containing the file to uninstall should already be entered BEFORE calling this function!
uninstallPackage() {
	if [ ! "$DRYRUN" ] && [ "$INDEX" -eq 1 ] && [ "$UNLOAD" != 'unload2' ]; then
		[ $DEBUG -gt 0 ] && echo -e "\tCalling: sed -i \"/${FILENAME}/d\" \"${REPO_PREFIX}/${LIST_BOOT}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && sed -i "/${FILENAME}/d" "${REPO_PREFIX}/${LIST_BOOT}" 2>>"$LOG_ERRS"		# if this is a requested package and not one of its dependencies (via INDEX==1) -AND- we're are actually uninstalling (deleting or purging), then remove the package from the LIST file
	fi

	[ $DEBUG -gt 0 ] && echo -e "uninstallPackage:" >>"$LOG_DBUG"
# UPDATED 2025/11/24 - this is now an opt-out
#	if [ ! "$RESTORE" ]; then								# if we do NOT need a restore point, then...
# UPDATED 2025/12/01
#	if [ "$NORESTORE" ]; then								# if we do NOT need a restore point, then...
	if [ "$UNLOAD" ] && [ "$RESTORE" ]; then						# if we do NOT need a restore point (via -u and -R), then...
# UPDATED 2025/11/13
#		[ $DEBUG -gt 0 ] && echo -e "\tSkip creating a restore point...\n\trm -f ${APPHEAD}.*" >>$LOG_DBUG
#		rm -f "${APPHEAD}".* >>"$LOG_ERRS" 2>&1 || return 1				# just delete the packages' files (e.g. .deps, .hash, .soft, ...) and exit
		[ $DEBUG -gt 0 ] && echo -e "\tSkip creating a restore point...\n\trm -f ${BASENAME}.*" >>$LOG_DBUG
		[ ! "$DRYRUN" ] && ( rm -f "${BASENAME}".* >>"$LOG_ERRS" 2>&1 || return 1 )				# just delete the packages' files (e.g. .deps, .hash, .soft, ...) and exit
		return 0
	fi

	# if we've made it here then we need to create a restore point
	[ $DEBUG -gt 0 ] && echo -e "\tCreating a restore point..." >>$LOG_DBUG
	showMsg 'step' " [archiving]" 'both' 0 0

	# For XiniX only so the archives have permanence
	if [ ! -e "${REPO_RESTOR}" ] && [ -e "${DIR_MOUNT}/DATA/Links" ]; then			# if the root-level restore directory doesn't exist (e.g. /var/restore/2017-01-01 > /var/restore) -AND- there's a DATA, then...
		if [ ! -e "${DIR_MOUNT}/DATA/Links${REPO_RESTOR}" ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: mkdir -p \"${DIR_MOUNT}/DATA/Links${REPO_RESTOR}\"" >>"$LOG_DBUG"
			if [ ! "$DRYRUN" ]; then
				mkdir -p "${DIR_MOUNT}/DATA/Links${REPO_RESTOR}" >>"$LOG_ERRS" 2>&1 || {					#   create the restore directory on the DATA partition so that it actually gets preserved between reboots of the device
					echo "ERROR: the restore directory could not be created." >>"$LOG_ERRS"				# NOTE: we only write this to the log
					return 1
				}
			fi
		fi
		[ $DEBUG -gt 0 ] && echo -e "\tCalling: ln -sf \"${DIR_MOUNT}/DATA/Links${REPO_RESTOR}\" \"${REPO_RESTOR}\"" >>"$LOG_DBUG"
		if [ ! "$DRYRUN" ]; then
			ln -sf "${DIR_MOUNT}/DATA/Links${REPO_RESTOR}" "${REPO_RESTOR}" >>"$LOG_ERRS" 2>&1 || {				#   now symlink to it so we can reference its contents
				echo "ERROR: The symlink to the restore directory could not be created." >>"$LOG_ERRS"			# NOTE: we only write this to the log
				return 1
			}
		fi
	fi

# LEFT OFF - delete any extra files too

	# now create a unique name for the restore point: ACTION PACKAGE_NAMES/DIR_NAME (e.g. Updating sdl)
	TEMP="$(date +%F)/"
# UPDATED 2025/11/13
#	[ "$INSTALL" ] && ( [ "$FORCE" ] || [ "$RESTORE" ] ) && TEMP="${TEMP}Updating ${APPNAME}.${APPTYPE}"			# add a description of this process to the restore point
# UPDATED 2025/11/21
#	[ "$INSTALL" ] && ( [ "$FORCE" ] || [ "$RESTORE" ] ) && TEMP="${TEMP}Updating ${BASENAME}"			# add a description of this process to the restore point
# UPDATED 2025/11/24
#	[ "$INSTALL" ] && [ "$FORCE" ] && [ ! "$RESTORE" ] && TEMP="${TEMP}Updating ${BASENAME}"			# add a description of this process to the restore point
#	[ "$INSTALL" ] && [ ! "$FORCE" ] && [ "$RESTORE" ] && TEMP="${TEMP}Restoring ${BASENAME}"			# add a description of this process to the restore point
# UPDATED 2025/12/01
#	[ "$INSTALL" ] && TEMP="${TEMP}Updating ${BASENAME}"			# add a description of this process to the restore point
#	[ "$RESTORE" ] && TEMP="${TEMP}Restoring ${BASENAME}"			# add a description of this process to the restore point
	[ "$INSTALL" ] && [ "$RESTORE" ] && TEMP="${TEMP}Restoring ${BASENAME}"			# add a description of this process to the restore point
	[ "$INSTALL" ] && [ ! "$RESTORE" ] &&  TEMP="${TEMP}Updating ${BASENAME}"			# add a description of this process to the restore point
# UPDATED 2025/10/22 - merged -P with -U
#	[ "$UNLOAD" ] && [ "$PURGE" -gt '0' ] && TEMP="${TEMP}Uninstalling ${APPNAME}.${APPTYPE}"
# UPDATED 2025/11/13
#	[ "$UNLOAD" ] && [ "$PURGE" != '' ] && TEMP="${TEMP}Uninstalling ${APPNAME}.${APPTYPE}"
	[ "$UNLOAD" != 'unload' ] && TEMP="${TEMP}Uninstalling ${BASENAME}"

	# NOTE: the below line will create the entire REPO_RESTOR directory structure if there is no DATA, or just the date directory in the event there is one
	if [ ! -e "${REPO_RESTOR}/${TEMP}" ]; then
		[ $DEBUG -gt 0 ] && echo -e "\tCalling: mkdir -p \"${REPO_RESTOR}/${TEMP}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && ( mkdir -p "${REPO_RESTOR}/${TEMP}" >>"$LOG_ERRS" 2>&1 || return 1 )		# if the restore point directory doesn't exist, then create it!
	fi

# UPDATED 2025/11/13
#	readlink "$APPFILE" >/dev/null 2>&1 && {												# if a particular prior version of the package that was installed (designated via a symlink), then...
#		[ $DEBUG -gt 0 ] && echo -e "\tPrior version...\n\tmv -f \"$(readlink ${APPFILE} | head -c -6)\".* \"${REPO_RESTOR}/${TEMP}\"" >>"$LOG_DBUG"
#		mv -f "$(readlink "${APPFILE}" 2>>"$LOG_ERRS" | head -c -6)".* "${REPO_RESTOR}/${TEMP}" >>"$LOG_ERRS" 2>&1 || return 1		# move the actual files referenced by the symlinks to the restore point (which would be the numerical named files)
#	}
#	[ $DEBUG -gt 0 ] && echo -e "\tmv -f ${APPHEAD}.* \"${REPO_RESTOR}/${TEMP}\"" >>"$LOG_DBUG"
#	mv -f "${APPHEAD}".* "${REPO_RESTOR}/${TEMP}" >>"$LOG_ERRS" 2>&1 || return 1		# now move the iterated dependency into the restore point	NOTE: it will be symlinks if VERSION has a value
	readlink "$FILENAME" >/dev/null 2>&1 && {												# if a particular prior version of the package that was installed (designated via a symlink), then...
		[ $DEBUG -gt 0 ] && echo -e "\tPrior version...\n\tCalling: mv -f \"$(readlink ${FILENAME} | sed "s|\.${EXT_SOFT}||")\".* \"${REPO_RESTOR}/${TEMP}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && mv -f "$(readlink "${FILENAME}" 2>>"$LOG_ERRS" | sed "s|\.${EXT_SOFT}||")".* "${REPO_RESTOR}/${TEMP}" >>"$LOG_ERRS" 2>&1 || return 1		# move the actual files referenced by the symlinks to the restore point (which would be the numerical named files)
	}
	[ $DEBUG -gt 0 ] && echo -e "\tCalling: mv -f ${BASENAME}.* \"${REPO_RESTOR}/${TEMP}\"" >>"$LOG_DBUG"
	[ ! "$DRYRUN" ] && mv -f "${BASENAME}".* "${REPO_RESTOR}/${TEMP}" >>"$LOG_ERRS" 2>&1 || return 1		# now move the iterated dependency into the restore point	NOTE: it will be symlinks if VERSION has a value
	return 0
}


# Usage syntax: validatePackage													REMOVED 2025/11/06
# Overview:	validates the package is 'correct', including all the dependencies are installed, all data files/dirs
#		from packages are installed, validate contents md5sum checks, ownership and permissions are correct
# Notes:	the directory containing the file to validate should already be entered BEFORE calling this function!
validatePackage() {
	( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${APPNAME}: [data]"
	( ! /bin/mount 2>>"$LOG_ERRS" | grep -q "/${APPNAME}.${APPTYPE} type squashfs" ) && MODE='copy' || MODE='link'	# if the package is not symlink, then indicate we need to copy it!
	installPackage || exitGracefully 1
	( [ "$SILENT" ] || [ "$QUIET" ] ) || echo " [done]"
	return 0
}




# LOAD VARIABLE PERSONALIZATION

[ -e "${DIR_CONF}/config" ] && . "${DIR_CONF}/config"						# overwrite any of the variables set above by reading in a global config file
# UPDATED 2025/10/25 - dash as sh threw errors
#[ -e "${HOME}/.${DIR_CONF:1}/config" ] && . "${HOME}/.${DIR_CONF:1}/config"			# same using a personalized config file - using XSB
#[ -e "${HOME}/.${DIR_CONF##*/}/config" ] && . "${HOME}/.${DIR_CONF##*/}/config"			# same using a personalized config file - using LSB
[ -e "${HOME}/.$(echo "${DIR_CONF}" | tail -c +2)/config" ] && . "${HOME}/.$(echo "${DIR_CONF}" | tail -c +2)/config"			# same using a personalized config file - using XSB
[ -e "${HOME}/.${DIR_CONF##*/}/config" ] && . "${HOME}/.${DIR_CONF##*/}/config"			# same using a personalized config file - using LSB




# SET DEFAULT/UNINITIALIZED VARIABLE VALUES							  NOTE: we have to set these here since they rely on functions above

# MOVED 2025/11/20 - these were moved back to the top and eval'ed if BOOTING
#[ ! "$LIST_BOOT" ] && LIST_BOOT="$( ( checkBootcode list2 && [ -e "${REPO_PREFIX}/$(getBootcode list2)" ] ) && getBootcode list2 || echo 'optional.list')"				# stores a specified secondary boot list (if it exists) -OR- uses the default 'optional.list' otherwise
#[ ! "$LIST_FLAG" ] && LIST_FLAG="${LIST_BOOT%.*}.flag"																		# store an accompanying blacklist flag file for packages that should NOT be installed from the secondary boot list (or their dependencies)
#[ ! "$MODE" ] && MODE="$(TEMP="$(getBootcode mode)"; ( [ "$TEMP" = 'conservative' ] || readlink $REPO_PREFIX | grep -q DATA ) && echo 'link' || echo 'copy')"			# store the install mode: copy, (sym)link	NOTE: symlink by default if we are in a 'conservative' operation mode -OR- we are using DATA as the source of the repo




# SCRIPT PARAMETER PROCESSING

if [ "$1" = '--help' ]; then									# displays ACTION and OPTION help for this script
	echo
	echo " This script provides package management for a Linux distro that currently does"
	echo " not have this functionality, or is interested in switching from its existing"
	echo " implementation. The packages created and used by this system can be copied out"
	echo " or mounted and linked-to using the read-only and compact squashfs file system."
	echo
	echo "  Usage: ${0##*/} [OPTIONS] ACTION {PACKAGE(S)|FILELIST} [DIRECTORY]"
	echo
	echo '  ACTIONS:'
#	echo '	-a   '
#	echo '	-b   '
	echo '	-c   copy local packages to another directory'				# old '-t' > new '-c'	# NOTE: if you want to copy local and remote, use '-d' with '-S' and/or DIRECTORY
	echo '	-d   download package(s) only'
	echo '	-e   extract local package(s) contents'
	echo '	-f   find which local package(s) a file belongs to'
#	echo '	-g   '
#	echo '	-h   '
	echo '	-i   install package(s)'
#	echo '	-j   '
#	echo '	-k   '
# VER2 - ability to show packages that are downloaded, but not installed (e.g. -l all,downloaded,installed)
	echo '	-l   list all currently installed packages'
	echo '	-m   make a new package (requires DIRECTORY)'					# this makes a new .soft package tarball based on the passed directory; 	NOTE: you can just have the .make file call builder to do all the heavy lifting
#	echo '	-n   '
	echo '	-o   open a fifo for (remote) communication'		# this will allow remote administration; uses DIR_TEMP/input
# VER2 - check for updates to installed packages (compare the version numbers in the local .list files vs ones dl'ed from repo server); use cron to do this regularly
#	echo '	-p   process updates for installed packages'
#			check		simply checks for updates and notifies
#			download	checks and downloads updates
#			install		checks, downloads, and installs updates
#			checks(etup)	installs a cron job to check and notify
#			downloads(etup)	installs a cron job to check and download
#			installs(etup)	installs a cron job to do everything
#			deletes(etup)	deletes any existing update cron job
#	echo '	-q   '
# REMOVED 2025/12/01
#	echo '	-r   restore package(s) from a restore point'					# NOTE: this does not perform any uninstallation of newer running version or installation of the restored version, just restores the software (and deps) to the 'optional' directory (as if the package had just be downloaded)
#	echo '	-r   '
# VER2 - implement the below; it's like apt-search; this needs to work with both directory structure and URL submissions; make it so you can search for packages (names) or files (within a package, like the -f action but for all packages in the repo)
#		maybe create a php file that can be used in TC repo to allow this
#	echo '	-s   search the repo to find matches of passed term(s)'
#		non-db queries will need to download all the manifest files and grep them to find the file
#		db queries will need to utilize another variable REPO_QUERY specifying the URI of the script to submit the search to
	echo '	-t   show the dependency trees of package(s): relies, reliant'
	echo '	-u   uninstall package(s): unload, delete, purge'
	echo "	-v   validate package(s) info: data, deep, deps, fix"					# makes sure all data files/dirs from packages are installed, all the dependencies are installed, validate contents md5sum checks, ownership and permissions are correct; data=files,dirs,hash,owner,perms
#	echo '	-w   '
#	echo '	-x   '
#	echo '	-y   '
	echo '	-z   populates DIR_LIST with package files'
	echo
	echo '	--help      shows this screen'
	echo '	--install   installs pax as the default package manager'
	echo '	--version   displays the software version'
	echo
	echo '  OPTIONS:'
# VER2 - implement
#	echo '	-A   approval code/key from the server when making purchases'			# so after the software is purchased, the code/key can be passed as authentication to download the software package(s)
	echo '	-B   indicates we are currently booting the system'				# use this to indicate everything gets installed to root (PREFIX=/) and obtain files from REPO_SYSTEM
	echo '	-C   specifies an alternative CPU architecture: i32, i64, r32, r64'		# this allows for alternative CPU software downloads		r01 (raspi 0 and 1), r23 (raspi 2 and 3)
# UPDATED 2025/10/22
#	echo '	-D   sets the directory prefix when installing/unloading packages'		# this can be used to install to / (OS - admin permissions), /Users/.Public (everyone), $HOME (personal) while retaining the bin, sbin, lib, etc structure
# REMOVED 2025/11/26 - this is now the DIRECTORY value
#	echo '	-D   sets the directory prefix when (un)installing packages'			# this can be used to install to / (OS - admin permissions), /Users/.Public (everyone), $HOME (personal) while retaining the bin, sbin, lib, etc structure
	echo '	-D   dependency handling: none, default, all'
	echo '	-E   include extra package files: all, code, cpio, info, list, make'				# not installed by default to keep size down
	echo '	-F   force the ACTION to take place'						# NOTE: this ignores the package installed status on the existing system so if we need to download packages to another device (e.g. installing XiniX to other media) we can do so
#	echo '	-G   '
#	echo '	-H   '
# UPDATED 2025/11/24
#	echo '	-I   list of dependencies to ignore during unload/uninstall'			# for example, web.de can be listed for theme uninstalls
	echo '	-I   list of dependencies to ignore'						# for example, web.de can be listed for theme uninstalls
# MERGED 2025/11/26 - this is now -D none
#	echo '	-J   just process the passed packages, not any dependencies'
#	echo '	-J'
	echo '	-K   specifies an alternative kernel name (4.1.6_xinix)'			# this allows for alternative kernel software downloads
# UPDATED 2025/10/23 - make this a negation instead of an inclusion, meaning we add to the list by default, but using the -L prevents this from happening
#	echo '	-L   adds the software to the (optional.)list when installing'			# this only is useful when installing
# UPDATED 2025/12/01 - this now needs to take parameters
#	echo '	-L   prevent package addition to (optional.)list when installing'			# this only is useful when installing
	echo '	-L   the list to adjust: none, boot, live'					# this only is useful when installing
	echo '	-M   defines the package install mode: copy, link (default)'		# old '-R' > new '-M copy'		NOTE: if the OS is run from RAM, then the 'copy' value will copy into RAM, if it is on a disk, then it copies to the disk
	echo '	-N   do NOT install all files in the package, just those specified'		# allows users to install desired file(s) from a package so all the contents don't get installed (to keep the system as small as possible); keeps attack vector to a minimum
# VER2 - implement the 'html' values
# UPDATED 2025/11/19
#	echo '	-O   how output is displayed: none, fifo, text, xml, xmLive'		# old '-Q' > new '-O none'		NOTE: this defines the way the output is shown
	echo '	-O   display output format: fifo, text, xml, xmLive'			# old '-Q' > new '-O none'		NOTE: this defines the way the output is shown
# UPDATED 2025/10/22 - merged -P with -U
#	echo '	-P   purges all files of the uninstalled packages including configs'		# data ALWAYS is retained though! (e.g. mysql databases)
	echo '	-P   prompt before taking action'
# UPDATED 2025/11/19
#	echo '	-Q   quiets the output to only show errors'				# old '-q' > new '-Q'
	echo '	-Q   quiets the output: all, errors, default, verbose, none'		# old '-q' > new '-Q'
# UPDATED 2025/11/24 - make this an opt-out, not an opt-in
#	echo '	-R   create a restore point when uninstalling'				# old '-N' > new 'absence of value'; if you want to create a restore point, you must now specify the flag!
# UPDATED 2025/12/01
#	echo '	-R   do NOT create a restore point when uninstalling'				# old '-N' > new 'absence of value'; if you want to create a restore point, you must now specify the flag!
	echo '	-R   the action applies to restore points'				# old '-N' > new 'absence of value'; if you want to create a restore point, you must now specify the flag!
	echo '	-S   changes the source directory/repo to obtain software from'			# mainly used when creating installation media to pull the files from an existing BOOT instead of an online repo
	echo '	-T   specifies the package type: bin, dev, doc, drv, gir, lib, loc'
# UPDATED 2025/10/22 - merged -P with -U
#	echo '	-U   uninstalls all files of the package excluding configs'		# old '-p' > new '-U'
# UPDATED 2025/10/23 - merged with -u
#	echo '	-U   uninstalls specified package files: all, app (leaves configs)'	# old '-p' > new '-U'		# data ALWAYS is retained though! (e.g. mysql databases)
#	echo '	-U   '
# DEV NOTE: can use -S and DIRECTORY to validate files on a separate hard drive (e.g. diagnostics using one computer for another computers' hard drive via USB)
	echo '	-V   the specific version of a package to install'
# UPDATED 2025/11/24 - made more generic
#	echo '	-W   installs all packages in .deps file, including optional'		# old '-A' > new '-W'			this is so that if a user is installing a drivers set, any optional software is also installed (e.g. [xf86_video_intel|xorg])
# MERGED 2025/11/26 - this is now -D all
#	echo '	-W   processes all packages in .deps file, including optional'		# old '-A' > new '-W'			this is so that if a user is installing a drivers set, any optional software is also installed (e.g. [xf86_video_intel|xorg])
#	echo '	-W'
# VER2 - proxy other actions via ssh so that administrators can push software to clients, or reinstall/delete software that's currently installed
	echo '	-X   obtain packages via proxy using another device'				# Can be used when one location has little or no Internet access. For example, @home has bad internet connection, but work is good, can dl @work for @home.
	echo '	-Y   performs a dry run of the action'
# VER2 - use -Z to add colors to output
#	echo '	-Z   '
	echo
	echo '  NOTES:'
	echo "	The '-e' ACTION will always overwrite data due to the unsquashfs binary"
	echo "	     always exiting with success - even when it fails if data already"
	echo "	     exists in the target destination."
	echo "	The '-i' ACTION first checks locally, then uses the repo."
	echo "	The '-m' ACTION can be used with pre-compiled software, or if a .make"
	echo "	     file is present, it will execute it to compile everything."
	echo "	     NOTES:"
	echo "	     - only one package can be processed per script execution"
	echo "	     - place the .make file alongside the source code directory"
# UPDATED 2025/10/23
#	echo "	     - the source code directory will also be used with packaging, so make"
#	echo "         sure to swap out its contents for the compiled software"
	echo "	     - if using a .make file, install the compiled software into a"
	echo "	       'package' directory alongside the .make file and source code"
#	echo "	     - if no -S or DIRECTORY value is passed, the current directory"
#	echo "	       is assumed"
	echo "	The '-o' ACTION requires the 'clear' command to always be last."
# REMOVED 2025/12/01
#	echo "	The '-r' ACTION does not perform an uninstallation of currently running"
#	echo "	     versions, nor installation of the restored version itself, but"
#	echo "	     simply restores the package files to the 'optional' directory to"
#	echo "	     allow re-installation when you see fit to do so."
	echo "	The '-u' ACTION will always leave user data in place (docs, pics, etc)."
	echo "	     NOTES:"
	echo "	     - Unloading removes the application files, but leaves the config"
	echo "	       files and package for easy future re-installation"
	echo "	     - Deleting leaves the configs, but removes the application files"
	echo "	       and the package so it would need to be re-downloaded before"
	echo "	       another installation could occur"
	echo "	     - Purging does the same as deleting, but also deletes the config"
	echo "	       files as well"
	echo "	The '-v' ACTION can perform various package integrity checks:"
	echo "	     - data: ownership, permissions, {symlink source|file size}"
	echo "	     - deps: verifies the package dependencies are all installed"
	echo "	     - fix : resolves any issues detected"
	echo "	     - hash: same as 'data' but md5sum hashes instead of file size"
	echo "	The '-I' OPTION value must be comma separated."
# REMOVED 2025/11/24 - this is now handled with error checking
#	echo "	The '-L', '-M', and '-V' OPTIONS can only be used with the '-i' ACTION."
	echo "	The '-N' OPTION takes a comma separated list of filenames."
# LEFT OFF - what about quote encapsulated (e.g. -N 'package1 package2 package3')
	echo "	The '-O' and '-Q' OPTIONS need to start the parameters (for init errs)."
	echo "	The '-O xmLive' OPTION does NOT encapsulate with <s> tags, so assume"
	echo "	     success unless an <f> tag is relayed."
	echo "	When using '-O fifo', the fifo must be managed by the calling script"
	echo "	     or binary, and must use DIR_TEMP/output as its location."
	echo "	The '-R' OPTION can only be used with the '-i', '-l', and '-u' ACTIONS."
	echo "	The '-S' OPTION can take a directory or URL as its value."
	echo "	     URL's need to begin with 'http' or 'ftp'."
	echo "	The '-T' OPTION can only be used once per call, so all the packages"
	echo "	     need to be of the same type. Alternatively, you can skip using"
	echo "	     this option and specify the full name of each package."
# UPDATED 2025/10/22 - merged -P with -U
#	echo "	The '-P' and '-U' OPTIONS can only be used with the '-u' ACTION and"
# REMOVED 2025/11/24 - this is now handled with error checking
#	echo "	The '-X' OPTION can only be used with the '-c' and '-d' ACTIONS."
	echo "	When using the '-V' OPTION, you can only list one package at a time."
# REMOVED 2025/10/29 - this looks like part of an old description
#	echo "	     NAME.all.src.make file exists, it will use that to compile."
	echo
	echo "	The PACKAGE(S) value can be:"
	echo "	     - a file containing a list (one package per line)"
	echo "	     - directory containing the package(s)"
	echo "	     - or a space separated list of package names"
	echo "	The DIRECTORY as the last parameter must be:"
	echo "	     - a full path: /tmp/pax/"
	echo "	     - or a relative path: ./pax"
	echo "	     - or have a trailing slash: pax/"
	echo
	echo "	The presence of a REPO_PREFIX/${FLAG_COPY} file will indicate that"
	echo "	     all packages will be copied instead of symlinked."
	echo "	The presence of a REPO_PREFIX/${FLAG_FIRM} file will indicate that"
# UPDATED 2025/12/05
#	echo "	     all the packages in REPO_SYSTEM will be loaded into RAM.  This"
#	echo "	     only takes place if REPO_SYSTEM and REPO_OPTION are different."
	echo "	     all the packages in REPO_SYSTEM or LIST_BOOT will be copied"
	echo "	     instead of symlinked."
	echo
	echo '  EXAMPLES:'
	echo '	Performing action with all packages [to current directory]:'
	echo "	     ${0##*/} -{ceilt}"
	echo '	Performing action with specific packages [to current directory]:'
	echo "	     ${0##*/} -{cdeilt} package1 package2"
	echo '	Performing action with package list [to current directory]:'
	echo "	     ${0##*/} -{cdeilt} packages.txt"
	echo '	Performing action with specific packages to/in a specified directory:'
	echo "	     ${0##*/} -{cdeilt} package1 package2 /target/path"
	echo '	Performing action with a package list to/in a specified directory:'
	echo "	     ${0##*/} -{cdeilt} packages.txt /target/path"
	echo '	Performing action with specific packages from/in a specific directory:'
	echo "	     ${0##*/} -S {URL|/source/path} -{cdeilt} package1 package2"
	echo '	Performing action with a package list from/in a specific directory:'
	echo "	     ${0##*/} -S {URL|/source/path} -{cdeilt} packages.txt"
	echo '	Performing action with all packages between specified directories:'
	echo "	     ${0##*/} -S {URL|/source/path} -{cdei} /target/path"
	echo '	Performing action with a package list between specified directories:'
	echo "	     ${0##*/} -S {URL|/source/path} -{cdei} packages.txt /target/path"
	echo
# CONSOLIDATED 2025/11/26 - above
#	echo '	Copy packages from the local repo to specified directory:'
#	echo "	     ${0##*/} -c package1 package2 /target/path"
#	echo '	Copy specified packages from a directory to specified directory:'
#	echo "	     ${0##*/} -S /source/path -c package1 package2 /target/path"
#	echo '	Copy all packages from specific directory to specified directory:'
# CONSOLIDATED 2025/12/03 - above
#	echo '	Copy all packages in a specific directory to current directory:'
#	echo "	     ${0##*/} -S /source/path -c"
# CONSOLIDATED 2025/11/26 - above
#	echo "	     ${0##*/} -S /source/path -c package1 package2 /target/path"
#	echo '	Download packages from the repo:'
#	echo "	     ${0##*/} -d package1 package2"
#	echo '	Download a package from the repo into specified directory:'
#	echo "	     ${0##*/} -d package /path/to/download"
# CONSOLIDATED 2025/12/03 - above
#	echo '	Download a package from a specific repo:'
#	echo "	     ${0##*/} -S 'https://mydomain.com/repo' -d package"
# CONSOLIDATED 2025/11/26 - above
#	echo '	Extract package(s) contents in current directory:'
#	echo "	     ${0##*/} -e package"
#	echo '	Extract package(s) contents to a specified directory:'
#	echo "	     ${0##*/} -e package /path/to/extract"
# CONSOLIDATED 2025/12/03 - above
#	echo '	Extract all packages in a specific directory to current directory:'
#	echo "	     ${0##*/} -S /source/path -e"
# CONSOLIDATED 2025/11/26 - above
#	echo '	Extract package(s) in a specific directory to current directory:'
#	echo "	     ${0##*/} -S /path/to/files -e package1 package2"
#	echo '	Extract specific package(s) in a directory to specified directory:'
#	echo "	     ${0##*/} -S /path/to/files -e package1 package2 /path/to/extract"
	echo '	Find files in available packages:'
	echo "	     ${0##*/} -f file1 file2"
	echo '	Find files in available packages from a filelist:'
	echo "	     ${0##*/} -f files.txt"
	echo '	Find files in packages within a specified directory:'
	echo "	     ${0##*/} -f file1 file2 /source/path"
	echo "	     ${0##*/} -S /source/path -f file1 file2"
# CONSOLIDATED 2025/11/26 - above
#	echo '	Install packages (local or remote):'
#	echo "	     ${0##*/} -i package1 package2"
#	echo '	Install packages from a filelist:'
#	echo "	     ${0##*/} -i [/path/to/]packages.txt"
	echo '	Install a specific version:'
	echo "	     ${0##*/} -V 1.2.3 -i package"
# CONSOLIDATED 2025/11/26 - above
#	echo '	Install packages from a specific diretory:'
#	echo "	     ${0##*/} -S /path/to/files -i package1 package2"
# CONSOLIDATED 2025/12/03 - above
#	echo '	Install packages from a specific online repo:'
#	echo "	     ${0##*/} -S 'https://...' -i package1 package2"
	echo '	Make a package for distribution:'
	echo "	     ${0##*/} -m package /path/containing/{package|source}"
	echo "	     ${0##*/} -S /path/containing/{package|source} -m package"
	echo "	     ${0##*/} -S /path/containing/{package|source} -m file"
# REMOVED 2025/11/04 - this is duplicated above
#	echo '	Extract package contents:'
#	echo "	     ${0##*/} -e package[.i32.bin.soft] [/path/to/extract]"
	echo '	Open a fifo to operate pax:'
	echo "	     ${0##*/} -o"
	echo '	Open a fifo to operate pax in a specified directory:'
	echo "	     ${0##*/} -o /path/to/fifo"
	echo "	     ${0##*/} -S /path/to/fifo -o"
	echo '	Open a fifo to operate pax using a specific fifo:'
	echo "	     ${0##*/} -o name"
	echo '	Open a fifo to operate pax, clearing a prior failure:'
	echo "	     ${0##*/} -o clear"
	echo '	Open a fifo to operate pax, clearing and using specific fifo:'
	echo "	     ${0##*/} -o name clear"
	echo '	Proxy a download:'
	echo "	     ${0##*/} -X /mnt/sdb1 -d package1 package2"
	echo '	Proxy an install:'
	echo "	     ${0##*/} -X /mnt/sdb1 -i package1 package2"
# CONSOLIDATED 2025/12/03 - above
#	echo '	Show dependency tree for package(s):'
#	echo "	     ${0##*/} -t package"
#	echo '	Show dependency tree for all installed packages:'
#	echo "	     ${0##*/} -t"
# UPDATED 2025/12/01
#	echo '	Update a package with optional restore point:'
#	echo "	     ${0##*/} [-R] -i package"
	echo '	Unload a package:'
	echo "	     ${0##*/} -u unload package"
	echo '	Uninstall a package, leaving configs:'
	echo "	     ${0##*/} -u delete package"
	echo '	Uninstall a package, including configs too:'
	echo "	     ${0##*/} -u purge package"
	echo
	exit 0
elif [ "$1" = '--install' ] || [ "$3" = '--install' ]; then			# so a user can do 'pax -O xml --install'
	if [ $# -gt 1 ]; then							# if we were passed more than just the '--version' option, it has to be '-O', so...
# UPDATED 2025/11/19
#		if [ "$2" != 'none' ] && [ "$2" != 'text' ] && [ "$2" != 'xml' ]; then						# validate the passed '-O' value
		if ( echo "$2" | grep -qE ^'(fifo|text|xml|xmLive)'$ ); then
			[ "$SILENT" ] || echo "ERROR: you must supply a proper value to the -O option." | tee -a "$LOG_ERRS"	# NOTE: we can't use showMsg() yet because we don't have it's value, so...
			exit 1
		fi
		OUTPUT=$2													# set that value to use from now on
	fi
	[ ! -e "${DIR_CONF}/install" ] && {
		showMsg 'failure' "The install script is missing to make pax the default package manager." 'screen'
		exit 1
	}
	"${DIR_CONF}/install" || exit 1
	exit 0
elif [ "$1" = '--version' ] || [ "$3" = '--version' ]; then			# so a user can do 'pax -O xml --version'
# UPDATED 2025/10/25
#	head -10 $(which pax) | grep ^'# updated' | sed "s/.*\\t//;s/ .*//;s:/:.:g"
	if [ $# -gt 1 ]; then							# if we were passed more than just the '--version' option, it has to be '-O', so...
# UPDATED 2025/11/19
#		if [ "$2" != 'none' ] && [ "$2" != 'text' ] && [ "$2" != 'xml' ]; then						# validate the passed '-O' value
		if ( echo "$2" | grep -qE ^'(fifo|text|xml|xmLive)'$ ); then
			[ "$SILENT" ] || echo "ERROR: you must supply a proper value to the -O option." | tee -a "$LOG_ERRS"	# NOTE: we can't use showMsg() yet because we don't have it's value, so...
			exit 1
		fi
		OUTPUT=$2													# set that value to use from now on
	fi
	TEMP=$(head -10 $0 | grep ^'# updated' | sed "s/.*\\t//;s/ .*//;s:/:.:g")
	showMsg 'success' "$TEMP" 'screen'
	exit 0
else
	# PROCESS PASSED PARAMETERS

	TEMP=0
	while getopts BcC:dD:eE:fFiI:K:lL:mM:N:oO:PQ:RS:t:T:u:v:V:X:Yz OPTION; do			# NOTE: the 'V:' indicates that the '-V' parameter requires a value!
		( echo $OPTION | grep -qe '[a-z]' ) && TEMP=1						# if we've reached an ACTION, then...
		if [ $TEMP -gt 0 ] && ( echo $OPTION | grep -qe '[A-Z]' ); then				# if an ACTION was already processed -AND- we've reached an OPTION, then...
			showMsg 'failure' "All OPTIONS must preceed the ACTION." 'screen'
			exit 1
		fi

		case ${OPTION} in
			B) BOOTING=TRUE ;;
			c) COPY=TRUE ;;
# UPDATED 2025/11/03
#			C) ( echo ${OPTARG} | grep -q -e ^'i32'$ -e ^'i64'$ -e ^'r32'$ ) || {
			C) ( echo "${OPTARG}" | grep -qE ^"($ARCH_VALUES)"$ ) || {
#echo "|$ARCH_VALUES|"
# UPDATED 2025/10/25
#				[ "$SILENT" ] || echo "ERROR: you must supply a CPU architecture to the -C option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a CPU architecture to the -C option." 'screen'
				exit 1
			   }
			   ARCH="$OPTARG" ;;
			d)
#echo "|$REPO_SOURCE|$REPO_OPTION|"
 [ "$REPO_SOURCE" = "$REPO_OPTION" ] && eval REPO_SOURCE="$REPO_SCHEMA"		# NOTE: we use the condition in case the -S might has been passed and processed already
			   DOWNLOAD=TRUE ;;
# REMOVED 2025/11/26 - this is now the DIRECTORY value
#			D) ( echo ${OPTARG} | grep -q ^'/' ) || {
## UPDATED 2025/10/25
##				[ "$SILENT" ] || echo "ERROR: you must supply an absolute path to the -D option." | tee -a "$LOG_ERRS"
#				showMsg 'failure' "You must provide an absolute path to the -D option." 'screen'
#				exit 1
#			   }
#			   PREFIX="$OPTARG" ;;
			D) ( echo "${OPTARG}" | grep -qE ^'(none|default|all)'$ ) || {
				showMsg 'failure' "You must provide a proper value to the -D option." 'screen'
				exit 1
			   }
			   DEPS="$OPTARG" ;;
			e) EXTRACT=TRUE ;;
# UPDATED 2025/11/03
#			E) if [ "$OPTARG" != 'all' ] && [ "$OPTARG" != 'info' ] && [ "$OPTARG" != 'list' ]; then
			E) ( echo "${OPTARG}" | grep -qE ^'(all|info|list)'$ ) || {
# UPDATED 2025/10/25
#				[ "$SILENT" ] || echo "ERROR: you must supply a valid file to the -E option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a proper value to the -E option." 'screen'
				exit 1
#			   fi
			   }
			   EXTRA="$OPTARG" ;;
			f) FIND=TRUE ;;
			F) FORCE=TRUE ;;
			i) eval LIST_BOOT="$LIST_BOOT"								# eval the variables to store processed values
# REMOVED 2025/11/25 - this is handled automatically now
#			   eval MODE="$MODE"
			   INSTALL=TRUE ;;
			I) ( echo "${OPTARG:0:1}" | grep -q ^[0-9a-zA-Z] ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a comma separated list to the -I option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a comma separated list to the -I option." 'screen'
				exit 1
			   }
			   IGNORE="$OPTARG" ;;
# MERGED 2025/11/26 - this is now -D none
#			J) ONLY=TRUE ;;
			K) #( echo "${OPTARG:0:1}" | grep -q ^[0-9] ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a kernel name to the -K option." | tee -a "$LOG_ERRS"
			#	showMsg 'failure' "You must provide a kernel name to the -K option." 'screen'
			#	exit 1
			#   }
			   KERNEL="$OPTARG" ;;
			l)
if [ 1 -eq 0 ]; then
 # [Colors]
			   NORMAL="\e[0m"
			   BLINK="\e[5m"
			   INVERSE="\e[7m"
			   HIDE="\e[8m"
			   UL="\e[4m"

			   BLACK="\e[0;30m"
			   GARNET="\e[0;31m"
			   GREEN="\e[0;32m"
			   BROWN="\e[0;33m"
			   NAVY="\e[0;34m"
			   MAGENTA="\e[1;35m"
			   TEAL="\e[0;36m"
			   DARKGREY="\e[1;30m"
			   GREY="\e[0;37m"
			   RED="\e[1;31m"
			   LIME="\e[1;32m"
			   YELLOW="\e[1;33m"
			   BLUE="\e[1;34m"
			   PURPLE="\e[0;35m"
			   CYAN="\e[1;36m"
			   WHITE="\e[1;37m"

			   [ "$QUIET" = 'all' ] && { echo "The -f action can't be used with the '-Q all' option."; exit 1; }		# NOTE: this has to be an 'echo' statement because showMsg() won't show it otherwise!
			   [ "$QUIET" = 'errors' ] && { showMsg 'failure' "The -f action can't be used with the '-Q errors' option." 'screen'; exit 1; }

			   # if we are looking for specific packages passed on the command line, then...
			   shift $(expr $OPTIND - 1)							# now that the OPTIONS have been processed, lets process the package name(s)
			   eval TEMP=\${$#}								# store the current last passed value to later check if a directory was passed as the last value	http://stackoverflow.com/questions/1853946/getting-the-last-argument-passed-to-a-shell-script
			   if [ "$TEMP" = "$0" ]; then							# if a blank or null value was given for the package name (since the 'shift' command will go back to $0), then...
				TEMP=''									#   no need to check for anything extra
			   else										# otherwise package(s) were passed, so...
				TEMP='^('								#   start a regex grep statement with packages matching the beginning of each name entered
				for RAWFILE in $@; do							#   cycle through each name passed
					TEMP="${TEMP}${RAWFILE}|"					#   adding to the regex statement
				done
				TEMP="${TEMP%|*})"							#   remove the trailing '|' character
			   fi

			   if [ "$OUTPUT" = 'text' ]; then
# UPDATED 2025/10/31
#				printf "${BLUE}%-30s %-4s %-32s %-10s\n" "Name" "Type" "              Hash" "  Version"
#				printf "${WHITE}%30s %4s %32s %10s\n" "------------------------------" "----" "--------------------------------" "----------"
				printf "${BLUE}%-30s %-9s %5s %-32s\n" "Name" " Version" "Types" "              Hash"
				printf "${WHITE}%30s %-9s %5s %32s\n" "------------------------------" "---------" "-----" "--------------------------------"
# REMOVED 2025/10/31
#			   elif [ "$OUTPUT" = 'xml' ]; then
#			   	showMsg 'HEADER' "<s>\n   <xml>\n"
			   fi

# UPDATED 2025/10/22 - no longer using APP* variables
#			   for FILE in $(ls -1 "$DIR_LIST" 2>/dev/null | grep 'soft'$); do		# NOTE: using 'grep' prevents directory from being part of FILE
#				splitName "$FILE"
#
#				printf "${NORMAL}%-30s %-49s\n" "$APPNAME" "$([ -e ${DIR_LIST}/${APPHEAD}.info ] && cat ${DIR_LIST}/${APPHEAD}.info | grep ^'Description:' | sed 's/Description:[ \t]*//')"
#				printf "%-30s ${BLUE}%-4s ${DARKGREY}%-32s ${BLUE}%-11s${NORMAL}\n" ' ' "$APPTYPE" "$([ -e ${DIR_LIST}/${APPHEAD}.hash ] && sed 's/ .*//' ${DIR_LIST}/${APPHEAD}.hash)" "$([ -e ${DIR_LIST}/${APPHEAD}.info ] && cat ${DIR_LIST}/${APPHEAD}.info | grep ^'Version:' | sed 's/Version:[ \t]*//')"
# UPDATED 2025/10/31
#			   for FILE in $(ls -1 "$DIR_LIST" 2>/dev/null | grep ${EXT_SOFT}$); do		# NOTE: using 'grep' prevents directory from being part of FILE
# UPDATED 2025/11/05 - updated to check for specific package(s)
#			   for FILE in $(ls -1 "$DIR_LIST" 2>/dev/null | grep ${EXT_SOFT}$); do		# NOTE: using 'grep' prevents directory from being part of FILE
			   for FILE in $(ls -1 "$DIR_LIST" 2>/dev/null | grep -E "${TEMP}" | grep ${EXT_SOFT}$); do		# NOTE: using 'grep' prevents directory from being part of FILE
				splitName "$FILE"
				case $BASENAME in
					*-dev*|*.dev*) TYPE='dev' ;;
					*-doc*|*.doc*) TYPE='doc' ;;
					*-drv*|*.drv*) TYPE='drv' ;;
					*-gir*|*.gir*) TYPE='gir' ;;
					*-lib*|*.lib*) TYPE='lib' ;;
					*-loc*|*.loc*) TYPE='loc' ;;
					*) TYPE='bin' ;;
				esac
				if [ "$OUTPUT" = 'fifo' ]; then
					echo "$PACKAGE" >"${DIR_TEMP}/output"
					echo "$TYPE" >"${DIR_TEMP}/output"
					echo "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//')" >"${DIR_TEMP}/output"
					echo "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${DIR_LIST}/${BASENAME}.${EXT_HASH})" >"${DIR_TEMP}/output"
					echo "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//')" >"${DIR_TEMP}/output"
				elif [ "$OUTPUT" = 'text' ]; then
# UPDATED 2025/10/31
#					printf "${BLUE}%-30s ${GREY}%-49s\n" "$PACKAGE" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//' | head -c 48)"
#					printf "%-30s ${TEAL}%-4s ${DARKGREY}%-32s ${MAGENTA}%-11s${NORMAL}\n" ' ' "$TYPE" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${DIR_LIST}/${BASENAME}.${EXT_HASH})" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//')"
					printf "${BLUE}%-30s ${GREY}%-49s\n" "$PACKAGE" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//' | head -c 48)"
					printf "${TEAL}%40s ${CYAN}%-5s ${DARKGREY}%-32s${NORMAL}\n" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//')" " $TYPE" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${DIR_LIST}/${BASENAME}.${EXT_HASH})"
				elif [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ]; then
# UPDATED 2025/10/28
#					showMsg '' '	<package>'
#					showMsg 'file' "$FILE"
# UPDATED 2025/10/30
#					showMsg 'package' "$FILE" 'screen' 0 5
					showMsg 'package' "$FILE" 'screen' 1 4
					showMsg 'type' "$TYPE" 'screen'
					showMsg 'version' "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//')" 'screen'
					showMsg 'hash' "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${DIR_LIST}/${BASENAME}.${EXT_HASH})" 'screen'
					showMsg 'description' "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//')" 'screen'
# UPDATED 2025/10/28
#					showMsg '' '	</package>'
# REMOVED 2025/10/30
#					showMsg 'package' "" 'screen' 0 4
				fi
			   done
			   [ "$OUTPUT" = 'text' ] && echo -e "${NORMAL}"
# UPDATED 2025/10/30
#			   [ "$OUTPUT" = 'xml' ] && showMsg '' "   <xml>\n</s>\n"
# UPDATED 2025/10/31
#			   [ "$OUTPUT" = 'xml' ] && showMsg 'package' "   <xml>\n</s>" 1 6
			   ( [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ] ) && showMsg 'success' "" 'screen' 1 6
			   exit 0
fi
LIST=TRUE
			   ;;
# UPDATED 2025/12/01
#			L) NOLIST=TRUE ;;
			L) ( echo "${OPTARG}" | grep -qE ^'(none|boot|live)'$ ) || {
# UPDATED 2025/10/25
#				[ "$SILENT" ] || echo "ERROR: you must supply a valid file to the -E option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a proper value to the -L option." 'screen'
				exit 1
			   }
			   PACKLIST="${OPTARG}" ;;
			m) MAKE=TRUE ;;
			M) if [ "$OPTARG" != 'copy' ] && [ "$OPTARG" != 'link' ]; then
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a proper mode type to the -M option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a proper mode type to the -M option." 'screen'
				exit 1
			   fi
			   MODE="$OPTARG" ;;
			N) FILELIST="$OPTARG" ;;
			o)
if [ 0 -eq 1 ]; then
			   [ "$2" ] && [ "$2" != 'clear' ] && FIFO_SERVER="$2"				# NOTE: the second parameter MUST be 'clear', even when using a custom input fifo
			   [ "$3" ] && FIFO_SERVER="$3"
			   if [ "$2" ] && [ "$2" = 'clear' ]; then
				rm -f "${FIFO_SERVER}" || {
					showMsg 'failure' "The input FIFO could not be cleared." 'screen'
					exit 1
				}
			   fi

			   if [ -e "${FIFO_SERVER}" ]; then
				showMsg 'failure' "Pax is already running in this mode." 'screen'
				exit 1
			   fi

			   mknod -m 700 "${FIFO_SERVER}" p || {
				showMsg 'failure' "The FIFO could not be created." 'screen'
				exit 1
			   }

			   while true; do
				if read LINE <"${FIFO_SERVER}" 2>>"$LOG_ERRS"; then
					[ "$LINE" == 'quit' ] && break
					( echo "$LINE" | grep -q ^'pax ' ) || {
						echo "ERROR: An invalid command was attempted."
						continue
					}
					showMsg 'start' "\n\n------- [ FIFO: Script Execution ] -------" 'log'
					showMsg 'start' "           $(date +'%Y-%m-%d  %H:%M:%S')\n" 'log'
					showMsg 'action' "EXECUTE: $LINE" 'both'
					$LINE
				fi
			   done

			   echo "QUIT"
			   rm -f "${FIFO_SERVER}"
			   exit 0 #;;
fi
 OPEN=TRUE ;;
# UPDATED 2025/11/03
#			O) if [ "$OPTARG" != 'none' ] && [ "$OPTARG" != 'fifo' ] && [ "$OPTARG" != 'text' ] && [ "$OPTARG" != 'xml' ] && [ "$OPTARG" != 'xmLive' ]; then
# UPDATED 2025/11/19
#			O) ( echo ${OPTARG} | grep -qE ^'(none|fifo|text|xml|xmLive)'$ ) || {
			O) ( echo "${OPTARG}" | grep -qE ^'(fifo|text|xml|xmLive)'$ ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a proper value to the -O option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a proper value to the -O option." 'screen'
				exit 1
			   }
# REMOVED 2025/11/19 - this is now part of -Q
#			   [ "$OPTARG" = 'none' ] && SILENT=TRUE
			   [ "$OPTARG" = 'fifo' ] && [ ! -e "${DIR_TEMP}/output" ] && {
				showMsg 'failure' "The fifo does not exist, aborting execution." 'screen'
				exit 1
			   }
			   ( [ "$OPTARG" = 'xml' ] || [ "$OPTARG" = 'xmLive' ] ) && {
				echo -e 'Content-Type: text/xml; charset=utf-8'
				echo -e "<?xml version='1.0' encoding='UTF-8'?>\n\n"
			   }
			   [ "$OPTARG" = 'xmLive' ] && echo '<xml>'
			   OUTPUT="$OPTARG" ;;
# MERGED 2025/10/22 - this was merged with -U
#			P) PURGE=2 ;;
			P) PROMPT=TRUE ;;
# UPDATED 2025/11/19
#			Q) QUIET=TRUE ;;
			Q) ( echo "${OPTARG}" | grep -qE ^'(all|errors|default|verbose|none)'$ ) || {
				showMsg 'failure' "You must provide a proper value to the -Q option." 'screen'
				exit 1
			   }
			   QUIET="$OPTARG" ;;
# REMOVED 2025/12/01
#			r) ( echo ${OPTARG:0:1} | grep -q ^[0-9] ) || {
## UPDATED 2025/10/26
##				[ "$SILENT" ] || echo "ERROR: you must supply a restore date to the -r action." | tee -a "$LOG_ERRS"
#				showMsg 'failure' "You must provide a restore date to the -r action." 'screen'
#				exit 1
#			   }
#			   REPO_SOURCE="$REPO_RESTOR"				# set the source location to the restore points directory
#			   RESTORE="$OPTARG" ;;
# UPDATED 2025/11/24 - RESTORE is used for the action; plus this is now an opt-out
#			R) RESTORE=TRUE ;;
# UPDATED 2025/12/01
#			R) NORESTORE=TRUE ;;
			R) RESTORE=TRUE ;;
# UPDATED 2025/11/03
#			S) if ( echo $OPTARG | grep -q ^'http' ) || ( echo $OPTARG | grep -q ^'ftp' ) || ( echo $OPTARG | grep -q ^'/' ) || ( echo $OPTARG | grep -q ^'./' ); then
# UPDATED 2025/12/05
#			S) ( echo "${OPTARG}" | grep -qE ^'(http|ftp|/|./)' ) || {
			S) ( echo "${OPTARG}" | grep -qE '(^(http|ftp|/|./)|(/)$)' ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a directory or http/ftp URI to the -S option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a directory or http/ftp URI to the -S option." 'screen'
				exit 1
#			   fi
			   }
			   ( echo "$OPTARG" | grep -q '/'$ ) && OPTARG="${OPTARG%/*}"	#   if the user included a trailing '/' on the passed directory, then remove it
			   ( echo "$OPTARG" | grep -q ^'./' ) && OPTARG="$(pwd)${OPTARG#*.}"  # if a relative directory was passed, adjust the value to be the whole path
			   ( echo "$OPTARG" | grep -q ^'/' ) || OPTARG="$(pwd)/${OPTARG}" 
			   REPO_SOURCE="$OPTARG" ;;
# UPDATED 2025/10/26
#			t) echo "Dependency trees for package(s)..."
# UPDATED 2025/10/30
#			t) showMsg 'action' "Dependency trees for package(s)..." 'screen' 0 0 0 1
			t) 
# UPDATED 2025/11/06
#			   TREE=TRUE ;;
if [ 1 -eq 0 ]; then
showMsg 'action' "Dependency trees for package(s)..." 'screen' 1 1
			   # if we are looking for specific packages passed on the command line, then...
			   shift $(expr $OPTIND - 1)							# now that the OPTIONS have been processed, lets process the package name(s)
			   eval TEMP=\${$#}								# store the current last passed value to later check if a directory was passed as the last value	http://stackoverflow.com/questions/1853946/getting-the-last-argument-passed-to-a-shell-script

			   cd "${DIR_LIST}" >/dev/null
			   if [ "$TEMP" = "$0" ]; then							# if a blank or null value was given for the package name (since the 'shift' command will go back to $0), then...
				for PARAMETER in $(ls -1 *.${EXT_SOFT}); do				#   cycle each package to see what other packages depend on it
					splitName "$PARAMETER"
					TEMP="$BASENAME"
					showMsg 'package' "${PACKAGE} (${FILETYPE})" 'screen' 1 4
					for FILE in $(grep -lE ^"(${PACKAGE}|${FILENAME})" *.${EXT_DEPS}); do
						splitName "$FILE" "$EXT_DEPS"
						[ "$TEMP" = "$BASENAME" ] && continue
						showMsg 'dependency' "   (${FILETYPE}) ${PACKAGE}" 'screen' 1 4
					done
				done
			   else										# otherwise package(s) were passed, so...
				for PARAMETER in $@; do							#   cycle through each name passed
					[ -d "$PARAMETER" ] && {
						showMsg 'failure' "The DIRECTORY value can not be used with the -t action." 'screen'
						exit 1
					}
					splitName "$PARAMETER"
					showMsg 'package' "${PACKAGE} (${FILETYPE})" 'screen' 1 4
					for FILE in $(grep -lE ^"(${PACKAGE}|${FILENAME})" *.${EXT_DEPS}); do
						splitName "$FILE" "$EXT_DEPS"
						showMsg 'dependency' "   (${FILETYPE}) ${PACKAGE}" 'screen' 1 4
					done
				done
			   fi
			   ( [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ] ) && showMsg 'success' "" 'screen' 1 6
			   exit 0 #;;
fi
# UPDATED 2025/12/04
#			   TREE=TRUE ;;
			   ( echo "${OPTARG}" | grep -qE ^'(relies|reliant)' ) || {
				showMsg 'failure' "You must provide a proper value to the -t action." 'screen'
				exit 1
			   }
# REMOVED 2025/12/05 - this was causing -S and DIRECTORY conflicts
#			   [ ! "$REPO_SOURCE" ] && REPO_SOURCE="$REPO_OPTION"				# NOTE: this MUST come here so that the "no packages were passed" is triggered below; this also preserves any passed -S value
			   TREE="$OPTARG" ;;
# UPDATED 2025/11/03
#			T) if [ "$OPTARG" != 'bin' ] && [ "$OPTARG" != 'dev' ] && [ "$OPTARG" != 'doc' ] && [ "$OPTARG" != 'drv' ] && [ "$OPTARG" != 'gir' ] && [ "$OPTARG" != 'lib' ] && [ "$OPTARG" != 'loc' ]; then
			T) ( echo "${OPTARG}" | grep -qE ^'(bin|dev|doc|drv|gir|lib|loc)' ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: the specified value to the -T option is invalid." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a proper value to the -T option." 'screen'
				exit 1
#			   fi
			   }
			   TYPE="$OPTARG" ;;
# UPDATED 2025/10/23 - merged with -U
#			u) UNLOAD=TRUE ;;
# UPDATED 2025/11/03
#			u) if [ "$OPTARG" != 'unload' ] && [ "$OPTARG" != 'delete' ] && [ "$OPTARG" != 'purge' ]; then
			u) ( echo "${OPTARG}" | grep -qE ^'(unload|delete|purge)' ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: the specified value to the -u action is invalid." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a proper value to the -u action." 'screen'
				exit 1
#			   fi
			   }
# REMOVED 2025/11/13 - this was merged with UNLOAD
#			   UNLOAD=TRUE
#			   [ "$OPTARG" != 'unload' ] && PURGE="$OPTARG" ;;		# specify the purge type if we're not just unloading the software
			   UNLOAD="$OPTARG" ;;
# UPDATED 2025/10/23 - merged with -u
#			U) if [ "$OPTARG" != 'app' ] && [ "$OPTARG" != 'all' ]; then
#				[ "$SILENT" ] || echo "ERROR: the specified value to the -U switch is invalid." | tee -a "$LOG_ERRS"
#				exit 1
#			   fi
#			   PURGE="$OPTARG" ;;
# UPDATED 2025/10/22
#			   PURGE=1 ;;
# UPDATED 2025/12/09
#			v) if [ "$OPTARG" != 'data' ] && [ "$OPTARG" != 'deps' ]; then
			v) ( echo "${OPTARG}" | grep -qE ^'(data|deps|fix|hash)' ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a proper mode type to the -v action." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a proper value to the -v action." 'screen'
				exit 1
			   }
			   VALIDATE="$OPTARG" ;;
			V) ( echo "${OPTARG:0:1}" | grep -q ^[0-9] ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a version number to the -V option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a version number to the -V option." 'screen'
				exit 1
			   }
			   VERSION="$OPTARG" ;;
# MERGED 2025/11/26 - this is now -D all
#			W) ALL=TRUE ;;
			X) 
( echo "${OPTARG}" | grep -q ^'/' ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a device mount point to the -X option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a device mount point to the -X option." 'screen'
				exit 1
			   }
			   proxyAction
			   PROXY="$OPTARG" ;;
			Y) DRYRUN=TRUE ;;
# DEV NOTE: -z must be called for any non-consecutive package manager call to make sure the files represent an up-to-date system (e.g. if pax is used to install something, then tce-load is, the catalog list with become out-of-sync and pax could malfunction)
			z) # remove anything existing that would force prompting for overwritting (e.g. alias cp='cp -i')
			   unalias cp >/dev/null 2>&1
			   unalias ln >/dev/null 2>&1

			   # remove any existing of these files (in case the original package manager was used between runs)
			   showMsg 'action' "Clearing any prior -z action contents:" 'screen' 0 3
			   [ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/"*.${EXT_SOFT}
			   [ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/"*.${EXT_HASH}
			   [ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/"*.${EXT_DEPS}
			   showMsg 'action' " [done]" 'screen' 1 5

			   # (re-)sync the package contents
			   showMsg 'action' "Sync'ing necessary package files:" 'screen' 0 3
			   for BASENAME in $(ls -1 "$DIR_LIST"); do
				[ ! "$DRYRUN" ] && ( ln -sf "${BASENAME}" "${DIR_LIST}/${BASENAME}.${EXT_SOFT}" 2>>"$LOG_ERRS" || exit 1 )
				[ ! "$DRYRUN" ] && [ -e "${REPO_OPTION}/${BASENAME}.${EXT_HASH}" ] && ln -sf "${REPO_OPTION}/${BASENAME}.${EXT_HASH}" "${DIR_LIST}/${BASENAME}.${EXT_HASH}" 2>>"$LOG_ERRS"
				[ ! "$DRYRUN" ] && [ -e "${REPO_OPTION}/${BASENAME}.${EXT_DEPS}" ] && ln -sf "${REPO_OPTION}/${BASENAME}.${EXT_DEPS}" "${DIR_LIST}/${BASENAME}.${EXT_DEPS}" 2>>"$LOG_ERRS"
			   done
			   showMsg 'action' " [done]" 'screen' 1 5
			   exit 0 ;;
			*) exit 1 ;;								# NOTE: since 'getopts' presents it own error, we don't need to do so here
		esac
	done

	EXE_CMD="${0##*/} $@"									# store the executed command for logging below

	# PROCESS THE 'DIRECTORY' PARAMETER
# REMOVED 2025/11/03 - this is no longer needed as we expanded FIND to use the DIRECTORY parameter
#if [ "$FIND" ]; then										# if we are trying to find a file in a package, then...
#	shift $(expr $OPTIND - 2)								#   remove the script name ($0) and the action (-f) and store all the filenames passed
#	eval TEMP=\${$#}
#
#elif [ ! "$FIND" ]; then									# we're not finding a file (since none of these checks are relevent for that action), then...
	shift $(expr $OPTIND - 1)								# now that the ACTIONS and OPTIONS have been processed, lets process the package name(s)
	eval TEMP=\${$#}									# store the current last passed value to later check if a directory was passed as the last value	http://stackoverflow.com/questions/1853946/getting-the-last-argument-passed-to-a-shell-script

	# WARNING: this MUST come before the directory processing!!!
# UPDATED 2025/11/20
#	if [ "$TEMP" = "$0" ]; then								# if a blank or null value was given for the package name (since the 'shift' command will go back to $0), then...
# UPDATED 2025/11/25 - so that DIRECTORY can be used as a target destination (copy, download, extract, make, validate) or a prefix (install, unload); LIST, OPEN, TREE do not accept packages
#	if [ "$TEMP" = "$0" ] && [ ! "$LIST" ] && [ ! "$OPEN" ] && [ ! "$TREE" ]; then						# if a blank or null value was given for the package name (since the 'shift' command will go back to $0) -AND- we're not listing installed packages, then...
## UPDATED 2025/10/26
##		echo "ERROR: you must provide a file or package name before processing can begin." | tee -a "$LOG_ERRS";
#		showMsg 'failure' "You must provide a file or package name before processing can begin." 'screen'
#		exit 1
#	elif [ -f "$1" ] && [ ! "$(echo $1 | grep -e ${EXT_SOFT}$)" ]; then			# check if the PACKAGE(S) value was actually passed as a text file -AND- is NOT a package name (ending with the EXT_SOFT extension)	NOTE: can't check for mime type since busybox doesn't have a 'file' applet
#		[ "$1" = "$TEMP" ] && TEMP=''							#   if the PACKAGE(S) value is the last passed value (and not a DIRECTORY), then erase the TEMP value to avoid directory processing below
#		TEMPLIST="$(cat "$1" | tr '\n' ' ')"						#   store all the packages to load within the text file list
#		[ "$TEMPLIST" = '' ] && exit 0							#   if there are NOT any packages listed in the text file, there's nothing to process so exit
#		set -- $TEMPLIST								#   otherwise reset the $1, $2, $3, etc values (and $@ that is used in the main 'for' loop below) to be the package names in the text file (as if they were passed via the command line)
#		unset TEMPLIST									#   erase this variable since it's no longer used
#	fi

# REMOVED 2025/11/03 - this is handled below now
#	if [ "$MAKE" ] && ( ( echo "$1" | grep -q ^'/' ) || ( echo "$1" | grep -q ^'./' ) ); then
## UPDATED 2025/10/26
##		[ "$SILENT" ] || echo "ERROR: you must supply a package name with the -m action." | tee -a "$LOG_ERRS"
#		showMsg 'failure' "You must provide a package name with the -m action."
#		exit 1
#	fi

# UPDATED 2025/11/20
#	if [ ! -d "$TEMP" ] && ( echo "$TEMP" | grep -q '/' ); then				# if a DIRECTORY was actually passed (via the presence of '/' characters), but doesn't exist then...
# UPDATED 2025/11/26
#	if [ ! -d "$TEMP" ] && ( echo "$TEMP" | grep -q '/' ) && [ ! "$LIST" ] && [ ! "$OPEN" ] && [ ! "$TREE" ]; then				# if a DIRECTORY was actually passed (via the presence of '/' characters) -AND- we're not listing installed packages, but doesn't exist then...
##echo oops
## UPDATED 2025/10/26
##		[ "$SILENT" ] || echo "ERROR: the passed file or directory does not exist (${TEMP})." | tee -a "$LOG_ERRS"	#   NOTE: this is shown to the screen and logged on purpose!
#		showMsg 'failure' "The passed directory does not exist (${TEMP})." 'screen'
#		exit 1
#	elif [ -d "$TEMP" ] && ( echo "$TEMP" | grep -q '/' ); then				# otherwise it does exist, so...	# NOTE: the second test is incase there is a directory and file with the same name (e.g. foo/ and foo.bin.i64.soft; without the '/' in the parameter value, we'd be referring to the package)
# UPDATED 2025/12/03
#if [ ! "$OPEN" ] && [ ! "$LIST" ]; then
#	if [ "$TEMP" = "$0" ]; then								# if no PACKAGE(S), FILELIST, or DIRECTORY was passed, then...
	if [ "$TEMP" = "$0" ] && [ ! "$OPEN" ] && [ ! "$LIST" ] && [ ! "$TREE" ]; then								# if no PACKAGE(S), FILELIST, or DIRECTORY was passed, then...
		showMsg 'failure' "The script must have a PACKAGE(S), FILELIST, and/or DIRECTORY value." 'screen'
		exit 1
	elif [ "$TEMP" != "$0" ] && ( echo "$TEMP" | grep -q '/' ) && [ ! -f "$1" ]; then			# if a DIRECTORY was passed, then...	  NOTE: the first check is specifically for OPEN and LIST (since they don't require a PACKAGE(S) or DIRECTORY value), and should NOT effect the other actions
#echo "@ |$@|"
		if [ ! -d "$TEMP" ]; then							#   if it does NOT exist, then...
			showMsg 'failure' "The passed directory does not exist (${TEMP})." 'screen'
			exit 1
		fi
#echo "1 TEMP |$1|$TEMP|"
# REMOVED 2025/11/26 - this should be processed if NO directory was passed, and take all the packages from REPO_SOURCE
#		if [ "$1" = "$TEMP" ] && [ ! "$MAKE" ] && [ ! "$OPEN" ]; then							# if the DIRECTORY is the PACKAGE(S) value, then a directory needs to be processed as the 'list'...
#echo top
#			TEMPLIST="$(ls -1 "${1}/"*.${EXT_SOFT} 2>/dev/null | tr '\n' ' ')"	#   store all the .soft packages to load within the directory
	# MOVED 2025/11/25 - below everything as a last command to reset the $1, $2, $3, ...
	#		[ "$TEMPLIST" = '' ] && exit 0						#   if there are NOT any packages in the directory, there's nothing to process so exit
	#		set -- $TEMPLIST							#   otherwise reset the $1, $2, $3, etc values (and $@ that is used in the main 'for' loop below) to be the package names in the directory (as if they were passed via the command line)
# REMOVED 2025/11/03 - no need to perform these checks and fixed a value storage bug
#			if [ "$TEMP" != "$REPO_OPTION" ] && [ "$TEMP" != "$REPO_SYSTEM" ]; then	#   if neither of the two defaults repo locations were passed (e.g. not booting) as the location, then...
	# REMOVED 2025/11/25 - this variable should ONLY be set via -S
	#			REPO_SOURCE="$TEMP"						#   automatically update this value since it is the source location where the desired files are stored
#				[ "$(echo $REPO_SOURCE|tail -c 2)" = '/' ] && TEMP="$(echo $REPO_SOURCE|head -c -2)"		# if the user included a trailing '/' on the passed directory, then remove it to prevent parsing below
#			fi
	#		( echo "$REPO_SOURCE" | grep -q '/'$ ) && REPO_SOURCE="$(echo "$REPO_SOURCE"|head -c -2)"		# if the user included a trailing '/' on the passed directory, then remove it to prevent parsing below
# REMOVED 2025/10/23 - unsure what this is being used for; it causes problems with -m
# RESTORED 2025/11/03 - we are now using DIRECTORY
# REMOVED 2025/11/26 - this should be processed if NO directory was passed, and take all the packages from REPO_SOURCE
#		else										# otherwise a passed value for DIRECTORY was given (along with PACKAGE(S)), so...
#echo btm
#echo 'directory was passed'
			DIRECTORY="$TEMP"							#   store the DIRECTORY value

			TEMP=''
			for PARAMETER in ${@}; do						#   process each remaining parameter (after the OPTIONS and ACTION have been removed)
				[ "$PARAMETER" = "$DIRECTORY" ] && break			#   if we have reached the DIRECTORY value, break out of the 'for' loop to NOT include it
				TEMP="$TEMP $PARAMETER"						#   append each parameter to the list
			done
# REMOVED 2025/11/25 - we use this throughout the script instead of RAWFILE
#			unset PARAMETER
			set -- $TEMP								#   now reset the $@ array (e.g. $1, $2, $3, etc) with the adjusted parameters list

			( echo "$DIRECTORY" | grep -q '/'$ ) && DIRECTORY="${DIRECTORY%/*}"	#   if the user included a trailing '/' on the passed directory, then remove it
			( echo "$DIRECTORY" | grep -q ^'./' ) && DIRECTORY="$(pwd)${DIRECTORY#*.}"  # if a relative directory was passed, adjust the value to be the whole path
			( echo "$DIRECTORY" | grep -q ^'/' ) || DIRECTORY="$(pwd)/${DIRECTORY}" 

# UPDATED 2025/11/03 - we are now using DIRECTORY
#			REPO_TARGET="$TEMP"							#   update the target value since that is where the user wants the packages stored
#			[ "$(echo $REPO_TARGET|tail -c 2)" = '/' ] && TEMP="$(echo $REPO_TARGET|head -c -2)"
#		fi
# MOVED 2025/11/25 - moved at the end
#		unset TEMPLIST

# REMOVED 2025/10/23 - this appears to NOT be used (probably was for previous -m implementation since it stores the last part of the passed directory)		 do we need to store the value in TEMP, since it gets immediately erased afterwards?
#		TEMP="${TEMP##*/}"								# remove everything but the last directory to rename
	fi
# UPDATED 2025/12/03
#fi
#[ "$LIST" ] && ( echo "$TEMP" | grep -q '/' ) && [ -d "$TEMP" ] && DIRECTORY="$TEMP"				# if a DIRECTORY was passed, set the value so an error will be triggered below
#[ "$OPEN" ] && ( echo "$TEMP" | grep -q '/' ) && [ -d "$TEMP" ] && DIRECTORY="$TEMP"				# if a DIRECTORY was passed, set the value so an error will be triggered below
# WARNING: this MUST be two different 'if' statements so both can execute!!!
#if [ ! "$OPEN" ]; then
	if [ -f "$1" ] && ( ! grep -q '\0' "$1" ); then						# if the parameter is a file -AND- not a binary file, then it's a FILELIST, so...	NOTE: can't check for mime type since busybox doesn't have a 'file' applet	https://stackoverflow.com/questions/567757/how-do-i-distinguish-between-binary-and-text-files
#echo 'filelist was passed'
		TEMP="$(cat "$1" | tr '\n' ' ')"						#   store all the packages to load within the FILELIST
		[ ! "$TEMP" ] && exit 0								#   if there are NOT any packages in the directory, there's nothing to process so exit
		set -- $TEMP									#   now reset the $@ array (e.g. $1, $2, $3, etc) with the files in the FILELIST
# UPDATED 2025/12/03 - adjusted so LIST doesn't trigger the below statement
#	elif [ ! "$1" ] && ( ! echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ); then		# otherwise only a DIRECTORY was passed, so we need to process all packages in REPO_SOURCE	NOTE: we can't do this for -d since the REPO_SOURCE will be remote
# UPDATED 2025/12/05
#	elif [ ! "$1" ] && [ "$REPO_SOURCE" ] && ( ! echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) && [ ! "$OPEN" ]; then		# otherwise only a DIRECTORY was passed, so we need to process all packages in REPO_SOURCE	NOTE: we can't [ -d ] since the REPO_SOURCE will be remote
#		TEMP="$(cd "${REPO_SOURCE}" && ls -1 *.${EXT_SOFT} 2>/dev/null | tr '\n' ' ')"	#   store all the .soft packages to load within the directory
	elif [ ! "$1" ] && [ ! "$OPEN" ] && ( [ "$TREE" ] || ( [ "$REPO_SOURCE" ] && ( ! echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) ) ); then		# otherwise only a DIRECTORY was passed, so we need to process all packages in REPO_SOURCE	NOTE: we can't [ -d ] since the REPO_SOURCE will be remote
#echo "no packages were passed |$REPO_SOURCE|"
		[ "$TREE" ] && [ ! "$REPO_SOURCE" ] && cd "$REPO_OPTION"				# NOTE: this MUST be handled in this manner so that the -S and DIRECTORY checking doesn't get triggered
		[ "$REPO_SOURCE" ] && ( ! echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) && cd "${REPO_SOURCE}"
		TEMP="$(ls -1 *.${EXT_SOFT} 2>/dev/null | tr '\n' ' ')"	#   store all the .soft packages to load within the directory
		[ ! "$TEMP" ] && exit 0						#   if there are NOT any packages in the directory, there's nothing to process so exit
		set -- $TEMP							#   otherwise reset the $1, $2, $3, etc values (and $@ that is used in the main 'for' loop below) to be the package names in the directory (as if they were passed via the command line)
	fi
#fi
	TEMP=''											# make sure this value is not contaminating anything
#echo "@ DIR |$@|$DIRECTORY|"
fi




# MANDATORY CHECKS BEFORE **ANY** PROCESSING

# general checking			NOTE: we can't write to a log yet since those checks haven't occurred
( ls -1 "${DIR_LIST}" | grep -q "${EXT_HASH}"$ ) || { showMsg 'failure' "pax does not appear to be the default package manager.\nNOTES: Run 'pax --install' to make it the default package manager, or\n       run 'pax -z' to populate the system.\n       'pax -z' will be required after each non-consecutive action by a\n       package manager. Making pax the default will remove this step." 'screen'; exit 1; }
[ "$VERSION" ] && [ "$2" ] && { showMsg 'failure' "Only one package can be listed with the -V option." 'screen'; exit 1; }

# action checking
TEMP=0
[ "$COPY" ] && TEMP=$(( TEMP + 1 ))
[ "$DOWNLOAD" ] && TEMP=$(( TEMP + 1 ))
[ "$EXTRACT" ] && TEMP=$(( TEMP + 1 ))
[ "$FIND" ] && TEMP=$(( TEMP + 1 ))
[ "$INSTALL" ] && TEMP=$(( TEMP + 1 ))
[ "$LIST" ] && TEMP=$(( TEMP + 1 ))
[ "$MAKE" ] && TEMP=$(( TEMP + 1 ))
[ "$OPEN" ] && TEMP=$(( TEMP + 1 ))
# REMOVED 2025/12/01
#[ "$RESTORE" ] && TEMP=$(( TEMP + 1 ))
[ "$TREE" ] && TEMP=$(( TEMP + 1 ))
[ "$UNLOAD" ] && TEMP=$(( TEMP + 1 ))
[ "$VALIDATE" ] && TEMP=$(( TEMP + 1 ))
[ $TEMP -gt 1 ] && { showMsg 'failure' "Include only one ACTION when executing this script." 'screen'; exit 1; }
# UPDATED 2025/11/20
#[ ! "$COPY" ] && [ ! "$DOWNLOAD" ] && [ ! "$EXTRACT" ] && [ ! "$FIND" ] && [ ! "$INSTALL" ] && [ ! "$MAKE" ] && [ ! "$RESTORE" ] && [ ! "$TREE" ] && [ ! "$UNLOAD" ] && [ ! "$VALIDATE" ] && { showMsg 'failure' "You must provide an ACTION when executing this script." 'screen'; exit 1; }
# REMOVED 2025/12/01
#[ ! "$COPY" ] && [ ! "$DOWNLOAD" ] && [ ! "$EXTRACT" ] && [ ! "$FIND" ] && [ ! "$INSTALL" ] && [ ! "$LIST" ] && [ ! "$MAKE" ] && [ ! "$OPEN" ] && [ ! "$RESTORE" ] && [ ! "$TREE" ] && [ ! "$UNLOAD" ] && [ ! "$VALIDATE" ] && { showMsg 'failure' "You must provide an ACTION when executing this script." 'screen'; exit 1; }
[ ! "$COPY" ] && [ ! "$DOWNLOAD" ] && [ ! "$EXTRACT" ] && [ ! "$FIND" ] && [ ! "$INSTALL" ] && [ ! "$LIST" ] && [ ! "$MAKE" ] && [ ! "$OPEN" ] && [ ! "$TREE" ] && [ ! "$UNLOAD" ] && [ ! "$VALIDATE" ] && { showMsg 'failure' "You must provide an ACTION when executing this script." 'screen'; exit 1; }
[ "$DOWNLOAD" ] && [ ! "$1" ] && { showMsg 'failure' "You must provide at least one package before processing can begin." 'screen'; exit 1; }
[ "$DOWNLOAD" ] && [ "$REPO_SOURCE" ] && ( ! echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) && { showMsg 'failure' "You must provide a remote source with the -d action." 'screen'; exit 1; }
[ "$FIND" ] && [ "$REPO_SOURCE" ] && [ "$DIRECTORY" ] && { showMsg 'failure' "You must provide only the -S or DIRECTORY value with the -f action." 'screen'; exit 1; }
[ "$LIST" ] && [ "$DIRECTORY" ] && { showMsg 'failure' "This action can't be used with the DIRECTORY value." 'screen'; exit 1; }
[ "$MAKE" ] && [ "$DIRECTORY" ] && [ "$REPO_SOURCE" ] && { showMsg 'failure' "You must provide only the -S or DIRECTORY value with the -m action." 'screen'; exit 1; }
[ "$MAKE" ] && [ ! "$DIRECTORY" ] && [ ! "$REPO_SOURCE" ] && { showMsg 'failure' "You must provide either the -S or DIRECTORY value with the -m action." 'screen'; exit 1; }
[ "$MAKE" ] && ( [ ! "$1" ] || ( echo "$1" | grep -q '/' ) ) && { showMsg 'failure' "You must provide a package name before processing can begin." 'screen'; exit 1; }
[ "$MAKE" ] && [ "$2" ] && { showMsg 'failure' "Only one package can be processed per call of the -m action." 'screen'; exit 1; }
[ "$OPEN" ] && [ "$DIRECTORY" ] && [ "$REPO_SOURCE" ] && { showMsg 'failure' "You must provide only the -S or DIRECTORY value with the -o action." 'screen'; exit 1; }
[ "$OPEN" ] && [ "$2" ] && [ "$2" != 'clear' ] && { showMsg 'failure' "Only one fifo can be managed per call of the -o action." 'screen'; exit 1; }
[ "$TREE" ] && [ "$DIRECTORY" ] && [ "$REPO_SOURCE" ] && { showMsg 'failure' "You must provide only the -S or DIRECTORY value with the -t action." 'screen'; exit 1; }

# option checking
[ "$BOOTING" ] && [ ! "$INSTALL" ] && { showMsg 'failure' "This action can't be used with the -B option." 'screen'; exit 1; }
[ "$ARCH" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$OPEN" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -C option." 'screen'; exit 1; }
# REMOVED 2025/11/26 - this is now the DIRECTORY value
#[ "$PREFIX" ] && [ ! "$INSTALL" ] && [ ! "$UNLOAD" ] && { showMsg 'failure' "This action can't be used with the -D option." 'screen'; exit 1; }
[ "$DEPS" != 'default' ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] ) && { showMsg 'failure' "This action can't be used with the -D option." 'screen'; exit 1; }
[ "$DEPS" = 'none' ] && [ "$TREE" ] && { showMsg 'failure' "This action can't be used with the '-D none' option." 'screen'; exit 1; }
[ "$EXTRA" ] && [ ! "$COPY" ] && [ ! "$DOWNLOAD" ] && [ ! "$INSTALL" ] && [ ! "$UNLOAD" ] && { showMsg 'failure' "This action can't be used with the -E option." 'screen'; exit 1; }
[ "$FORCE" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -F option." 'screen'; exit 1; }
[ "$IGNORE" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -I option." 'screen'; exit 1; }
# UPDATED 2025/12/01
#[ "$KERNEL" != "$KRNL_SCHEMA" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -K option." 'screen'; exit 1; }
[ "$KERNEL" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -K option." 'screen'; exit 1; }
# UPDATED 2025/12/01
#[ "$NOLIST" ] && [ ! "$INSTALL" ] && { showMsg 'failure' "This action can't be used with the -L option." 'screen'; exit 1; }
[ "$PACKLIST" ] && [ ! "$INSTALL" ] && [ "$UNLOAD" != 'delete' ] && [ "$UNLOAD" != 'purge' ] && { showMsg 'failure' "This action can't be used with the -L option." 'screen'; exit 1; }
# UPDATED 2025/12/01
#[ "$MODE" = 'link' ] && [ ! "$INSTALL" ] && { showMsg 'failure' "This action can't be used with the -M option." 'screen'; exit 1; }
[ "$MODE" ] && [ ! "$INSTALL" ] && { showMsg 'failure' "This action can't be used with the -M option." 'screen'; exit 1; }
[ "$FILELIST" ] && [ ! "$INSTALL" ] && { showMsg 'failure' "This action can't be used with the -N option." 'screen'; exit 1; }
[ "$OUTPUT" = 'xml' ] && [ "$OPEN" ] && { showMsg 'failure' "This action can't be used with the '-O xml' option." 'screen'; exit 1; }		# NOTE: we can't use this since it requires a final success/failure before any output is shown
[ "$PROMPT" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -P option." 'screen'; exit 1; }
[ "$QUIET" = 'all' ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$TREE" ] ) && { echo "This action can't be used with the '-Q all' option."; exit 1; }		# NOTE: this has to be an 'echo' statement because showMsg() won't show it otherwise!
[ "$QUIET" = 'errors' ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the '-Q errors' option." 'screen'; exit 1; }
# UPDATED 2025/12/01
#[ "$NORESTORE" ] && [ ! "$UNLOAD" ] && { showMsg 'failure' "This action can't be used with the -R option." 'screen'; exit 1; }
[ "$RESTORE" ] && [ ! "$INSTALL" ] && [ ! "$LIST" ] && [ ! "$UNLOAD" ] && [ ! "$VALIDATE" ] && { showMsg 'failure' "This action can't be used with the -R option." 'screen'; exit 1; }
[ "$REPO_SOURCE" ] && [ "$LIST" ] && { showMsg 'failure' "This action can't be used with the -S option." 'screen'; exit 1; }
[ "$TYPE" != 'bin' ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] ) && { showMsg 'failure' "This action can't be used with the -T option." 'screen'; exit 1; }
[ "$VERSION" ] && [ ! "$DOWNLOAD" ] && [ ! "$INSTALL" ] && [ ! "$UNLOAD" ] && [ ! "$VALIDATE" ] && { showMsg 'failure' "This action can't be used with the -V option." 'screen'; exit 1; }
# MERGED 2025/11/26 - this is now -D all
#[ "$ALL" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -W option." 'screen'; exit 1; }
[ "$PROXY" ] && [ ! "$COPY" ] && [ ! "$DOWNLOAD" ] && [ ! "$INSTALL" ] && { showMsg 'failure' "This action can't be used with the -X option." 'screen'; exit 1; }
[ "$DRYRUN" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -Y option." 'screen'; exit 1; }

# option combination checking
# UPDATED 2025/12/01
#[ "$ARCH" ] && [ "$NORESTORE" ] && { showMsg 'failure' "The -C option can't be used with the -R option." 'screen'; exit 1; }
[ "$ARCH" ] && [ "$RESTORE" ] && { showMsg 'failure' "The -C option can't be used with the -R option." 'screen'; exit 1; }
[ "$IGNORE" ] && [ "$FILELIST" ] && { showMsg 'failure' "The -I option can't be used with the -N option." 'screen'; exit 1; }
[ "$PROMPT" ] && [ "$QUIET" = 'all' ] && { echo "ERROR: The -P option can't be used with the '-Q all' option."; exit 1; }		# NOTE: this has to be an 'echo' statement because showMsg() won't show it otherwise!
[ "$PROMPT" ] && [ "$QUIET" = 'errors' ] && { showMsg 'failure' "The -P option can't be used with the '-Q errors' option." 'screen'; exit 1; }
[ "$PROMPT" ] && [ "$OUTPUT" = 'fifo' ] && [ ! -e "$FIFO_SERVER" ] && { showMsg 'failure' "The -P option can't be used with '-O fifo' without a FIFO_SERVER." 'screen'; exit 1; }
[ "$PROMPT" ] && [ "$OUTPUT" != 'fifo' ] && [ "$OUTPUT" != 'text' ] && [ ! -e "$FIFO_SERVER" ] && { showMsg 'failure' "The -P option can only be used with '-O fifo' or '-O text'." 'screen'; exit 1; }
# REMOVED 2025/11/25
#[ "$PROXY" ] && [ "$REPO_SOURCE" ] && { showMsg 'failure' "The -X option can't be used with the -S option." 'screen'; exit 1; }
[ "$PROXY" ] && [ "$DRYRUN" ] && { showMsg 'failure' "The -X option can't be used with the -Y option." 'screen'; exit 1; }
[ "$PROXY" ] && [ "$DIRECTORY" != '' ] && { showMsg 'failure' "The DIRECTORY value can not be used with the -X option." 'screen'; exit 1; }

# UPDATED 2025/10/22 - the -f action does NOT supply a package name
#[ ! "$1" ] && { [ "$SILENT" ] || echo "ERROR: you must provide a PACKAGE name." | tee -a "$LOG_ERRS"; exit 1; }
# UPDATED 2025/10/26
#[ ! "$1" ] && [ ! "$FIND" ] && { [ "$SILENT" ] || echo "ERROR: you must provide a PACKAGE name." | tee -a "$LOG_ERRS"; exit 1; }
#[ ! "$2" ] && [ "$MAKE" ] && { [ "$SILENT" ] || echo "ERROR: you must provide a directory to package." | tee -a "$LOG_ERRS"; exit 1; }
#[ ! "$COPY" ] && [ ! "$DOWNLOAD" ] && [ ! "$EXTRACT" ] && [ ! "$FIND" ] && [ ! "$INSTALL" ] && [ ! "$MAKE" ] && [ ! "$RESTORE" ] && [ ! "$TREE" ] && [ ! "$UNLOAD" ] && [ ! "$VALIDATE" ] && { [ "$SILENT" ] || echo "ERROR: you must provide an ACTION." | tee -a "$LOG_ERRS"; exit 1; }
#[ ! -d "$REPO_PREFIX" ] && [ "$MAKE" ] && { [ "$SILENT" ] || echo "ERROR: the directory storing the package contents does NOT exist." | tee -a "$LOG_ERRS"; exit 1; }
#[ ! -d "$REPO_PREFIX" ] && [ ! "$MAKE" ] && { [ "$SILENT" ] || echo "ERROR: the package storage root directory does NOT exist." | tee -a "$LOG_ERRS"; exit 1; }
#[ ! -d "$REPO_OPTION" ] && [ ! "$MAKE" ] && ( mkdir -p "$REPO_OPTION" || { [ "$SILENT" ] || echo "ERROR: the package storage directory could NOT be created." | tee -a "$LOG_ERRS"; exit 1; } )
#[ "$MAKE" ] && [ "$(echo $REPO_PREFIX | head -c 1)" != '/' ] && { [ "$SILENT" ] || echo "ERROR: you must include the full path (not relative) when creating a package." | tee -a "$LOG_ERRS"; exit 1; }
#[ "$RESTORE" ] && [ ! -e "${REPO_RESTOR}/${RESTORE}" ] && { [ "$SILENT" ] || echo "ERROR: the passed path is not a valid restore point." | tee -a "$LOG_ERRS"; exit 1; }
# REMOVED 2025/11/03 - this never gets triggered as the mandatory checks above catches this
#[ ! "$FIND" ] && [ ! "$1" ] && { showMsg 'failure' "You must provide a package name before processing can begin."; exit 1; }
# UPDATED 2025/11/03 - the above segment has been reworked and this needed to be adjusted
#[ "$MAKE" ] && [ ! "$2" ] && { showMsg 'failure' "You must provide a directory to package before processing can begin."; exit 1; }
# MOVED 2025/11/06 - moved below
# MOVED 2025/11/12 - this has to be moved below were the directory values are set
#[ "$MAKE" ] && [ "$DIRECTORY" = "$REPO_OPTION" ] && [ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && { showMsg 'failure' "You must provide a directory to package before processing can begin." 'screen'; exit 1; }
# REMOVED 2025/11/03 - this is no longer needed
#[ "$MAKE" ] && [ "$(echo "$REPO_PREFIX" | head -c 1)" != '/' ] && { showMsg 'failure' "The full, not relative, path must be included when creating a package."; exit 1; }
# MOVED 2025/11/06 - moved below
# MOVED 2025/11/12 - this has to be moved below were the directory values are set
#[ "$PROXY" ] && [ "$DIRECTORY" != "$REPO_OPTION" ] && { showMsg 'failure' "The DIRECTORY value is not used with this action." 'screen'; exit 1; }
# MOVED 2025/11/12 - this has to be moved below were the directory values are set
#[ "$RESTORE" ] && [ ! -e "${REPO_RESTOR}/${RESTORE}" ] && { showMsg 'failure' "The provided path does not contain any valid restore points." 'screen'; exit 1; }


# check the directories		NOTE: we can't write to a log yet since those checks are occurring
if [ ! -d "${DIR_LIST}" ]; then
# UPDATED 2025/10/27
#	mkdir -p "${DIR_LIST}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The init script directory (DIR_LIST) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
	mkdir -p "${DIR_LIST}" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The catalog directory (DIR_LIST) does not exist and could not be created." 'screen'; exit 1; }
fi
# UPDATED 2025/10/27
#touch "${DIR_LIST}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The init script directory (DIR_LIST) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
touch "${DIR_LIST}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The catalog directory (DIR_LIST) is not writable." 'screen'; exit 1; }
rm "${DIR_LIST}/writable" >>"$LOG_ERRS" 2>&1

# REMOVED 2025/11/26 - this is now the DIRECTORY value
#if [ "$INSTALL" ] && [ "$PREFIX" = '' ] && [ "$DIRECTORY" = '' ]; then
if [ "$INSTALL" ] && [ "$DIRECTORY" = '' ]; then			# if we're installing -AND- the files need to be copied to the root (e.g. system package update)
	if [ ! -d "${DIR_INIT}" ]; then
# UPDATED 2025/10/27
#		mkdir -p "${DIR_INIT}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The init script directory (DIR_INIT) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
		mkdir -p "${DIR_INIT}" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The init script directory (DIR_INIT) does not exist and could not be created." 'screen'; exit 1; }
	fi
# UPDATED 2025/10/27
#	touch "${DIR_INIT}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The init script directory (DIR_INIT) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
	touch "${DIR_INIT}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The init script directory (DIR_INIT) is not writable." 'screen'; exit 1; }
	rm "${DIR_INIT}/writable" >>"$LOG_ERRS" 2>&1
fi

if [ ! -d "${DIR_INST}" ]; then
# UPDATED 2025/10/27
#	mkdir -p "${DIR_INST}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The installed cache directory (DIR_INST) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
	mkdir -p "${DIR_INST}" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The installed cache directory (DIR_INST) does not exist and could not be created." 'screen'; exit 1; }
fi
# UPDATED 2025/10/27
#touch "${DIR_INST}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The installed cache directory (DIR_INST) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
touch "${DIR_INST}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The installed cache directory (DIR_INST) is not writable." 'screen'; exit 1; }
rm "${DIR_INST}/writable" >>"$LOG_ERRS" 2>&1

if [ ! -d "${DIR_LOGS}" ]; then
# UPDATED 2025/10/27
#	mkdir -p "${DIR_LOGS}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The logs directory (DIR_LOGS) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
	mkdir -p "${DIR_LOGS}" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The logs directory (DIR_LOGS) does not exist and could not be created." 'screen'; exit 1; }
fi
# UPDATED 2025/10/27
#touch "${DIR_LOGS}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The logs directory (DIR_LOGS) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
touch "${DIR_LOGS}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The logs directory (DIR_LOGS) is not writable." 'screen'; exit 1; }
rm "${DIR_LOGS}/writable" >>"$LOG_ERRS" 2>&1

if [ ! -d "${DIR_LOOP}" ]; then
# UPDATED 2025/10/27
#	mkdir -p "${DIR_LOOP}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The mounting directory (DIR_LOOP) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
	mkdir -p "${DIR_LOOP}" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The mounting directory (DIR_LOOP) does not exist and could not be created." 'screen'; exit 1; }
fi
# UPDATED 2025/10/27
#touch "${DIR_LOOP}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The mounting directory (DIR_LOOP) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
touch "${DIR_LOOP}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The mounting directory (DIR_LOOP) is not writable." 'screen'; exit 1; }
rm "${DIR_LOOP}/writable" >>"$LOG_ERRS" 2>&1

if [ ! -d "${DIR_TEMP}" ]; then
# UPDATED 2025/10/27
#	mkdir -p "${DIR_TEMP}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The temp directory (DIR_TEMP) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
	mkdir -p "${DIR_TEMP}" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The temp directory (DIR_TEMP) does not exist and could not be created." 'screen'; exit 1; }
fi
# UPDATED 2025/10/27
#touch "${DIR_TEMP}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The temp directory (DIR_TEMP) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
touch "${DIR_TEMP}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The temp directory (DIR_TEMP) is not writable." 'screen'; exit 1; }
rm "${DIR_TEMP}/writable" >>"$LOG_ERRS" 2>&1

if [ ! -d "$REPO_PREFIX" ]; then
	mkdir -p "$REPO_PREFIX" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The package storage directory (REPO_PREFIX) could not be created." 'screen'; exit 1; }
fi
touch "${REPO_PREFIX}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The package storage directory (REPO_PREFIX) is not writable." 'screen'; exit 1; }
rm "${REPO_PREFIX}/writable" >>"$LOG_ERRS" 2>&1

if ( [ "$DOWNLOAD" ] || [ "$INSTALL" ] ) && [ ! -d "$REPO_OPTION" ]; then
	mkdir -p "$REPO_OPTION" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The optional package storage directory (REPO_OPTION) could not be created." 'screen'; exit 1; }
fi
touch "${REPO_OPTION}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The optional package storage directory (REPO_OPTION) is not writable." 'screen'; exit 1; }
rm "${REPO_OPTION}/writable" >>"$LOG_ERRS" 2>&1

# LEFT OFF - check the permissions on REPO_SYSTEM are root:root @ 770 (or root:advanced), but only if REPO_SYSTEM and REPO_OPTION are different locations (so that TC can work without root permissions)




showMsg 'start' "\n\n---------- [ Script Execution ] ----------" 'log'
showMsg 'start' "           $(date +'%Y-%m-%d  %H:%M:%S')\n" 'log'
showMsg 'start' "$EXE_CMD" 'log'




# SET DIRECTORY VALUES

[ "$DIRECTORY" = '' ] && DIRECTORY="$REPO_OPTION"						# set default values if none were specified in the passed parameters
[ "$REPO_SOURCE" = '' ] && REPO_SOURCE="$REPO_SCHEMA"

if [ "$COPY" ]; then										# if we are copying package(s), then...
	[ "$DIRECTORY" = "$REPO_OPTION" ] && DIRECTORY='./'					#   if no directory was passed, then set the current directory as the target location to extract
# REMOVED 2025/11/26 - this is now the default value
# REVERTED 2025/12/02
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since we can only copy from local packages
# LEFT OFF - convert this over to 'cd REPO_SOURCE'
	cd "$DIRECTORY" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'				#   now cd into the DIRECTORY where the packages are to be copied
elif [ "$DOWNLOAD" ]; then									# if we are downloading package(s), then...
	# NOTE: REPO_SOURCE can NOT be processed here because it has variables that need to be parsed each time it's called
#	eval REPO_SOURCE="${REPO_SCHEMA}"								#   eval REPO_SOURCE incase it has any variables in it
#echo "rs2 |$REPO_SOURCE|"
	cd "$DIRECTORY" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'				#   now cd into the DIRECTORY where the packages will be downloaded
elif [ "$EXTRACT" ]; then									# if we are extracting package(s) contents, then...
# UPDATED 2025/12/02 - swapped locations so we don't have to copy .deps files
#	[ "$DIRECTORY" = "$REPO_OPTION" ] && DIRECTORY='./'					#   if no directory was passed, then set the current directory as the target location to extract
## REMOVED 2025/11/26 - we have a new default value
##	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE='.'					#   if the REPO_SOURCE is still remote, then change it to the current directory (this allows for directories to be processed as package list)
#	cd "$DIRECTORY" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'				#   now cd into the DIRECTORY where the packages are
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the current directory (this allows for directories to be processed as package list)
	[ "$DIRECTORY" = "$REPO_OPTION" ] && DIRECTORY="$(pwd)"					#   if no directory was passed, then set the current directory as the target location to extract
#	( echo "$DIRECTORY" | grep -qE ^'(./|[^/])' ) && 
# MOVED 2025/12/05 - this was moved above so it takes place with the initial directory assignment
#	( echo "$DIRECTORY" | grep -q ^'./' ) && DIRECTORY="$(pwd)${DIRECTORY#*.}"
#	( echo "$DIRECTORY" | grep -q ^'/' ) || DIRECTORY="$(pwd)/${DIRECTORY}" 
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'				#   now cd into the DIRECTORY where the packages are
elif [ "$FIND" ]; then										# if we are finding file(s) in packages, then...
	[ "$DIRECTORY" != "$REPO_OPTION" ] && REPO_SOURCE="$DIRECTORY"				#   if a directory was passed, then set the REPO_SOURCE as that value (so it can be used with '-S' interchangably)
# REMOVED 2025/11/26 - this is now the default value
# REVERTED 2025/12/02
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since we can only search local packages
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the REPO_SOURCE where the packages are
elif [ "$INSTALL" ]; then									# if we are installing package(s), then...
	if [ "$BOOTING" ]; then									#   if we're booting the device, then...
		DIRECTORY='/'									#     set DIRECTORY to the filesystem root
		REPO_SOURCE="$REPO_SYSTEM"							#     set REPO_SOURCE to the 'FIRMWARE' packages location
	else											#   otherwise the system is live and can use parameters, so...
# REMOVED 2025/11/26 - this is now the DIRECTORY value
#		[ "$PREFIX" ] && DIRECTORY="${PREFIX}"						#     if the -D option was passed, add it to the directory structure
#		[ ! "$PREFIX" ] && [ "$DIRECTORY" = "$REPO_OPTION" ] && {			#     if the -D option was NOT passed, and the DIRECTORY was NOT passed, then set to the default installation location
		[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"		#     if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since this is were we need to store packages by default
		[ "$DIRECTORY" = "$REPO_OPTION" ] && {						#     if the DIRECTORY was NOT passed, then set to the default installation location
			( echo "$DIR_LIVE" | grep -qE '(/|\.)'$ ) || DIR_LIVE="${DIR_LIVE}/"	#        make sure the directory ends with a '/' or '.' (because the first '/' is stripped from the package files' path to allow for ~/.whatever)
			DIRECTORY="$DIR_LIVE"
		}
	fi
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the REPO_SOURCE where the packages are
# REMOVED 2025/11/24 - this uses DIR_LIVE in all its i/o
#elif [ "$LIST" ]; then										# if we are listing installed packages, then...
# this is handled in the script parameter processing section above
#	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since we can only search local packages
elif [ "$MAKE" ]; then										# if we are creating a package for distribution, then...
	[ "$DIRECTORY" != "$REPO_OPTION" ] && REPO_SOURCE="$DIRECTORY"				#   if a directory was passed, then set the REPO_SOURCE as that value (so it can be used with '-S' interchangably)
# REMOVED 2025/11/26 - this is now the default value
# REVERTED 2025/12/02
# UPDATED 2025/12/03 - changed to current directory, since REPO_OPTION makes no sense
#	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since we can only search local packages
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE='./'					#   if the REPO_SOURCE is still remote, then change it to the current directory
# REMOVED 2025/11/25
#	[ "$DIRECTORY" = "$REPO_OPTION" ] && {
#		showMsg 'failure' "You must provide a directory to package before processing can begin." 'screen'
#		exitGracefully 1 'screen'
#	}
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the REPO_SOURCE where the source code or compiled software is
elif [ "$OPEN" ]; then
# UPDATED 2025/12/04 
#	[ "$DIRECTORY" = "$REPO_OPTION" ] && DIRECTORY="$DIR_TEMP"				#   if a directory was appended to the list, then use that for the directory to work from
	[ "$DIRECTORY" != "$REPO_OPTION" ] && REPO_SOURCE="$DIRECTORY"				#   if a directory was appended to the list, then use that for the REPO_SOURCE
# REMOVED 2025/11/26 - we have a new default value
#	[ "$REPO_SOURCE" != "$REPO_OPTION" ] && DIRECTORY="$REPO_SOURCE"			#   if the -S option was passed, then use that for the directory to work from
# REVERTED 2025/12/02
# UPDATED 2025/12/04
#	[ "$REPO_SOURCE" != "$REPO_SCHEMA" ] && DIRECTORY="$REPO_SOURCE"			#   if the -S option was passed, then use that for the directory to work from
#	cd "$DIRECTORY" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'				#   now cd into the DIRECTORY where the fifo needs to be created
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$DIR_TEMP"				#   if the -S option was NOT passed, then use the default temp directory
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'				#   now cd into the REPO_SOURCE where the fifo needs to be created
#elif [ "$PROXY" ]; then										# if we are proxying an action, then...
	# this action can not use DIRECTORY, however REPO_SOURCE gets passed to the script
# REMOVED 2025/11/25
#	[ "$DIRECTORY" != "$REPO_OPTION" ] && {
#		showMsg 'failure' "The DIRECTORY value can not be used with this action." 'screen'
#		exitGracefully 1 'screen'
#	}
#elif [ "$RESTORE" ]; then									# if we are restoring a package from a restore point, then...
#	adjust the below once the directory values get set
#	[ ! -e "${REPO_RESTOR}/${RESTORE}" ] && { showMsg 'failure' "The provided path does not contain any valid restore points." 'screen'; exit 1; }
#		[ "$RESTORE" ] && cd "${REPO_RESTOR}/${RESTORE}"				# change into the restore points directory to get all the requested software and any of its dependencies
elif [ "$TREE" ]; then										# if we are showing the dependency tree, then...
# this is handled in the script parameter processing section above
	[ "$DIRECTORY" != "$REPO_OPTION" ] && REPO_SOURCE="$DIRECTORY"				#   if a directory was appended to the list, then use that for the REPO_SOURCE
# REMOVED 2025/11/26 - we have a new default value
# REVERTED 2025/12/02
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$DIR_LIST"				#   if the -S option was NOT passed, then use the DIR_LIST for the REPO_SOURCE
#	[ "$REPO_SOURCE" = "$REPO_OPTION" ] && REPO_SOURCE="$DIR_LIST"				#   if the -S option was NOT passed, then use the DIR_LIST for the REPO_SOURCE
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the DIRECTORY where the packages are located
elif [ "$UNLOAD" ]; then									# if we are unloading/uninstalling package(s), then...
# REMOVED 2025/11/26 - this is now the DIRECTORY value
#	[ "$PREFIX" ] && DIRECTORY="${PREFIX}"							#   if the -D option was passed, add it to the directory structure
#	[ ! "$PREFIX" ] && [ "$DIRECTORY" = "$REPO_OPTION" ] && {				#   if the -D option was NOT passed, and the DIRECTORY was NOT passed, then set to the default installation location
	[ "$DIRECTORY" = "$REPO_OPTION" ] && {							#   if the DIRECTORY was NOT passed, then set to the default installation location
		( echo "$DIR_LIVE" | grep -qE '(/|\.)'$ ) || DIR_LIVE="${DIR_LIVE}/"		#     make sure the directory ends with a '/' or '.'
		DIRECTORY="$DIR_LIVE"
	}
# REMOVED 2025/11/26 - this is now the default value
# REVERTED 2025/12/02
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since we can only unload local packages
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the REPO_SOURCE where the packages are
elif [ "$VALIDATE" ]; then									# if we are validating package(s) information, then...
# REMOVED 2025/11/26 - this is now the default value
# REVERTED 2025/12/02
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since we can only validate local packages
	eval REPO_SOURCE="${REPO_SOURCE}"							#   eval REPO_SOURCE incase it has any variables in it
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into REPO_SOURCE where the packages are located
fi




# PERFORM SOME ACTUAL WORK

# MOVED and UPDATED 2025/11/07
#if [ $DEBUG -eq 0 ]; then
#	echo -e "\n\n---------- [ Script Execution ] ----------" >>"$LOG_ERRS"
#	echo -e "           $(date +'%Y-%m-%d  %H:%M:%S')\n" >>"$LOG_ERRS"
#else
#	echo -e "\n\n---------- [ Script Execution ] ----------" | tee -a "$LOG_DBUG" >>"$LOG_ERRS"
#	echo -e "           $(date +'%Y-%m-%d  %H:%M:%S')\n" | tee -a "$LOG_DBUG" >>"$LOG_ERRS"
#fi

	eval LIST_BOOT="$LIST_BOOT"
	eval FLAG_BOOT="$FLAG_BOOT"
	eval LIST_LIVE="$LIST_LIVE"
	eval FLAG_LIVE="$FLAG_LIVE"
	[ ! "$ARCH" ] && eval ARCH="$ARCH_SCHEMA"
	[ ! "$KERNEL" ] && eval KERNEL="$KRNL_SCHEMA"
	[ ! "$PACKLIST" ] && PACKLIST=$LIST_LIVE

[ "$COPY" ] && [ "$DEPS" != 'none' ] && showMsg 'action' "Processing dependencies for the packages..." 'both' 1 4
[ "$DOWNLOAD" ] && showMsg 'action' "Processing dependencies for the packages..." 'both' 1 4
# MERGED 2025/11/26 - this is now -D none
#[ "$EXTRACT" ] && [ ! "$ONLY" ] && showMsg 'action' "Processing dependencies for the packages..." 'both' 1 4
[ "$EXTRACT" ] && [ "$DEPS" != 'none' ] && showMsg 'action' "Processing dependencies for the packages..." 'both' 1 4
#[ "$FIND" ]
[ "$INSTALL" ] && showMsg 'action' "Processing dependencies for the packages..." 'both' 1 4
#[ "$LIST" ]
#[ "$MAKE" ]
[ "$OPEN" ] && showMsg 'action' "Starting pax in client mode..." 'both' 1 1
[ "$PROXY" ] && showMsg 'action' "Generating package list..." 'both' 1 4
# REMOVED 2025/12/01
#[ "$RESTORE" ] && showMsg 'action' "Processing dependencies for the packages..." 'both' 1 4
[ "$TREE" ] && showMsg 'action' "Dependency trees for package(s)..." 'screen' 1 1
# MOVED 2025/11/13 - moved below in the passed packages section
#if [ "$UNLOAD" ]; then										# if we are unloading/uninstalling package(s), then...
## REMOVED 2025/11/04 - this serves no functional purpose
##	TEMP=$OPTIND										#   store the current OPTIND value to restore it in just a second
## UPDATED 2025/11/04 - replaced APP*
##	for APPFILE in $@; do touch ${DIR_LIST}/${APPFILE}.mark; done				#   mark all the files we want to unload
#	for FILE in $@; do touch ${DIR_LIST}/${FILE%.*}.${EXT_MARK}; done			#   mark all the files we want to unload
## REMOVED 2025/11/04 - this serves no functional purpose
##	OPTIND=$TEMP										#   restore the original value of OPTIND
#fi
[ "$UNLOAD" ] && showMsg 'action' "Building list for all packages to unload..." 'both' 1 4
[ "$VALIDATE" = 'data' ] && showMsg 'action' "Processing dependencies for the packages..." 'both' 1 4
[ "$VALIDATE" = 'deps' ] && showMsg 'action' "Validating dependencies for the packages..." 'both' 1 4


# PROCESS PASSED PACKAGES

TEMP=''
for RAWFILE in $@; do
# REMOVED 2025/11/04 - this is no longer necessary since the implementation of DIRECTORY
#	( [ "$RAWFILE" = "$REPO_OPTION" ] || [ "$RAWFILE" = "${REPO_OPTION}/" ] ) && continue	# if we've made it to a passed directory (with and without trailing '/'), then skip processing it

# TEMP 2025/11/05 - testing to see if we can have all the dependencies detected at once
	#INDEX=0											# reset these values each iteration
	#TOTAL=0
#echo 01
	splitName "$RAWFILE"									# NOTE: the RAWFILE value will be overwritten by the splitName() call
#continue
#	PACKAGE=$RAWFILE
#	eval FILENAME=${BASENAME}
#echo "|${RAWFILE}|${BASENAME}|"

# UPDATED 2025/10/22 - no longer using APP* variables
#	[ $DEBUG -gt 0 ] && echo -e "body:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:" >>"$LOG_DBUG"
	[ $DEBUG -gt 0 ] && echo -e "body (dependencies):\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${ARCH}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|" >>"$LOG_DBUG"
#echo 02
# UPDATED 2025/11/06 - this only needs to reference REPO_SOURCE
#	if [ ! "$DOWNLOAD" ] && [ ! "$FIND" ] && [ ! "$MAKE" ] && [ ! "$PROXY" ] && [ ! -e "${REPO_SYSTEM}/${FILENAME}" ] && [ ! -e "${REPO_OPTION}/${FILENAME}" ] && [ ! -e "${REPO_SOURCE}/${FILENAME}" ] && [ ! -e "./${FILENAME}" ]; then
	if [ ! "$DOWNLOAD" ] && [ ! "$FIND" ] && [ ! "$LIST" ] && [ ! "$MAKE" ] && [ ! "$OPEN" ] && [ ! "$PROXY" ] && [ ! -e "${REPO_SOURCE}/${FILENAME}" ]; then
# UPDATED 2025/10/30
#		showMsg 'msg|failure' "The '${FILENAME}' file does not exist."
		showMsg 'failure' "The '${FILENAME}' package does not exist." 'both'
#echo 02b
# UPDATED 2025/11/13
#		exitGracefully 1
# UPDATED 2025/11/13 - several actions don't need the '[failure]' message shown
#		exitGracefully 4 'both' 5 'action'
		exitGracefully 1 'both' 5 'action'
	fi
#echo 03
# showMsg TAG MESSAGE [TARGET] [CR] [TAGS] [TRIM]

	#if [ "$COPY" ]; then									# if we are copying package(s), then...
		# this executes the processDependencies() call below
	#elif [ "$DOWNLOAD" ]; then								# if we are downloading package(s), then...
		# this executes the processDependencies() call below
	#elif [ "$EXTRACT" ]; then									# if we are extracting package(s) contents, then...
		# this executes the processDependencies() call below
	if [ "$FIND" ]; then									# if we are finding file(s) in packages, then...
# UPDATED 2025/10/29
#		showMsg 'action' "Searching for '${PACKAGE}' in packages..." 'screen' 0 0 0 1
# UPDATED 2025/10/30
#		showMsg 'action' "Searching for '${PACKAGE}' in packages..." 'screen' 0 5
		showMsg 'action' "Searching for '${PACKAGE}' in packages..." 'both' 1 4	# NOTE: we store to the log so if any error occurs, we know what it relates to (the rest of this section can just show to the screen)
# DBUG
#REPO_SOURCE='/tmp'
#		cd "${REPO_SYSTEM}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1		#   change into the first repo location to check for the files
# UPDATED 2025/12/03 - we are already in the REPO_SOURCE directory
#		for FILE in $(ls -1 "$REPO_SOURCE"/*.${EXT_SOFT}); do
		for FILE in $(ls -1 *.${EXT_SOFT}); do
#echo "file |$FILE|"
			[ $(stat -c %s $FILE) -eq 0 ] && continue				#   skip all 0 byte files (since they can just be placeholders); this really shouldn't come into play in this location, but better safe than sorry
			unsquashfs -ll $FILE | tail -n +5 | grep -v ^d | sed 's:.*/::' | grep -q "$PACKAGE" && {
# UPDATED 2025/10/27
#				echo $FILE
#				unsquashfs -ll $FILE | tail -n +5 | grep -v ^d | sed 's/.*squashfs-root/   /' | grep "$PACKAGE"
# UPDATED 2025/10/30
#				showMsg 'package' "$FILE" 'screen' 0 5
#				showMsg 'matches' "$(unsquashfs -ll "$FILE" | tail -n +5 | grep -v ^d | sed 's/.*squashfs-root/   /' | grep "$PACKAGE")" 'screen' 0 3 1
				showMsg 'package' "   $FILE" 'screen' 1 4 1
				showMsg 'file' "$(unsquashfs -ll "$FILE" | tail -n +5 | grep -v ^d | sed 's/.*squashfs-root/      /' | grep "$PACKAGE")" 'screen' 1 2 1
# REMOVED 2025/10/30
#				showMsg 'package' "" 'screen' 0 4
			}
		done

# REMOVED 2025/11/05 - this is controlled completely by the user via the -S
#		if [ "$REPO_OPTION" != "$REPO_SYSTEM" ]; then					#   if there are separate repo's for packages (e.g. XiniX and not TC), then...
#			cd "${REPO_OPTION}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1	#	change into the optional repo location to further check for the files
#			for FILE in $(ls -1 *.${EXT_SOFT}); do
#				[ $(stat -c %s $FILE) -eq 0 ] && continue			#	skip all 0 byte files (since they can just be placeholders)
#				unsquashfs -ll $FILE | tail -n +5 | grep -v ^d | sed 's:.*/::' | grep -q "$PACKAGE" && {
## UPDATED 2025/10/28
##					echo $FILE
##					unsquashfs -ll $FILE | tail -n +5 | grep -v ^d | sed 's/.*squashfs-root/   /' | grep "$PACKAGE"
#					showMsg 'package' "" 'screen' 0 4
#					showMsg 'package' "$FILE" 'screen' 0 5
#					showMsg 'matches' "$(unsquashfs -ll "$FILE" | tail -n +5 | grep -v ^d | sed 's/.*squashfs-root/   /' | grep "$PACKAGE")" 'screen' 0 3 1
#				}
#			done
#		fi

#		showMsg 'package|success' "" 'screen' 0 4
# REMOVED 2025/10/30
#		showMsg 'action' "" 'screen' 0 4
		continue
	#elif [ "$INSTALL" ]; then									# if we are installing package(s), then...
		# this executes the processDependencies() call below
# MOVED 2025/11/13 - moved into processDependencies() so that ALL the dependencies are added to the list
#		# add the package to the list of dependencies						  NOTE: this lists EVERY dependency for every dependency in one list; not just the dependencies for the requested package!
#		echo "$FILENAME" >>"${DIR_TEMP}/installed.${EXEID}"					# add the package to the cache file for future unloading/uninstalling information
	elif [ "$LIST" ]; then										# if we are listing installed packages, then...
# this is handled in the script parameter processing section above
TEMP="${TEMP}${RAWFILE}|"					#   adding to the regex statement
continue
	elif [ "$MAKE" ]; then									# if we are creating a package for distribution, then...
# MOVED 2025/11/03 - this was moved above where all the other actions set these values
#		DIRECTORY="$2"
# REMOVED 2025/11/20 - this was no longer being used in this manner
#		TEMP=1
# UPDATED 2025/10/22 - no longer using APP* variables
#		if [ -e "${APPNAME}.all.src.make" ] && [ -x "${APPNAME}.all.src.make" ]; then	# if a compile script exists, then lets run that first!
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Making the '${APPNAME}' package..."
#			./${APPNAME}.all.src.make >${APPNAME}.all.src.make.log 2>&1 || {
# UPDATED 2025/11/05 - this now needs to be REPO_SOURCE so the -S can be used too
#		if [ -e "${DIRECTORY}/${BASENAME}.${EXT_MAKE}" ] && [ -x "${DIRECTORY}/${BASENAME}.${EXT_MAKE}" ]; then		# if a compile script exists (and is executable), then lets run that first!
		if [ -e "./${BASENAME}.${EXT_MAKE}" ] && [ -x "./${BASENAME}.${EXT_MAKE}" ]; then	# if a compile script exists (and is executable), then lets run that first!
# UPDATED 2025/10/28
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Making the '${PACKAGE}' package..."
# UPDATED 2025/10/30
#			showMsg 'action' "Compiling the '${PACKAGE}' package:" 'screen' 1 0 0 1
#			cd "${DIRECTORY}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'action' 'screen' 2			# change into the passed directory (e.g. /tmp/staging[/PACKAGE.make|src/] > /tmp) so the generated files get placed correctly
# UPDATED 2025/11/20 - so that the compile script can output if desired
#			showMsg 'action' "Compiling the '${PACKAGE}' package:" 'both' 0 3
			showMsg 'action' "Compiling the '${PACKAGE}' package..." 'both' 1 4
# REMOVED 2025/11/05 - this is now handled above
#			cd "${DIRECTORY}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'action'			# change into the passed directory (e.g. /tmp/staging[/PACKAGE.make|src/] > /tmp) so the generated files get placed correctly
# CONSOLIDATED 2025/11/14
#			./${BASENAME}.${EXT_MAKE} >${BASENAME}.${EXT_MAKE}.log 2>&1 || {
## UPDATED 2025/10/28
##				[ "$SILENT" ] || echo "ERROR: a compile error occurred - see the log for details."
##				showMsg 'failure' "An error occurred while compiling."
## UPDATED 2025/10/30
##				exitGracefully 1 'action' 'screen' 2
#				exitGracefully 4 'both' 5 'action'
#			}
			./${BASENAME}.${EXT_MAKE} >${BASENAME}.${EXT_MAKE}.log 2>&1 || exitGracefully 4 'both' 5 'action'
# UPDATED 2025/11/20 - so that the compile script can output if desired
#			showMsg 'action' " [done]" 'both' 1 5
			showMsg 'action' "" 'both' 1 5
# REMOVED 2025/10/30 - this is handled elsewhere now
#			TEMP=0									# indicate we do NOT need to show the XML header again
# REMOVED 2025/11/05 - this is now handled above
#			cd - >/dev/null
		fi

# UPDATED 2025/10/22 - no longer using APP* variables
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Creating the '${APPNAME}' package..."
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Creating the '${PACKAGE}' package..."
# UPDATED 2025/10/30
#		showMsg 'action' "Creating the '${PACKAGE}' package..." 'screen' 0 5 0 $TEMP
## UPDATED 2025/10/23 - corrected the location to be the passed directory, and moved it to the top of this block
##		cd "${REPO_PREFIX}" >/dev/null 2>>"$LOG_ERRS"					# change into the previous directory (REPO_PREFIX) so the generated files get placed correctly (e.g. /tmp/staging > /tmp)
#		cd "${DIRECTORY}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'action' 'screen' 2				# change into the passed directory (e.g. /tmp/staging[/package][/bin,/etc,/usr,...] > /tmp) so the generated files get placed correctly
		showMsg 'action' "Creating the '${PACKAGE}' package..." 'both' 1 4
# REMOVED 2025/11/05 - this is now handled above
#		cd "${DIRECTORY}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 2 'both' 6					# change into the passed directory (e.g. /tmp/staging[/package][/bin,/etc,/usr,...] > /tmp) so the generated files get placed correctly
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[1/4] Erasing any prior files"
# UPDATED 2025/10/30
#		showMsg 'step' "   [1/4] Erasing any prior files:" 'screen' 1 3 1		# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
# #UPDATED 2025/10/22 - no longer using APP* variables
##		rm -f ${APPHEAD}.* >/dev/null 2>>"$LOG_ERRS"
#		[ -e "${FILENAME}" ] && { rm -f "${FILENAME}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'; }
#		[ -e "${BASENAME}.${EXT_HASH}" ] && { rm -f "${BASENAME}.${EXT_HASH}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'; }
#		[ -e "${BASENAME}.${EXT_LIST}" ] && { rm -f "${BASENAME}.${EXT_LIST}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'; }
#		[ -e "${BASENAME}.${EXT_INFO}" ] && { rm -f "${BASENAME}.${EXT_INFO}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'; }
#		[ -e "${BASENAME}.${EXT_DEPS}" ] && { rm -f "${BASENAME}.${EXT_DEPS}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'; }
#		showMsg 'step' " [done]" 'screen' 2 3
		showMsg 'step' "   [1/4] Erasing any prior files:" 'both' 0 3			# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
		[ -e "${FILENAME}" ] && { rm -f "${FILENAME}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		[ -e "${BASENAME}.${EXT_HASH}" ] && { rm -f "${BASENAME}.${EXT_HASH}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		[ -e "${BASENAME}.${EXT_LIST}" ] && { rm -f "${BASENAME}.${EXT_LIST}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		[ -e "${BASENAME}.${EXT_INFO}" ] && { rm -f "${BASENAME}.${EXT_INFO}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		[ -e "${BASENAME}.${EXT_DEPS}" ] && { rm -f "${BASENAME}.${EXT_DEPS}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		showMsg 'step' " [done]" 'both' 1 5
# UPDATED 2025/10/22 - no longer using APP* variables
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[2/4] Creating the .soft file"
#		mksquashfs "${REPO_OPTION##*/}" "$APPFILE" >>"$LOG_ERRS" 2>&1
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[2/4] Creating the .${EXT_SOFT} file"
# UPDATED 2025/10/30
#		showMsg 'step' "   [2/4] Creating the .${EXT_SOFT} file:" 'screen' 1 3 1
## UPDATED 2025/10/28
##		[ -d "${DIRECTORY}/package" ] && TEMP='package' || TEMP="${2##*/}"		# if the compiled software call above created a 'package' directory then use it to create the packages below, otherwise use the directory that was passed
#		[ -d "${DIRECTORY}/package" ] && TEMP='package' || TEMP=''			# if the compiled software call above created a 'package' directory then use it to create the packages below, otherwise use the directory that was passed
## UPDATED 2025/10/23 - corrected the location to be the passed directory
##		mksquashfs "${REPO_OPTION##*/}" "${FILENAME}" >>"$LOG_ERRS" 2>&1
#		mksquashfs "${TEMP}" "${FILENAME}" >>"$LOG_ERRS" 2>&1 || exitGracefully 1 'step' 'screen' 2 3 'action'
#		showMsg 'step' " [done]" 'screen' 2 3
		showMsg 'step' "   [2/4] Creating the .${EXT_SOFT} file:" 'both' 0 3
		[ -d "${DIRECTORY}/package" ] && TEMP='package' || TEMP='./'			# if the compiled software call above created a 'package' directory then use it to create the packages below, otherwise use the directory that was passed
		mksquashfs "${TEMP}" "${FILENAME}" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'step'
		showMsg 'step' " [done]" 'both' 1 5
# UPDATED 2025/10/22 - no longer using APP* variables
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[3/4] Creating the .hash file"
#		md5sum "$APPFILE" > "${APPHEAD}.hash" 2>>"$LOG_ERRS"
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[3/4] Creating the .${EXT_HASH} file"
# UPDATED 2025/10/30
#		showMsg 'step' "   [3/4] Creating the .${EXT_HASH} file:" 'screen' 1 3 1
#		md5sum "${FILENAME}" >"${BASENAME}.${EXT_HASH}" 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'
#		showMsg 'step' " [done]" 'screen' 2 3
		showMsg 'step' "   [3/4] Creating the .${EXT_HASH} file:" 'both' 0 3
		md5sum "${FILENAME}" >"${BASENAME}.${EXT_HASH}" 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'
		showMsg 'step' " [done]" 'both' 1 5
# UPDATED 2025/10/22 - no longer using APP* variables
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[4/4] Creating the .list file"
#		find "${REPO_OPTION##*/}" -not -type d 2>>"$LOG_ERRS" | sed "s/${REPO_OPTION##*/}//" > "${APPHEAD}.list" 2>>"$LOG_ERRS"
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[4/4] Creating the .${EXT_LIST} file"
# UPDATED 2025/10/30
#		showMsg 'step' "   [4/4] Creating the .${EXT_LIST} file:" 'screen' 1 3 1
## UPDATED 2025/10/23 - corrected the location to be the passed directory
##		find "${REPO_OPTION##*/}" -not -type d 2>>"$LOG_ERRS" | sed "s/${REPO_OPTION##*/}//" > "${BASENAME}.${EXT_LIST}" 2>>"$LOG_ERRS"
#		find "${TEMP}" -not -type d 2>>"$LOG_ERRS" | sed "s|${TEMP}||" >"${BASENAME}.${EXT_LIST}" 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'
#		showMsg 'step' " [done]" 'screen' 2 3
#		showMsg 'action' "" 'screen' 0 4
		showMsg 'step' "   [4/4] Creating the .${EXT_LIST} file:" 'both' 0 3
		find "${TEMP}" -not -type d 2>>"$LOG_ERRS" | sed "s|${TEMP}||" >"${BASENAME}.${EXT_LIST}" 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'
		showMsg 'step' " [done]" 'both' 1 5
	#	showMsg 'action' "" 'screen' 0 4
# UPDATED 2025/10/28
#		echo -e "\nThe package has been created!"
## UPDATED 2025/10/22 - no longer using APP* variables
##		echo -e "Don't forget to create/update the .deps and .info files!\n"
#		echo -e "Don't forget to create/update the .${EXT_HASH} and .${EXT_INFO} files!\n"
	#	showMsg 'note|success' "\nThe package has been created!\nDon't forget to create/update the .${EXT_DEPS} and .${EXT_INFO} files!\n"
		showMsg 'note' "\nThe package has been created!\nDon't forget to create/update the .${EXT_DEPS} and .${EXT_INFO} files!\n" 'both' 1 2 1
		showMsg 'success' "" 'both' 1 6
		exit 0										# prevent the code below from executing since we're done with this ACTION
	elif [ "$OPEN" ]; then									# if we are opening a fifo, then...
#echo "iterating |$RAWFILE|"
		if [ "$RAWFILE" != 'clear' ]; then						#   if a different fifo name was passed, then set it
			FIFO_SERVER="$RAWFILE"
#echo "setting the fifo name |${FIFO_SERVER}|"
		elif [ -e "${FIFO_SERVER}" ] && [ ! "$FORCE" ]; then				#   if the fifo exists -AND- we're not forcing the action, then there might have been an error previously so...
#echo "erasing an existing fifo |${FIFO_SERVER}|"
			rm -f "${FIFO_SERVER}" || {						#      delete it
				showMsg 'failure' "The input FIFO could not be cleared." 'screen'
				exit 1
			}
		fi
		continue
	elif [ "$PROXY" ]; then									# if we are proxying an action, then...
# UPDATED 2025/10/28
#		echo "$RAWFILE" >> "${DIR_TEMP}/proxy.list"
		echo "$PACKAGE" >> "${DIR_TEMP}/proxy.list"					# create the proxy package list
		continue
	elif [ "$TREE" ]; then										# if we are showing the dependency tree, then...
# this is handled in the script parameter processing section above
#				for PARAMETER in $@; do							#   cycle through each name passed
#					[ -d "$PARAMETER" ] && {
#						showMsg 'failure' "The DIRECTORY value can not be used with the -t action." 'screen'
#						exit 1
#					}
#					splitName "$PARAMETER"
		if [ "$TREE" = 'reliant' ]; then				# if we need to show which packages are reliant upon the ones passed, then...
					showMsg 'package' "${PACKAGE} (${FILETYPE})" 'screen' 1 4
					for FILE in $(grep -lE ^"(${BASENAME}|${FILENAME})" *.${EXT_DEPS}); do
						splitName "$FILE" "$EXT_DEPS"
						showMsg 'file' "   (${FILETYPE}) ${PACKAGE}" 'screen' 1 4
					done
#				done
		continue
		fi								# otherwise we need to show which packages this one depends on, so lets call processDependencies()!
	#elif [ "$UNLOAD" ]; then									# if we are unloading/uninstalling package(s), then...
		# this executes the processDependencies() call below
# REMOVED 2025/11/14 - changed the way this is processed
#		touch ${DIR_LIST}/${FILE%.*}.${EXT_MARK}
#		EXEID="$(grep -lH "$PACKAGE" "${DIR_TEMP}/installed."*)"			# store the cache file containing the software to be uninstalled
	#elif [ "$VALIDATE" ]; then									# if we are validating package(s) information, then...
		# this executes the processDependencies() call below
	fi

	# NOTE: everything below this point in this segment is simply to build the dependency list, the actual work is done in the following 'while' loop
# REMOVED 2025/11/07
#	else
#echo "INDEX |$INDEX|"
# REMOVED 2025/12/01
## MOVED 2025/11/12 - this was moved above
##		[ "$RESTORE" ] && cd "${REPO_RESTOR}/${RESTORE}"				# change into the restore points directory to get all the requested software and any of its dependencies
# UPDATED 2025/10/22 - using PACKAGE
#		[ "$UNLOAD" ] && EXEID="$(grep -lH "$RAWFILE" "${DIR_TEMP}/"*)"			# store the cache file containing the software to be uninstalled
# MOVED 2025/11/12 - this was moved above
#		[ "$UNLOAD" ] && EXEID="$(grep -lH "$PACKAGE" "${DIR_TEMP}/"*)"			# store the cache file containing the software to be uninstalled
# REMOVED 2025/11/06 - this was moved in the parameter processing above
#		[ "$TREE" ] && {
## UPDATED 2025/10/28
##			echo -e "\n[ DEPENDENTS ]"
### UPDATED 2025/10/22 - no longer using APP* variables
###			echo "${APPNAME}.${APPTYPE}"
##			echo "${PACKAGE}"
## UPDATED 2025/10/31
##			showMsg 'dependents' "\n[ DEPENDENTS ]" 'screen' 0 5 1
##			showMsg 'dependent' "${PACKAGE}" 'screen' 0 3
#			showMsg 'dependents' "\n[ DEPENDENTS ]" 'both' 1 4 1
#			showMsg 'package' "${PACKAGE}" 'both' 1 1
## VER2 - update this once we have our own repo
##			echo "${PACKAGE}[${TYPE}]"
## UPDATED 2025/10/22 - no longer using APP* variables
##			for DEPFILE in $(ls -1 $DIR_LIST | grep 'deps'$); do			# find any form of the iterated package (e.g. bash.i64.bin.soft, bash.bin, etc) in any installed software .deps file
##				grep -q "${APPNAME}.${APPARCH}.${APPTYPE}.${APPEXTN}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
##				grep -q "${APPNAME}.${APPTYPE}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
##				grep -q "${RAWFILE}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
#			for DEPFILE in $(ls -1 "$DIR_LIST" | grep ${EXT_DEPS}$); do		# find any form of the iterated package (bash.i64.bin.soft, bash[bin], bash) in any installed software .deps file
## UPDATED 2025/10/28
##				grep -q "${FILENAME}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
## UPDATED 2025/10/29
##				grep -q "${PACKAGE}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
## UPDATED 2025/10/31
##				grep -q "${FILENAME}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { showMsg 'dependent' "   $DEPFILE" 'screen' 0 3 1; continue; }
#				grep -q "${FILENAME}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { showMsg 'dependent' "   $DEPFILE" 'both' 1 1 1; continue; }
## VER2 - uncomment this once we have our own repo (since it's another variation of the filename that can be present in the deps file)
##				grep -q "${APPNAME}.${APPTYPE}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
## UPDATED 2025/10/31
##				grep -q "${PACKAGE}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { showMsg 'dependent' "   $DEPFILE" 'screen' 0 3 1; continue; }
#				grep -q "${PACKAGE}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { showMsg 'dependent' "   $DEPFILE" 'both' 1 1 1; continue; }
#			done
## UPDATED 2025/10/31
##			showMsg 'dependents' '' 'screen' 0 4
#			showMsg 'dependents' '' 'both' 1 5
## UPDATED 2025/10/28
##			echo -e "\n[DEPENDENCIES]"
## UPDATED 2025/10/31
##			showMsg 'dependencies' "\n[DEPENDENCIES]" 'screen' 0 5 1
#			showMsg 'dependencies' "\n[DEPENDENCIES]" 'both' 1 4 1
#		}
# UPDATED 2025/10/22 - using PACKAGE
#		processDependencies "${RAWFILE}"
		processDependencies "${FILENAME}" || exitGracefully 2 'screen' 5 'step'
#echo '----'
#ls -1 /tmp/pax >/tmp/debug.txt
#echo '----'
# UPDATED 2025/11/14
#		[ ! "$DEPENDENCY" ] && continue							# if the iterated package has already been installed (via a prior package), then no need to waste resources below...
	# left off - the below can be commented out since the loops are now separated
	#	( [ ! "$DEPENDENCY" ] || [ "$UNLOAD" ] ) && continue				# if the iterated package has already been installed (via a prior package) -OR- we're unloading packages, then no need to waste resources below...
# UPDATED 2025/10/31
#		[ "$TREE" ] && { showMsg 'dependencies' '' 'screen' 0 4; continue; }		# if we are simply displaying a dependency tree, then go to the next package in the list
	# probably don't need this any longer
	#	[ "$TREE" ] && { showMsg 'dependencies' '' 'both' 1 5; continue; }		# if we are simply displaying a dependency tree, then go to the next package in the list
# REMOVED 2025/11/06 - since this become its own loop, we don't need this any longer
#		[ "$VALIDATE" = 'deps' ] && continue						# if we are validating a packages dependencies, then go to the next package
# UPDATED 2025/10/28
#		[ "$VALIDATE" = 'data' ] && { ( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -e "\nValidating the package data..."; }
# UPDATED 2025/10/31
#		[ "$VALIDATE" = 'data' ] && { showMsg 'action' "\nValidating the package data..." 'screen' 0 0 1; }
# REMOVED 2025/11/06 - this was moved outside of this loop
#		[ "$VALIDATE" = 'data' ] && { showMsg 'action' "\nValidating the package data..." 'screen' 1 4 1; }
# REMOVED 2025/11/14 - changed the way this is processed
#		[ "$UNLOAD" ] && {								# if we are unloading, then...
#			INDEX=1									#   change the INDEX value since we need to reverse the order to process the dependencies
#			eval "DEPENDENCY=\$DEP${INDEX}"						#   reset the variable value to the new 'pointer' value of the 'array'
#		}
# REMOVED 2025/11/07
#	fi
# ADJUSTED 2025/11/05 - made these two separate loops so all the dependencies get processed at once to generate the entire list before actual actions take place
#echo DBUG
#continue
#echo DBUG
#exit 0
done

	# PROCESS THE ACTION (per passed package)						NOTE: this has to be done this way so that (un)installations can create and process proper file lists

	[ "$VALIDATE" = 'deps' ] && exitGracefully 0 'both' 6 'success'				# there's no more work to perform if this was the action to process
	[ $INDEX -eq 0 ] && [ ! "$FIND" ] && [ ! "$LIST" ] && [ ! "$OPEN" ] && [ "$TREE" != 'reliant' ] && [ ! "$UNLOAD" ] && {
		[ "$TREE" != 'relies' ] && showMsg 'action' "There are no package(s) to be processed." 'both' 1 4
		exitGracefully 0 'both' 6 'success'
	}

	if ( [ $DEBUG -gt 1 ] || [ "$PROMPT" ] ); then
		if [ "$PROMPT" ] && [ ! "$PROXY" ] && [ ! "$VALIDATE" ]; then
			[ "$COPY" ] && TEMP='copied'
			[ "$DOWNLOAD" ] && TEMP='downloaded'
			[ "$EXTRACT" ] && TEMP='extracted'
			#[ "$FIND" ]
			[ "$INSTALL" ] && TEMP='installed'
			#[ "$LIST" ]
			#[ "$MAKE" ]
			#[ "$OPEN" ]
			#[ "$PROXY" ]
			#[ "$TREE" ]
			[ "$UNLOAD" ] && TEMP='unloaded'
			#[ "$VALIDATE" ]

			showMsg 'action' "The following package(s) will be ${TEMP}:" 'both' 1 4
			listDependencies
		fi

# UPDATED 2025/11/19
#		echo -en "   Do you want to proceed with the action? [Y/N] (N): "
		showMsg 'prompt' "   Do you want to proceed with the action? [Y/N] (N): " 'both' 0 1 1
		[ "$OUTPUT" = 'fifo' ] && read <"$FIFO_SERVER" || read
		( [ "$REPLY" = 'N' ] || [ "$REPLY" = 'n' ] || [ "$REPLY" = '' ] ) && exitGracefully 0 'both' 6 'success'
	fi


	[ "$COPY" ] && showMsg 'action' "Copying the specified package(s)..." 'both' 1 4
	[ "$DOWNLOAD" ] && showMsg 'action' "Downloading the specified package(s)..." 'both' 1 4
	[ "$EXTRACT" ] && showMsg 'action' "Extracting the specified package(s)..." 'both' 1 4
	#[ "$FIND" ]
	[ "$INSTALL" ] && {
		showMsg 'action' "Installing the specified package(s)..." 'both' 1 4
#echo "mode |$MODE|"
		# NOTE: this MUST be here and not in the parameter processing section above, because the -M option may not get passed!
# UPDATED 2025/11/25
		# if '-M copy' was passed to this script -OR- the copy-everything-to-RAM file exists -OR- { the copy the system directory (REPO_SYSTEM) contents to RAM file exists -and- we're using that directory (e.g. booting) -and- REPO_SYSTEM and REPO_OPTION are NOT the same (to prevent TC from erroneously loading everything to RAM since those two would be the same) }, then...
#		if [ "$MODE" = 'copy' ] || [ -e "${REPO_PREFIX}/copy_all.flag" ] || ( [ -e "${REPO_PREFIX}/copy_sys.flag" ] && [ "$REPO_SOURCE" = "$REPO_SYSTEM" ] && [ "$REPO_SYSTEM" != "$REPO_OPTION" ] ); then
# UPDATED 2025/12/08
#		if [ "$MODE" = 'copy' ] || [ -e "${REPO_PREFIX}/${FLAG_COPY}" ] || ( [ -e "${REPO_PREFIX}/${FLAG_FIRM}" ] && [ "$BOOTING" ] ) || [ "$(getBootcode mode)" != "conservative" ]; then
		# if no mode was passed (this way the commandline overrides) -AND- ( the copy-everything-to-RAM file exists -OR- { the copy the system directory (REPO_SYSTEM) contents to RAM file exists -and- we're booting } -OR- we're not using 'conservative' mode ), then...
		if [ ! "$MODE" ] && ( [ -e "${REPO_PREFIX}/${FLAG_COPY}" ] || ( [ -e "${REPO_PREFIX}/${FLAG_FIRM}" ] && [ "$BOOTING" ] ) || [ "$(getBootcode mode)" != "conservative" ] ); then
#echo top
			[ $DEBUG -gt 0 ] && echo -e "\tInstall by copying..." >>"$LOG_DBUG"
#			showMsg 'step' " [copy]" 'both' 0 0
			MODE='copy'
# UPDATED 2025/12/08
#		else
		elif [ "$MODE" != 'copy' ]; then
#echo btm
			[ $DEBUG -gt 0 ] && echo -e '\tInstall using symlinks...' >>"$LOG_DBUG"
#			showMsg 'step' " [link]" 'both' 0 0
			MODE='link'
		fi

#echo "dbug4 |$MODE|"
	}
	#[ "$LIST" ]
	#[ "$MAKE" ]
	#[ "$OPEN" ]
	#[ "$PROXY" ]
	#[ "$TREE" ]
	#[ "$UNLOAD" ]
	[ "$VALIDATE" ] && showMsg 'action' "Validating the package contents..." 'both' 1 4



	# now process the dependencies obtained from the above segment!
	while [ "$DEPENDENCY" ] && [ $INDEX -gt 0 ]; do						# while we have a dependency to process via the DEPENDENCY value set by processDependencies() and INDEX adjusted within this loop itself
# UPDATED 2025/10/22 - no longer using APP* variables; UPDATED AGAIN 2025/11/05 - the dependency files are all the full names so we don't have to worry about splitting anything
		splitName "$DEPENDENCY"

# REMOVED 2025/11/05 - with adjustments made above, these statements may no longer be relevent
##		# find and change into, the directory containing the package to be processed	  NOTE: the downloadPackage() will make further directory adjustments below
## UPDATED 2025/10/22 - no longer using APP* variables
##		if [ ! "$REPO_SOURCE" ] && [ -e "./${APPFILE}" ]; then								# if no source was provided via '-S' and the pwd has the file (e.g. from a restore point), then...
#		if [ ! "$REPO_SOURCE" ] && [ -e "./${FILENAME}" ]; then						# if no source was provided via '-S' and the pwd has the file (e.g. from a restore point), then...
#			SOURCE='local'
#		elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'http' || echo "$REPO_SOURCE"|grep -q ^'ftp' ); then	# if a different SOURCE was provided -AND- it is remote, then...
#			cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1 || exitGracefully 1						# NOTE: we cd into this directory just as a precaution
#			DOWNLOAD=TRUE
## UPDATED 2025/10/22 - no longer using APP* variables
##		elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'/' || echo "$REPO_SOURCE"|grep -q ^'./' ) && ( [ -e "${REPO_SOURCE}/${APPFILE}" ] || [ -f "${REPO_SOURCE}/${VERFILE}" ] ); then	# if a different SOURCE was provided -AND- it is a directory -AND- the iterated package exists in the REPO directory, then...	NOTE: the use of -f is required in case VERFILE is blank
#		elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'/' || echo "$REPO_SOURCE"|grep -q ^'./' ) && ( [ -e "${REPO_SOURCE}/${FILENAME}" ] || [ -f "${REPO_SOURCE}/${VERFILE}" ] ); then	# if a different SOURCE was provided -AND- it is a directory -AND- the iterated package exists in the REPO directory, then...	NOTE: the use of -f is required in case VERFILE is blank
#			cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 1
#			unset DOWNLOAD
## UPDATED 2025/10/22 - no longer using APP* variables
##		elif [ -e "${REPO_SYSTEM}/${APPFILE}" ] || [ -f "${REPO_SYSTEM}/${VERFILE}" ]; then				# otherwise check that the file exists in the REPO_SYSTEM...
#		elif [ -e "${REPO_SYSTEM}/${FILENAME}" ] || [ -f "${REPO_SYSTEM}/${VERFILE}" ]; then		# otherwise check that the file exists in the REPO_SYSTEM...
#			cd "$REPO_SYSTEM" >>"$LOG_ERRS" 2>&1 || exitGracefully 1
#			unset DOWNLOAD
#		else														# and lastly change to the default REPO_OPTION as a last resort to find the software
#			cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1 || exitGracefully 1
## UPDATED 2025/10/22 - no longer using APP* variables
##			( [ -e "${REPO_OPTION}/${APPFILE}" ] || [ -f "${REPO_OPTION}/${VERFILE}" ] ) && unset DOWNLOAD || DOWNLOAD=TRUE
#			( [ -e "${REPO_OPTION}/${FILENAME}" ] || [ -f "${REPO_OPTION}/${VERFILE}" ] ) && unset DOWNLOAD || DOWNLOAD=TRUE
#		fi

# UPDATED 2025/10/22 - no longer using APP* variables
#		[ $DEBUG -gt 0 ] && { echo -en "  body:\n\tINDEX      :${INDEX}:\n\tDEPENDENCY :${DEPENDENCY}:\n\tAPPFILE    :$APPFILE:\n\tAPPHEAD    :$APPHEAD:\n\tAPPNAME    :$APPNAME:\n\tAPPARCH    :$APPARCH:\n\tAPPTYPE    :$APPTYPE:\n\tAPPEXTN    :$APPEXTN:\n\tVERSION :${VERSION}:\n\tVERFILE    :$VERFILE:\n\tDOWNLOAD  :$DOWNLOAD:\n\tpwd        " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }
# UPDATED 2025/11/05 - the dependency files are all the full names so we don't have to worry about splitting anything
#		[ $DEBUG -gt 0 ] && { echo -en "  body:\n\tINDEX      |${INDEX}|\n\tDEPENDENCY |${DEPENDENCY}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE    |${PACKAGE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tTYPE        |${FILETYPE}|\n\tVERSION |${VERSION}|\n\tVERFILE    |$VERFILE|\n\tDOWNLOAD  |$DOWNLOAD|\n\tpwd        " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }
		[ $DEBUG -gt 0 ] && { echo -en "body (implementation):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tTYPE        |${FILETYPE}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |$VERFILE|\n\tDOWNLOAD    |$DOWNLOAD|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

		# NOTE: this is a separate 'if' on purpose!	NOTE: these only need to execute if we are NOT validating packages
# UPDATED 2025/11/06
#		if [ ! "$DOWNLOAD" ] && [ ! "$VALIDATE" ]; then
		if [ ! "$DOWNLOAD" ]; then
# UPDATED 2025/10/22 - no longer using APP* variables
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${APPFILE}: [local]"
# UPDATED 2025/10/28
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${FILENAME}: [local]"
# UPDATED 2025/11/05
#			showMsg 'step' "${FILENAME}: [local]" 'screen' 1
# UPDATED 2025/11/19 - adjusted for the -Q value
#			showMsg 'step' "${DEPENDENCY}: [local]" 'both' 0 3
			showMsg 'file' "${DEPENDENCY}: [local]" 'both' 0 3
# UPDATED 2025/11/06
#		elif [ "$DOWNLOAD" ] && [ ! "$VALIDATE" ]; then
		elif [ "$DOWNLOAD" ]; then
# UPDATED 2025/10/22 - no longer using APP* variables
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${APPFILE}: [remote]"
# UPDATED 2025/10/28
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${FILENAME}: [remote]"
# UPDATED 2025/11/05
#			showMsg 'step' "${FILENAME}: [remote]" 'screen' 1
#			[ "$REPO_TARGET" ] && cd "$REPO_TARGET" >>"$LOG_ERRS" 2>&1 || cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1		# if a different target was specified, then cd into it now, otherwise use the default location!
# UPDATED 2025/11/19 - adjusted for the -Q value
#			[ "$DRYRUN" ] && showMsg 'step' "${DEPENDENCY}: [remote] [dryrun]" 'both' 0 3
#			[ ! "$DRYRUN" ] && showMsg 'step' "${DEPENDENCY}: [remote]" 'both' 0 3
			[ "$DRYRUN" ] && showMsg 'file' "${DEPENDENCY}: [remote] [dryrun]" 'both' 0 3
			[ ! "$DRYRUN" ] && showMsg 'file' "${DEPENDENCY}: [remote]" 'both' 0 3
			downloadPackage || exitGracefully 4 'screen' 5 'step'
		fi

		# NOTE: this is a separate 'if' on purpose!
		if [ "$COPY" ]; then								# if we're copying package(s), then...
# UPDATED 2025/10/28
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [copy]"
# REMVOED 2025/11/14 - we already know we're copying, no need to state again
#			showMsg 'step' " [copy]" 'both' 0 0
			[ "$DRYRUN" ] && showMsg 'file' " [dryrun]" 'both' 0 0
# UPDATED 2025/11/05
#			copyPackage || exitGracefully 1
			copyPackage || exitGracefully 4 'screen' 5 'step'
		elif [ "$EXTRACT" ]; then									# if we are extracting package(s) contents, then...
			# this is handled in the package processing above
		# NOTE: we can NOT make unsquashfs use the 'pax -F' option since it will just error
		#	with success even though it doesn't process anything if files or directory
		#	structures exist. As a result always force unsquashfs to operate to ensure
		#	the process works.

# UPDATED 2025/10/27
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "Extracting the '${PACKAGE}' package:"
# UPDATED 2025/10/30
#		showMsg 'package' "Extracting the '${PACKAGE}' package:" 'screen' 1 0 0 1
# REMOVED 2025/11/24
#		showMsg 'action' "Extracting the '${PACKAGE}' package:" 'both' 0 3
# UPDATED 2025/11/03 - implementing DIRECTORY
#		[ ! "$REPO_TARGET" ] && REPO_TARGET='./'					# if no directory was passed, then set the current directory as the target
#		[ $DEBUG -gt 0 ] && echo -e "unsquashfs -f -d \"$REPO_TARGET\" ${FILENAME}" >>"$LOG_DBUG"
#		unsquashfs -f -d "$REPO_TARGET" ${FILENAME} 1>/dev/null 2>>"$LOG_ERRS" || exitGracefully 2
		[ $DEBUG -gt 0 ] && echo -e "unsquashfs -f -d \"$DIRECTORY\" \"./${FILENAME}\"" >>"$LOG_DBUG"
		[ "$DRYRUN" ] && showMsg 'file' " [dryrun]" 'both' 0 0
# UPDATED 2025/11/05 - the directory is changed into above now
#		unsquashfs -f -d "$DIRECTORY" "${REPO_SOURCE}/${FILENAME}" 1>/dev/null 2>>"$LOG_ERRS" || exitGracefully 2
# UPDATED 2025/12/02 - we are now in the REPO_SOURCE directory
#		[ ! "$DRYRUN" ] && ( unsquashfs -f -d './' "${REPO_SOURCE}/${FILENAME}" 1>/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'package' )
		[ ! "$DRYRUN" ] && ( unsquashfs -f -d "$DIRECTORY" "./${FILENAME}" 1>/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'package' )
# UPDATED 2025/10/27
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo " [done]"
# UPDATED 2025/10/30
#		showMsg 'package' " [done]" 'screen' 2
# REMOVED 2025/11/24
#		showMsg 'action' " [done]" 'both' 1 5 
#		continue

		#elif [ "$FIND" ]; then									# if we are finding file(s) in packages, then...
			# this is handled in the package processing above
		elif [ "$INSTALL" ]; then							# if we're installing package(s), then...
# REMOVED 2025/10/21 - unsure what this was doing
#			if [ -e "${DIR_LIST}/${APPFILE}" ]; then						# if we are updating the installed package, then...
# UPDATED 2025/10/08
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [install]"
# UPDATED 2025/10/28
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || {
## UPDATED 2025/10/22 - no longer using APP* variables
##				[ ! -e "${DIR_LIST}/${APPFILE}" ] && echo -n " [install]"
##				[ -e "${DIR_LIST}/${APPFILE}" ] && echo -n " [update]"
#				[ ! -e "${DIR_LIST}/${FILENAME}" ] && echo -n " [install]"
#				[ -e "${DIR_LIST}/${FILENAME}" ] && echo -n " [update]"
#			}
			[ ! -e "${DIR_LIST}/${FILENAME}" ] && showMsg 'step' " [install]" 'both' 0
			[ -e "${DIR_LIST}/${FILENAME}" ] && showMsg 'step' " [update]" 'both' 0
# UPDATED 2025/11/12
#			installPackage || exitGracefully 1
			installPackage || exitGracefully 4 'screen' 5 'step'
		#elif [ "$LIST" ]; then									# if we are listing the installed packages, then...
			# this is handled in the script parameter processing section above
		#elif [ "$MAKE" ]; then									# if we are creating a package for distribution, then...
			# this is handled in the package processing above
		#elif [ "$OPEN" ]; then
			# this is handled in the final processing below
		#elif [ "$PROXY" ]; then									# if we are proxying an action, then...
			# this is handled in the final processing below
# REMOVED 2025/12/01
#		elif [ "$RESTORE" ]; then							# if we're restoring package(s), then...
## UPDATED 2025/10/28
##			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [restore]"
#			showMsg 'step' " [restore]" 'screen' 1
## UPDATED 2025/10/22 - no longer using APP* variables
##			[ -e "${DIR_LIST}/${APPFILE}" ] && { unloadPackage || exitGracefully 1; }				# if an undesired version/non-working package is currently installed, remove it now
## REMOVED 2025/11/24 - this is already part of installPackage()
##			[ -e "${DIR_LIST}/${FILENAME}" ] && { unloadPackage || exitGracefully 1; }			# if an undesired version/non-working package is currently installed, remove it now
#			copyPackage || exitGracefully 1										# copy the restore point packages back into the system
#			installPackage || exitGracefully 1									# install that version
		#elif [ "$TREE" ]; then										# if we are showing the dependency tree, then...
			# this is handled in the script parameter processing section above
		#elif [ "$UNLOAD" ]; then							# if we're unloading package(s), then...
			# this is never reached since the overall loop is iterated right after processDependencies() is called, for this action
# UPDATED 2025/10/28
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [unload]"
# MOVED 2025/11/14 - this is moved to 'execute final processing' below
#			showMsg 'step' " [unload]" 'screen' 1
#			unloadPackage || exitGracefully 1
		elif [ "$VALIDATE" ]; then							# if we're validating package(s), then...
# UPDATED 2025/11/06
#			validatePackage || exitGracefully 1
#			deleteDependency TRUE
#			continue
# UPDATED 2025/12/09
#			eval TEMP="${DIR_LOOP}/${LOOP_SCHEMA}"
#
#			# NOTE: this was put here in case some packages are symlinked and some are copied
#			( /bin/mount 2>>"$LOG_ERRS" | grep -q "${TEMP} type squashfs" ) && MODE='link' || MODE='copy'	# store the package installation mode: symlinked or copied
			( /bin/mount 2>>"$LOG_ERRS" | grep -q "${DIR_LOOP}/${BASENAME} type squashfs" ) && MODE='link' || MODE='copy'	# store the package installation mode: symlinked or copied

			# NOTE: the installPackage() will process the appropriate validation request
			installPackage || exitGracefully 4 'screen' 5 'step'
		fi
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo " [done]"
		[ ! "$VALIDATE" ] && showMsg 'file' " [done]" 'both' 1 5 || showMsg 'file' "" 'both' 1 5

# LEFT OFF - installing doesn't appear to process dependencies without a trailing TRUE
# UPDATED 2025/12/09
#		deleteDependency								# delete the dependency before assigning the next one below
		deleteDependency TRUE								# delete the dependency before assigning the next one below
# REMOVED 2025/11/14
#		[ "$UNLOAD" ] && INDEX=$(( INDEX + 1 ))						# if we are unloading, then we need to reverse the order to process the dependencies
# REMOVED 2025/12/09 - this should be handled by deleteDependency()
#		[ ! "$UNLOAD" ] && INDEX=$(( INDEX - 1 ))					# move the 'pointer' within the $DEP 'array' (instead of calling deleteDependency() since we need those values below)
#		eval "DEPENDENCY=\$DEP${INDEX}"							# reset the variable value to the new 'pointer' value of the 'array'
	done
#done




# EXECUTE FINAL PROCESSING

# finalize any output for '-O xml' with any of these actions
# UPDATED 2025/10/31 - combined the statements
#if [ "$EXTRACT" ] && ( [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ] ); then		# if we are extracting a packages contents, then...
#	showMsg 'success' "" 'both' 1 6
#elif [ "$FIND" ] && ( [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ] ); then			# if we are finding files in packages, then...
#	showMsg 'success' "" 'screen' 1 6
#fi
# REMOVED 2025/12/02 - this is already the default exit call
##if ( [ "$COPY" ] || [ "$EXTRACT" ] || [ "$FIND" ] ) && ( [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ] ); then		# if we're copying, extracting, or finding, then...
## UPDATED 2025/11/19
##	showMsg 'success' "" 'both' 1 6
##	exitGracefully 0
#	exitGracefully 0 'both' 6 'success'
#
#elif [ "$LIST" ]; then
if [ "$LIST" ]; then
	[ "$TEMP" ] && TEMP="^(${TEMP%|*})"								# if specific packages were passed, then construct a regex grep statement with packages matching the beginning of each name entered

	if [ "$OUTPUT" = 'text' ]; then
		# [Colors]
		NORMAL="\e[0m"
		BLINK="\e[5m"
		INVERSE="\e[7m"
		HIDE="\e[8m"
		UL="\e[4m"

		BLACK="\e[0;30m"
		GARNET="\e[0;31m"
		GREEN="\e[0;32m"
		BROWN="\e[0;33m"
		NAVY="\e[0;34m"
		MAGENTA="\e[1;35m"
		TEAL="\e[0;36m"
		DARKGREY="\e[1;30m"
		GREY="\e[0;37m"
		RED="\e[1;31m"
		LIME="\e[1;32m"
		YELLOW="\e[1;33m"
		BLUE="\e[1;34m"
		PURPLE="\e[0;35m"
		CYAN="\e[1;36m"
		WHITE="\e[1;37m"

		printf "${BLUE}%-30s %-9s %5s %-32s\n" "Name" " Version" "Types" "              Hash"
		printf "${WHITE}%30s %-9s %5s %32s\n" "------------------------------" "---------" "-----" "--------------------------------"
	fi

# UPDATED 2025/12/03 - to be more efficient
#	for FILE in $(ls -1 "$DIR_LIST" 2>/dev/null | grep -E "${TEMP}" | grep ${EXT_SOFT}$); do		# NOTE: using 'grep' prevents directory from being part of FILE
	for FILE in $(cd "${DIR_LIST}" && ls -1 *.${EXT_SOFT} 2>/dev/null | grep -E "${TEMP}"); do		# NOTE: using 'grep' prevents directory from being part of FILE
		splitName "$FILE"
		case $BASENAME in
			*-dev*|*_dev*|*.dev*) TYPE='dev' ;;
			*-doc*|*_doc*|*.doc*) TYPE='doc' ;;
			*-drv*|*_drv*|*.drv*) TYPE='drv' ;;
			*-gir*|*_gir*|*.gir*) TYPE='gir' ;;
			*-lib*|*_lib*|*.lib*) TYPE='lib' ;;
			*-loc*|*_loc*|*.loc*) TYPE='loc' ;;
			*) TYPE='bin' ;;
		esac
		if [ "$OUTPUT" = 'fifo' ]; then
			echo "$PACKAGE" >"${DIR_TEMP}/output"
			echo "$TYPE" >"${DIR_TEMP}/output"
			[ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//' >"${DIR_TEMP}/output"
			[ -e ${DIR_LIST}/${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${DIR_LIST}/${BASENAME}.${EXT_HASH} >"${DIR_TEMP}/output"
			[ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//' >"${DIR_TEMP}/output"
		elif [ "$OUTPUT" = 'text' ]; then
			printf "${BLUE}%-30s ${GREY}%-49s\n" "$PACKAGE" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//' | head -c 48)"
			printf "${TEAL}%40s ${CYAN}%-5s ${DARKGREY}%-32s${NORMAL}\n" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//')" " $TYPE" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${DIR_LIST}/${BASENAME}.${EXT_HASH})"
		elif [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ]; then
			showMsg 'package' "$PACKAGE" 'screen' 1 4
			showMsg 'type' "$TYPE" 'screen'
			showMsg 'version' "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//')" 'screen'
			showMsg 'hash' "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${DIR_LIST}/${BASENAME}.${EXT_HASH})" 'screen'
			showMsg 'description' "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//')" 'screen'
		fi
	done
	[ "$OUTPUT" = 'text' ] && echo -e "${NORMAL}"
# REMOVED 2025/12/03 - this is the exit code below
#	( [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ] ) && showMsg 'success' "" 'screen' 1 6

elif [ "$OPEN" ]; then
	if [ -e "${FIFO_SERVER}" ] && [ ! "FORCE" ]; then
		showMsg 'failure' "Pax is already running in this mode." 'screen'
		exit 1
	elif [ ! -e "${FIFO_SERVER}" ]; then
		mknod -m 700 "${FIFO_SERVER}" p || {
			showMsg 'failure' "The FIFO could not be created." 'screen'
			exit 1
		}
	fi

	while true; do
		if read LINE <"${FIFO_SERVER}" 2>>"$LOG_ERRS"; then
			[ "$LINE" == 'quit' ] && break
			showMsg 'start' "\n\n------- [ FIFO: Script Execution ] -------" 'log'
			showMsg 'start' "           $(date +'%Y-%m-%d  %H:%M:%S')\n" 'log'
			showMsg 'action' "EXECUTE: $LINE" 'both'
			( echo "$LINE" | grep -q ^'pax ' ) || {					# first check to make sure that it's a pax command that's getting issued
				showMsg 'failure' "An invalid command was attempted." 'both'
				continue
			}
			( echo "$LINE" | grep -qE '(;|&&|\|\|)' ) && {				# now check that (malicious) chained commands aren't passed (e.g. 'pax ... && rm -Rf /')
				showMsg 'failure' "An invalid command was attempted." 'both'
				continue
			}
			$LINE
		fi
	done
	showMsg 'action' "Shutting down the client communication..." 'both'
	rm -f "${FIFO_SERVER}" 2>>"$LOG_ERRS"

# now move the proxy files to the external storage device
elif [ "$PROXY" ]; then
# UPDATED 2025/10/28
#	( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "Creating the proxy information: "
# UPDATED 2025/10/31
#	showMsg 'action' "Creating the proxy information:" 'screen' 1 0 0 1
	showMsg 'action' "Implementing the proxy..." 'both' 1 4

	showMsg 'step' "   [1/3] Checking the directory:" 'both' 0 3			# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
	if [ -d "${PROXY}/pax" ]; then
		showMsg 'step' " [exists]" 'both' 1 5
	else
		showMsg 'step' " [creating]" 'both' 0 0
# UPDATED 2025/10/28
#		mkdir -p "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The proxy directory does not exist and could not be created." >>"$LOG_ERRS"; exitGracefully 1; }
# UPDATED 2025/10/31
#		mkdir -p "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The proxy directory does not exist and could not be created." 'log'; exitGracefully 1 'action' 'screen' 2; }
		mkdir -p "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'action'
		showMsg 'step' " [done]" 'both' 1 5
	fi

	showMsg 'step' "   [2/3] Moving proxy.sh script:" 'both' 0 3			# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
# UPDATED 2025/10/23 - since the script contains the actions to take (e.g. download or copy), the script must be copied everytime; this is also helpful if its contents get updated in a future version to not have stale versions of it
#	if [ -e "${DIR_TEMP}/proxy.sh" ]; then							# if the script isn't already on the storage device, then copy it!
# UPDATED 2025/10/28
#		mv "${DIR_TEMP}/proxy.sh" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The device mount point is not writable or invalid." >>"$LOG_ERRS"; exitGracefully 1; }
# UPDATED 2025/10/31
#		mv "${DIR_TEMP}/proxy.sh" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The device mount point is not writable or invalid." 'log'; exitGracefully 1 'action' 'screen' 2; }
		mv "${DIR_TEMP}/proxy.sh" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'action'
#	fi
	showMsg 'step' " [done]" 'both' 1 5
	showMsg 'step' "   [3/3] Moving the proxy list :" 'both' 0 3			# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
# UPDATED 2025/10/28 - to prevent prior proxy contamination, we need to move the list over every time
#	if [ ! -e "${PROXY}/pax/proxy.list" ]; then						# if the list isn't, then move it!
#		mv "${DIR_TEMP}/proxy.list" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The device mount point is not writable or invalid." >>"$LOG_ERRS"; exitGracefully 1; }
# UPDATED 2025/10/31
#		mv "${DIR_TEMP}/proxy.list" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The device mount point is not writable or invalid." 'log'; exitGracefully 1 'action' 'screen' 2; }
		mv "${DIR_TEMP}/proxy.list" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'action'
#	else											# otherwise, there is so lets add to it!
#		cat "${DIR_TEMP}/proxy.list" >> "${PROXY}/pax/proxy.list" 2>>"$LOG_ERRS" || { echo "ERROR: The device mount point is not writable or invalid." >>"$LOG_ERRS"; exitGracefully 1; }
#		rm "${DIR_TEMP}/pax/proxy.list" >>"$LOG_ERRS" 2>&1
#	fi
	showMsg 'step' " [done]" 'both' 1 5

# UPDATED 2025/10/28
#	echo " [done]"
#	echo
#	echo "On another device execute the 'pax/proxy.sh' script that was just created on the"
#	echo "removable media to obtain the desired package(s).  Return to this device and use"
#	echo "pax to install the files placed on the removable media into this OS."
#	echo
# UPDATED 2025/10/31
#	showMsg 'action' " [done]" 'screen' 0 4
#	showMsg 'note' "\nOn another device execute the 'pax/proxy.sh' script that was just created on the\nremovable media to obtain the desired package(s).  Return to this device and use\npax to install the files placed on the removable media into this OS.\n"
	showMsg 'note' "\nOn another device execute the 'pax/proxy.sh' script that was just created on the\nremovable media to obtain the desired package(s).  Return to this device and use\npax to install the files placed on the removable media into this OS.\n" 'both' 1 2 1
	showMsg 'success' "" 'both' 1 6
# REMOVED 2025/11/20
#	exitGracefully 0
elif [ "$TREE" ]; then
	# if we need to show which packages are reliant upon the ones passed, then...
	if [ "$TREE" = 'reliant' ] && [ ! "$1" ]; then					# if we need to process ALL installed packages, then...		NOTE: the first 'while' loop for this action is used to process specific PASSED packages
				for PACKAGE in $(ls -1 *.${EXT_SOFT}); do				# cycle each package to see what other packages depend on it
					splitName "$PACKAGE"
					showMsg 'package' "${PACKAGE} (${FILETYPE})" 'screen' 1 4

					for FILE in $(grep -lE ^"(${BASENAME}|${FILENAME})" *.${EXT_DEPS}); do
						splitName "$FILE" "$EXT_DEPS"
						showMsg 'file' "   (${FILETYPE}) ${PACKAGE}" 'screen' 1 4
					done
				done
	fi
elif [ "$UNLOAD" ]; then
	[ ! "$FORCE" ] && showMsg 'action' "Removing packages that can't be unloaded..." 'both' 1 4

	UNLOAD="${UNLOAD}2"							# indicate we are in the second stage of the unload process

	# finalize the packages to unload
	for FILE in $(cat "${DIR_TEMP}/unload.${EXEID}"); do					# for each package listed for removal (in the unload list from processDependencies() above)...
		[ "$FORCE" ] && continue							# if the action is being forced, then we need to remove everything
		( grep -q "$FILE" "${DIR_TEMP}/unload.${EXEID}" ) || continue			# if we've removed files from the unload list in the below 'while [ "$DEPENDENCY" ]; do' section, then this skips their processing
												# NOTE: we have to include the above line since the 'cat' call in the above 'for' loop will retain all the ORIGINAL values of the text file, not the removals of the 'while' below!
		[ $DEBUG -gt 0 ] && echo -e "Body (final):\n\tFILE        |${FILE}|" >>"$LOG_DBUG"

		for DEPFILE in $(grep -Hl "$FILE" "${DIR_LIST}/"*.${EXT_DEPS}); do				#   for each .deps file that contains the package (in REPO_SOURCE)...
#			TEMP="${FILE_SCHEMA#*\}}"						#   remove just the package name portion from the package filename 'schema' - everything before the first '}' character
#			eval TEMP="${TEMP}.${EXT_DEPS}"						#   combine the 'schema' (less the package name) values and the file extension value (e.g. i32.bin.soft)
#			DEPNAME="$(echo $DEPFILE | sed "s/${TEMP}//")"				#   remove that combination from the passed package name (in case it was passed like bash.i32.bin.soft) to isolate just the package name (e.g. bash)
			DEPBASE="$(echo $DEPFILE | sed "s/.${EXT_DEPS}$//")"			#   remove the file extension from the name
#			DEPTYPE="$(echo "$DEPFILE" | grep -oE '[\._\-](bin|dev|doc|drv|gir|lib|loc)' | sed -E 's/^[\._\-]//')"	# search for any variation of known type abbreviations and remove the preceeding separation character
#			[ "$DEPTYPE" = '' ] && DEPTYPE='bin'					#   if the line above did not return any value, then default to 'bin'

			( grep -q ^"$DEPBASE" "${DIR_TEMP}/unload.${EXEID}" ) && continue	#      if the corresponding .soft file of the iterated .deps file, is also listed for removal (in the unload list), then we need to unload so leave it in the list and go to the next DEPFILE
												#      otherwise a package that is NOT being unloaded still needs this package, so we can't unload it
# UPDATED 2025/11/17
#			[ $DEBUG -gt 0 ] && echo -e "\tRemoving:    ${FILE} from unload list; ${DEPBASE}.${EXT_SOFT} depends on it" >>"$LOG_DBUG"
			[ $DEBUG -gt 0 ] && echo -e "\tOther installed packages depend on ${FILE},\n\tprocessing its dependencies for removal from the unload list..." >>"$LOG_DBUG"
			processDependencies ${FILE}					#         store all it's dependencies

			[ $DEBUG -gt 0 ] && echo -e "Body (final - returned):\n\tFILE        |${FILE}|\n\tRemoving ${FILE} and its dependencies from the unload list..." >>"$LOG_DBUG"
# UPDATED 2025/11/17
#			while [ "$DEPENDENCY" ] && [ $INDEX -gt 0 ]; do			#         and delete them from the removal list (the unload list)
			while [ "$DEPENDENCY" ]; do					#         and delete them from the removal list (the unload list)
				sed -i "s/^${DEPENDENCY}//;/^$/d" "${DIR_TEMP}/unload.${EXEID}"
				deleteDependency TRUE
			done

			break									# we only need to check that one other installed, unmarked package depends on the iterated package, so we can exit the inner 'for' loop
		done
	done

	if ( [ $DEBUG -gt 1 ] || [ "$PROMPT" ] ); then
		showMsg 'action' "The following package(s) will be unloaded:" 'both' 1 4
		cat "${DIR_TEMP}/unload.${EXEID}"

		showMsg 'prompt' "   Do you want to proceed with the action? [Y/N] (N): " 'both' 0 1 1
		[ "$OUTPUT" = 'fifo' ] && read <"$FIFO_SERVER" || read
		( [ "$REPLY" = 'N' ] || [ "$REPLY" = 'n' ] || [ "$REPLY" = '' ] ) && exitGracefully 0 'both' 6 'success'
		echo >>"$LOG_ERRS"
	fi

	showMsg 'action' "Unloading packages remaining in the list..." 'both' 1 4
	for FILE in $(cat "${DIR_TEMP}/unload.${EXEID}"); do					# for each package remaining in the list for removal...
		unloadPackage $FILE || exitGracefully 4 'screen' 5 'step'				#   unload it
	done
fi


echo DBUG
exitGracefully 0 'both' 6 'success'


# now update the system that all the packages contents have been installed
# REMOVED 2025/12/01
#if [ "$INSTALL" ] || [ "$RESTORE" ] || [ "$UNLOAD" ]; then					# since these are the only ACTIONs that would require the system to be updated...
if [ "$INSTALL" ] || [ "$UNLOAD" ]; then					# since these are the only ACTIONs that would require the system to be updated...
	# if any processing so far has determined that a package(s) have kernel modules to process, then...			  NOTE: no need for 'sudo' when booting since the user is root at that time
	if [ "$MODULES" ]; then
		[ $DEBUG -gt 0 ] && echo -e '\tThere are kernel modules to (un)install...' >>"$LOG_DBUG"
		/sbin/depmod -a >>"$LOG_ERRS" 2>&1
		/sbin/udevadm trigger >>"$LOG_ERRS" 2>&1
	fi
	if [ "$LIBRARIES" ]; then
		[ $DEBUG -gt 0 ] && echo -e '\tThere are dynamic libraries to (un)install...' >>"$LOG_DBUG"
		/sbin/ldconfig >>"$LOG_ERRS" 2>&1
	fi
fi

# now call any marker/service scripts (if not unloading which is handled in unloadPackage())
# REMOVED 2025/12/01
#if [ "$INSTALL" ] || [ "$RESTORE" ]; then
if [ "$INSTALL" ]; then
	if [ -s ${DIR_TEMP}/installs.list ]; then
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Running deferred install scripts..." | tee -a "$LOG_ERRS"
		showMsg 'action' "Running deferred install scripts..."
# UPDATED 2025/10/22 - no longer using APP* variables
#		for APPFILE in $(cat ${DIR_TEMP}/installs.list); do
#			echo "$APPFILE" | tee -a "$LOG_ERRS"
#			"$APPFILE" 2>&1 | tee -a "$LOG_ERRS"
		for FILE in $(cat ${DIR_TEMP}/installs.list); do
			echo "$FILE" | tee -a "$LOG_ERRS"
			"$FILE" 2>&1 | tee -a "$LOG_ERRS"
		done
		rm -f ${DIR_TEMP}/installs.list 2>>"$LOG_ERRS"
	fi
	# NOTE: these are two separate 'if' statements on purpose!
	if [ -s ${DIR_TEMP}/services.list ]; then
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Running deferred service scripts..." | tee -a "$LOG_ERRS"
		showMsg 'action' "Running deferred service scripts..."
# UPDATED 2025/10/22 - no longer using APP* variables
#		for APPFILE in $(cat ${DIR_TEMP}/services.list); do
#			echo "$APPFILE" | tee -a "$LOG_ERRS"
#			"$APPFILE" start 2>&1 | tee -a "$LOG_ERRS"
		for FILE in $(cat ${DIR_TEMP}/services.list); do
			echo "$FILE" | tee -a "$LOG_ERRS"
			"$FILE" start 2>&1 | tee -a "$LOG_ERRS"
		done
		rm -f ${DIR_TEMP}/services.list 2>>"$LOG_ERRS"
	fi
fi

# UPDATED 2025/11/19
#exitGracefully 0
exitGracefully 0 'both' 6 'success'


#LEFT OFF

#pax
#implement -p and -O (don't load during booting unless debug>0)			show OUTPUT (screen,log,both) MESSAGE
#instituting EXT_* vars, left off @ split name()
#	use TYPE for APPTYPE (since that's set via switches)

#
#   Outstanding (LEFT OFF)
#	dependency.i32.lib.soft[1.2.3-2.3.1]				package requires within this range of version numbers of this dependency
#	dependency.i32.lib.soft[>1.2.3] or [1.2.3+]			package requires a version greater than or equal to stated of this dependency
#	dependency.i32.lib.soft[<1.2.3] or [1.2.3-]			package requires a version less or equal to than stated of this dependency
#	dependency.i32.lib.soft[=1.2.3] or [1.2.3!]	(implemented)	package requires this exact version of this dependency and will fail if not currently installed; useful for upgrading web.de themes to make sure web.de itself is at a certain version for compatibility
#	dependency.i64.bin.soft|dependency2.i64.bin.soft|...		package requires any of these dependencies (e.g. thttpd,apache,paged,...)	NOTE: should be in order of preference by OEM; (e.g. TC - size to keep overall size of system down)
#	dependency.i64.bin.soft{file1,file2,file3,...}			package requires only certain files from the dependency


# TESTS
# cd ~/Projects/Scripts/pax
# sudo su root
# cp -dpR TESTING/* /tmp
# exit
# cd /tmp
# pax -S /tmp -c zip zipperityduda zebra4/			can incorporate .deps.err files to check that errors occur corrently
# pax -e zip zebra4/
# pax -e zebra6/
# pax -e zip[.i64.bin.soft] zlib_base[.i64.dev.soft]
# pax -O fifo -e zip zlib_base
# pax -O xml -e zip[.i64.bin.soft] zlib_base
# pax -l
# pax -l zip zlib
# pax -m ASDF /tmp/zebra2
# pax -O fifo -m ASDF /tmp/zebra2
# pax -O xml -m ASDF /tmp/zebra2
# pax -X /tmp/zebra5/ -d zip
# pax -O fifo -X /tmp/zebra5/ -d zip
# pax -O xml -X /tmp/zebra5/ -d zip
# pax -t libreoffice
# pax -O fifo -t libreoffice
# pax -O xml -t libreoffice


#LATEST=							< LEFT OFF - this can be used so the latest version of a branch can be downloaded (e.g. pax -i apache -V 2.2.LATEST)



#builer
#- expand -i to take 'root' (/etc/builder/...) or 'home' (~/.etc/builder/...)
#- get script to check in XSB and LSB directories




# 'sudo pax -v data compiletc' does not work

# ask where to install: system (/), everyone (/Users/Public/.{bin|sbin|lib|...}), personal (/Users/$USER/.{bin|sbin|lib|...})		NOTE: there are no sbin's any more; also /Users/Public is for system-wide usage WITHOUT having elevated installation credentials (compared to system installations to /)
#	how do we address where to install during boot?		maybe utilize .list files for this?

# file	description				these are files included in the root of the package			OR, just have the install script put a file somewher indicating a device reboot (since that's the only meaningful follow-up; services already restart)
# -------------------				the files would be good to indicate beforehand packages that would require a reboot so the user can choose whether to install them or not
# .pre	checks that the account has permission to install the value
#	Example values: group	advanced	(to indicate the user needs to be a member of the 'advanced' group to install this package; can issue UI prompt for elevated account status)
#			location /
#
# .post	indicates any actions required post-install
#	Example values: device	reboot		(to indicate that a reboot is neccessary to complete install)
#			service	restart		(to indicate a service needs to restart)
#
# .reboot	indicates the package will require a reboot

