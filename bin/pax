#!/bin/sh
# pax		a package management system that allows the (un)loading of
#		(pre-compiled) software packages for the (XiniX) OS
#
# created	2016/08/08 by Dave Henderson (support@cliquesoft.org)
# updated	2026/01/15 by Dave Henderson (support@cliquesoft.org)
#
# Unless a valid Cliquesoft Private License (CPLv1) has been purchased for your
# device, this software is licensed under the Cliquesoft Public License (CPLv2)
# as found on the Cliquesoft website at www.cliquesoft.org.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the appropriate Cliquesoft License for details.
#
# NOTES
# - The types of packages include:
#	app	application (installer)
# 	bin	binaries
# 	dev	development
# 	doc	documentation
#	drv	drivers
#	gir	GObject
# 	lib	libraries
# 	loc	locales
#	msc	miscellaneous
#	src	source
#
# - The package extensions include:
#	code	source code
#	core	core OS package
#	cpio	ramdisk image
#	deps	dependencies list
#	hash	validation hash
#	info	package information
#	list	manifest list
#	make	compile script
#	newr	update available
#	soft	software files
#
# - The .deps files can use the following syntax:
#	dependency.i64.bin.soft						package requires this dependency (any version)
#	dependency.i32.lib.soft[1.2.3]					package requires the stated version of this dependency and will install it beside any other version; useful for software requiring different lib versions (e.g. sdl)
#	[dependency.r64.drv.soft|optional.i64.bin.soft]			package can optionally install this dependency if the device also has 'optional' installed




# PREVENT CONTAMINATION

unset COPY DOWNLOAD EXTRACT FIND INSTALL LIST MAKE OPEN TREE UNLOAD VALIDATE BOOTING ARCH DEPS EXTRA FORCE IGNORE KERNEL PACKLIST MODE FILELIST OUTPUT PROMPT QUIET RESTORE REPO_SOURCE TYPE VERSION PROXY DRYRUN




# DEFAULT VARIABLE DEFINITIONS

DEBUG=0												# NOTE: making this a '2' will enable prompts

LIST_BOOT='$( TEMP=$(getBootcode list); ( [ "$TEMP" ] && [ -e "${REPO_PREFIX}/${TEMP}" ] ) && echo $TEMP )'					# obtains and tests for the existence of the 'list' boot code value; is blank otherwise (e.g. process the REPO_SYSTEM)
LIST_LIVE='$( TEMP=$(getBootcode list2); ( [ "$TEMP" ] && [ -e "${REPO_PREFIX}/${TEMP}" ] ) && echo $TEMP || echo optional.list )'		# obtains and tests for the existence of the 'list2' boot code value -OR- uses a default otherwise
FLAG_BOOT='${LIST_BOOT%.*}.flag'								# the flag file that blacklists included packages
FLAG_LIVE='${LIST_LIVE%.*}.flag'								# the flag file that blacklists included packages
FLAG_COPY='copy_all.flag'									# the flag file indicating ALL packages need to be copied instead of symlinked
FLAG_FIRM='copy_sys.flag'									# the flag file indicating ALL firmware packages (REPO_SYSTEM|LIST_BOOT) need to be copied instead of symlinked

DIR_CONF='/etc/pax'										# directory containing any alternate/personalized configuration
DIR_LIST='/var/cache/software/catalog'								# directory containing the total list of installed applications
DIR_INIT='/var/cache/software/services'								# directory containing daemon/service scripts
DIR_INST='/var/cache/software/scripts'								# directory containing other software scripts (taken from /etc/envars)
DIR_LIVE='/Users/Public/.'									# directory to install by default after bootup	NOTE: this needs to end with a '/' or '.' (so that the packages files can be (un)installed from home directories)
DIR_LOGS='/var/log'
DIR_LOOP='/Mounts/.software'									# directory that symlinked software needs to use as mountpoint
DIR_TEMP='/tmp/pax'

EXT_CORE='core'											# [text file] package core OS marker
EXT_CODE='code'											# [tgz file]  package source code
EXT_DEPS='deps'											# [text file] package dependency list
EXT_HASH='hash'											# [text file] package validation hash
EXT_INFO='info'											# [text file] package information
EXT_LIST='list'											# [text file] package manifest list
EXT_MAKE='make'											# [text file] package make commands
EXT_SOFT='soft'											# [mksquashfs file] packaged compiled software

LOG_DBUG="${DIR_LOGS}/pax.debug"								# the log file for debug output
LOG_ERRS="${DIR_LOGS}/pax.log"									# the log file for error output

OWN_GROUP='staff'										# the default 'everyone' group that all non-admin users belong (used for default group ownership on package files/dirs)
OWN_SYSTEM='root:root'										# the ownership of the REPO_SYSTEM directory
PRM_SYSTEM='770'										# the permissions of the REPO_SYSTEM directory
						# DEV NOTE - document the below as being able to connect to a "pax server" for remote administration (e.g. FIFO_SERVER='/sshfs/directory/device_nic_mac')
FIFO_SERVER="input"										# defines the default name that the -o action should attach for (remote) commands
ARCH_VALUES='i32|i64|a32|a64'									# the valid values for the -C option

ARCH_SCHEMA="$(uname -m | sed -r 's/i386|i686/i32/;s/x86_64/i64/;s/armv7l/r32/')"		# this can be used so the .deps files can be universal - bash.ARCH.bin.soft
FILE_SCHEMA='${PACKAGE}.${TYPE}.${ARCH}'							# the format for the package filenames		NOTE: encase in single quotes so variables are NOT expanded yet
KRNL_SCHEMA="$(uname -r | sed 's/-/_/g')"							# store the currently used kernel version (substituting '-' for '_')
REPO_SCHEMA='http://repo.cliquesoft.org/vanilla/1.0/${PACKAGE/_${KERNEL}}'			# the format for remote repo package access	NOTE: save as above
VERS_SCHEMA='${VERSION}.${TYPE}.${ARCH}'							# the format of the versioned package name in the source remote repo (when -V is used)
VERT_SCHEMA='${PACKAGE}_${VERSION}.${TYPE}.${ARCH}'						# the format of the versioned package name in the target local repo (when -V is used)

REPO_PREFIX='/etc/software/SYSTEM/repo'
REPO_OPTION="${REPO_PREFIX}/optional"								# WARNING: this needs to reference 'optional' and REPO_SYSTEM needs to reference 'system'!!!
REPO_SYSTEM="${REPO_PREFIX}/system"								# if any dependency package(s) are not found in the (modified) REPO_OPTION, then check the 'base' location
REPO_RESTOR="/var/cache/Software/restore"


# -------------------- DO **NOT** EDIT BELOW THIS LINE --------------------


# [system]
EXEID="$(mktemp -u XXXXXX)"									# stores a temp execution ID (for use with (un)installing)
INDEX=0												# since no arrays can be used in this shell, this keeps track of the index within the dependency stack	NOTE: 0=no deps
TOTAL=0												# keeps track of the $DEP 'array' size
TEMP=''												# used to store information temporarily
COLORS=''											# if colors should be enabled by default (this is for setting via config file)
LIBRARIES=''											# boolean indicating libraries are contained in the package and need to be loaded after installation
MODULES=''											# boolean indicating kernel modules are contained in the package and need to be loaded after installation
RPD=''												# the Restore Point Directory
XML=''												# used to store XML until there's a final success/failure
XML_TAGS=''											# stores the tags that are currently opened (e.g. containing children)

# [names]
PARAMETER=''
DIRECTORY=''											# defaults to REPO_OPTION if not passed as DIRECTORY parameter
DEPENDENCY=''											# the current iterated dependency to work with
PACKAGE=''											# the isolated name of the package (e.g. nano.bin.i32.soft > nano); value set automatically below
BASENAME=''											# the filename without the extension (e.g. nano.bin.i32); value set automatically below
FILENAME=''											# the full filename of the package (e.g. nano.bin.i32.soft); value set automatically below
FILETYPE=''											# the file type that is being processed (this is used by processDependencies())
OPTFILE=''
VERBASE=''
VERFILE=''

# [colors]
NORMAL=''
BLINK=''
INVERSE=''
HIDE=''
UL=''

BLACK=''
GARNET=''
GREEN=''
BROWN=''
NAVY=''
MAGENTA=''
TEAL=''
DARKGREY=''
GREY=''
RED=''
LIME=''
YELLOW=''
BLUE=''
PURPLE=''
CYAN=''
WHITE=''

# [actions]
COPY=''
DOWNLOAD=''
EXTRACT=''
FIND=''
INSTALL=''
LIST=''
MAKE=''
OPEN=''
TREE=''
UNLOAD=''
VALIDATE=''

# [options]
BOOTING=''
ARCH=''												# stores the value of the ARCH_SCHEMA
DEPS=''
EXTRA=''
FORCE=''
IGNORE=''
KERNEL=''											# stores the currently used kernel string
PACKLIST=''
MODE=''												# the install mode: (sym)link, copy	NOTE: this is auto configured in the body
FILELIST=''
OUTPUT='text'											# the output format to display: fifo, text, xml, xmLive
PROMPT=''
QUIET='default'											# the verbosity of the output: none, errors, default, verbose, all
RESTORE=''
REPO_SOURCE=''											# if the user passed a new source via -S; defaults to REPO_OPTION if not passed			NOTE: we can NOT define a default value here since it may be different in a config file
TYPE='bin'											# the package type: bin dev doc drv gir lib loc	  NOTE: we're specifying the default value here
VERSION=''
PROXY=''
DRYRUN=''




# -------------------------------------------------------------------------




# DEFINE BUILT-IN FUNCTIONS FOR EXPORT




# DEFINE BUILT-IN FUNCTIONS FOR INTERNAL USE

# Usage syntax: exitGracefully [EXIT] [TARGET] [TAGS] [TAG]
# Overview:	allows the script the terminate gracefully
# Parameters:
# EXIT		[number] [optional] the exit status of this script afterwards
#			0 = success (default)
#			1 = failure without printing anything
#			2 = failure printing a generic message
#			3 = failure with printing ' [failure]'
#			4 = failure printing ' [failure]' and generic message
#			    NOTES:
#			    - the TAG should be passed to close XML
#			    - the TAGS value does not get passed through
# TARGET	[string] [optional] the TARGET value to send to showMsg
# TAGS		[number] [optional] the TAGS value to send to showMsg
# TAG		[string] [optional] the TAG value to send to showMsg
exitGracefully() {
	find "$DIR_TEMP" ! -type p -size 0 -print0 | xargs -0 rm 2>/dev/null			# remove any blank cache file	https://stackoverflow.com/questions/3157343/how-to-delete-many-0-byte-files-in-linux

	[ $DEBUG -eq 0 ] && [ -e "${DIR_TEMP}/installs.${EXEID}" ] && rm -f "${DIR_TEMP}/installs.${EXEID}" 2>/dev/null				# remove any installation temp files
	[ $DEBUG -eq 0 ] && [ -e "${DIR_TEMP}/services.${EXEID}" ] && rm -f "${DIR_TEMP}/services.${EXEID}" 2>/dev/null
	[ $DEBUG -eq 0 ] && [ -e "${DIR_TEMP}/filelist.${EXEID}" ] && rm -f "${DIR_TEMP}/filelist.${EXEID}" 2>/dev/null
	[ $DEBUG -eq 0 ] && [ -e "${DIR_TEMP}/unload.${EXEID}" ] && rm -f "${DIR_TEMP}/unload.${EXEID}" 2>/dev/null
	[ $DEBUG -eq 0 ] && [ -e "${DIR_TEMP}/unloaded.${EXEID}" ] && rm -f "${DIR_TEMP}/unloaded.${EXEID}" 2>/dev/null
	[ "$MODE" = 'copy' ] && [ $1 -gt 0 ] && ( /bin/mount 2>>"$LOG_ERRS" | grep -q "${DIR_LOOP}/${BASENAME} type squashfs" ) && sudo /bin/umount -d "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1	# if we're copying and an error was encountered, then umount the package

	( [ ! "$1" ] || [ $1 -eq 0 ] ) && {
		[ "$4" ] && showMsg "$4" '' "$2" 1 $3
		exit 0
	}

	[ $1 -gt 2 ] && {
		[ ! "$4" ] && showMsg 'failure' ' [failure]' "$2" 1 "$3"
		[ "$4" ] && showMsg "$4" ' [failure]' "$2" 1 5
	}
	( [ $1 -eq 2 ] || [ $1 -eq 4 ] ) && {
		[ ! "$4" ] && showMsg 'failure' 'An error occurred while processing your request.' "$2" 1 "$3"
		[ "$4" ] && showMsg 'failure' 'An error occurred while processing your request.' "$2" 1 6
	}
	exit $1
}


# Usage syntax: checkBootcode CODE
# Overview:	checks if a passed boot code was specified
# Parameters:
# CODE		[string] the name of the boot code to check for
checkBootcode() {
	cat /proc/cmdline | grep -qoE "${1}=[^ ]*" && return 0
	return 1
}


# Usage syntax: getBootcode CODE
# Overview:	stores the value of a passed boot code in $VALUE, or blank otherwise
# Parameters:
# CODE		[string] the name of the boot code to return its value
getBootcode() {
	cat /proc/cmdline | grep -oE "${1}=[^ ]*" | sed 's/.*=//'
	return 0
}


# Usage syntax: showMsg TAG MESSAGE [TARGET] [CR] [TAGS] [TRIM]
# Overview:	sends message to the target in the desired format
# Parameters:
# TAG		[string] the XML tag surrounding the message
#		[ NOTE ]
#			 - this value can be 'success' or 'failure' to a quick '<s><msg>MESSAGE</msg></s>' (or corresponding fail)
#			 - the * represents whatever you pass as the value becomes the XML tag (e.g. 'step' becomes <step>...</step>)
#			 - the * has no effect for plain text
# MESSAGE	[string] the message to display/store
# TARGET	[string] [optional] the target output: both (default), log, screen
#		[ NOTE ]
#			- if DEBUG>0 then 'log' will output to that log also
# CR		[boolean][optional] if the prompt needs to add a character return at the end [0=no, 1=yes (default)]
# TAGS		[number] [optional] defines XML tag encapsulation (default=1)
#		[ NOTE ]
#			 0 = none
#			 1 = on (one set of tags)	line 1		to	<TAG>line 1
#							line 2			      line 2</TAG>
#			 2 = on (tags for each line)	line 1		to	<TAG>line 1</TAG>
#							line 2			<TAG>line 2</TAG>
#			 3 = on (parent open) 		title		to	<TAG>title
#			 4 = on (parent alt open)	title		to	<TAG tag='title'>
#			 5 = on (parent close)		title		to	</TAG>		NOTE: this is ignored when OUTPUT='text'
#			 6 = on (closes all open)
# TRIM		[boolean][optional] if the output needs to be trimmed of spaces, tabs, newlines at the beginning and end (default=off)
showMsg() {
	local LINE=''
	local ITEM=''
	local PREFIX=''
	local SUFFIX=''
	local TAG="$1"
	local MSG="$2"
	local TARGET='both'
	local CR=''
	local TAGS=1
	local TRIM=0
	local TEMP=''

	# DEFINE DEFAULT VALUES
	[ "$3" ] && [ "$3" != '' ] && TARGET="$3"						# NOTE: we had to include the "!= ''" condition for exitGracefully (since it can pass a blank value)
	[ "$4" ] && [ $4 -eq 0 ] && CR="n"
	[ "$5" ] && TAGS=$5
	[ "$6" ] && TRIM=$6

	# MAKE VARIABLE CHANGES
	[ "$TAG" = 'failure' ] && TEMP='ERROR: '						# this needs to execute regardless of OUTPUT value since this is for the logs
	[ "$TAG" = 'warning' ] && TEMP='ALERT: '						# this needs to execute regardless of OUTPUT value since this is for the logs

	# OUTPUT TO LOG
	[ "$TARGET" != 'screen' ] && {
		echo -e${CR} "${TEMP}${2}" | sed 's/{COLOR}//' >>"$LOG_ERRS"			# writes to log if value is: both, log		NOTE: we use $2 instead of $MSG to prevent '<br />' contamination; {COLOR} is used to prevent codes from leaking into the logs
		[ $DEBUG -gt 0 ] && [ "$TARGET" = 'log' ] && echo -e${CR} "${TEMP}${2}" | sed 's/{COLOR}//' >>"$LOG_DBUG"
		[ "$TARGET" = 'log' ] && return 1						# if we're only logging messages, then we can exit
	}

	[ "$QUIET" = 'all' ] && [ "$TAG" != 'success' ] && return 1				# if we need to supress all visual output (except succes to close XML tags), then only write to the log if desired
	[ "$QUIET" = 'errors' ] && [ "$TAG" != 'success' ] && [ "$TAG" != 'failure' ] && return 1						# if we need to only show errors (or success to close XML tags), but this isn't one of them, then exit (writing to the log if desired)
	[ "$QUIET" = 'default' ] && ( [ "$TAG" = 'dependency' ] || [ "$TAG" = 'duplicate' ] ) && return 1					# if we need to show most output (success,failure,warning,notice,issue,note,location,package,directory,file,action,step,prompt), otherwise exit (writing to the log if desired)
	[ "$QUIET" = 'verbose' ] && [ "$TAG" = 'duplicate' ] && return 1			# if we need to show everything but duplicates (warnings,dependency), then exit (writing to the log if desired)

	# ADJUST MESSAGE AND OUTPUT TO SCREEN
	if [ "$OUTPUT" = 'fifo' ]; then
		[ $TAGS -eq 6 ] && return 1

		[ "$TAG" = 'failure' ] && [ "$MSG" != ' [failure]' ] && PREFIX='ERROR: '	# NOTE: the MSG comparison is so that if exitGracefully() was called, then we don't need the prefix
		IFS=$'\n'
		for LINE in $(echo -e "${PREFIX}${MSG}${SUFFIX}"); do				# convert a multi-line MESSAGE (e.g. 'LINE1\nLINE2') into separate 'echo' calls
			echo "$LINE" | sed 's/^\s*//;s/\s*$//' >"${DIR_TEMP}/output"		# also strip pre/post spacing (spaces, tabs) since FIFO's can't handle any of this
		done
	elif [ "$OUTPUT" = 'text' ]; then
		[ $TAGS -eq 6 ] && return 1

		[ "${NORMAL}" ] && TEMP="\\\\${NORMAL}" || TEMP=''
		MSG="$(echo "$MSG" | sed "s/{COLOR}/${TEMP}/")"					# the package name color in the processDependencies() output; this is so that color codes don't get into the logs
		[ "$TAG" = 'failure' ] && [ "$MSG" = ' [failure]' ] && PREFIX="${RED}"
		[ "$TAG" = 'failure' ] && [ "$MSG" != ' [failure]' ] && PREFIX="${RED}ERROR: ${NORMAL}"	# NOTE: the MSG comparison is so that if exitGracefully() was called, then we don't need the prefix
		[ "$TAG" = 'success' ] && PREFIX="${GREEN}"
		[ "$TAG" = 'warning' ] && PREFIX="${YELLOW}"
		[ "$TAG" = 'notice' ] && PREFIX="${PURPLE}"					# [dryrun], [overwrite]
		[ "$TAG" = 'action' ] && PREFIX="${TEAL}"					# Processing dependencies for the package...
		[ "$TAG" = 'step' ] && PREFIX="${CYAN}"						# [install], [copy], [extract], ...
		[ "$TAG" = 'location' ] && PREFIX="${PURPLE}"					# [home], [live], [root], [misc]
		[ "$TAG" = 'package' ] && PREFIX="${PURPLE}"					# (bin) zip:					< in the final action section (e.g. 'Copying files to specified location...')
		[ "$TAG" = 'directory' ] && PREFIX="${TEAL}"					# 2025-01-03:					< in the restore point listing
		[ "$TAG" = 'file' ] && PREFIX="${BLUE}"						# (bin) zip:					< in the final action section (e.g. 'Copying files to specified location...')
		[ "$TAG" = 'note' ] && PREFIX="${TEAL}"
		[ "$TAG" = 'issue' ] && ( echo "$MSG" | grep -q ^' !missing!' ) && PREFIX="${RED}"						# !missing!			in the validation checks
		[ "$TAG" = 'issue' ] && [ ! "$PREFIX" ] && PREFIX="${YELLOW}"
		[ "$TAG" = 'dependency' ] && ( echo "$MSG" | grep -q ^'\[  local  \]' ) && PREFIX="${BLUE}"
		[ "$TAG" = 'dependency' ] && ( echo "$MSG" | grep -q ^'\[ foreign \]' ) && PREFIX="${CYAN}"
		[ "$TAG" = 'dependency' ] && ( echo "$MSG" | grep -q ^'\[ BASE OS \]' ) && PREFIX="${PURPLE}"					# [SYSTEM] (dev) bash		in the 'Processing dependencies for the package...' section
		[ "$TAG" = 'dependency' ] && ( echo "$MSG" | grep -q ^'\[ optional\]' ) && PREFIX="${DARKGREY}"
		[ "$TAG" = 'dependency' ] && ( echo "$MSG" | grep -qE ^'(\[  exist  \]|\[installed\])' ) && PREFIX="${GREEN}"
		[ "$TAG" = 'dependency' ] && ( echo "$MSG" | grep -qE ^'(\[ alt dir \]|\[ ignored \]|\[ unloaded\])' ) && PREFIX="${YELLOW}"
		[ "$TAG" = 'dependency' ] && ( echo "$MSG" | grep -qE ^'(\[ account \]|\[ flagged \]|\[ missing \]|\[ Source! \])' ) && PREFIX="${RED}"
		[ "$TAG" = 'dependency' ] && [ ! "$PREFIX" ] && PREFIX="${BLUE}"
		[ "$TAG" = 'duplicate' ] && ( echo "$MSG" | grep -q ^'\[duplicate\]' ) && PREFIX="${DARKGREY}"
		echo -e${CR} "${PREFIX}${MSG}${SUFFIX}${NORMAL}"
	elif [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ]; then
		# PROCESS OPENED TAGS
		# if the tag is present after the first one in the list, then we need to close all the tags before it
		if ( echo "$XML_TAGS" | grep -qE " $TAG " ); then
			for ITEM in $(echo "$XML_TAGS"); do
				TEMP="$(echo "$XML_TAGS" | sed -E 's/ $//;s/[a-z]+/\\t/g;s/ //g')" # create the proper preceeding tabs
				XML_TAGS="$(echo "$XML_TAGS" | sed "s/^${ITEM} //")"		# remove the iterated TAG from the list
				PREFIX="${PREFIX}${TEMP}</${ITEM}>\n"				# update the PREFIX to include each closing TAG
				[ "$ITEM" = "$TAG" ] && break					# exit the 'for' as soon as we process the matching TAG
			done
		fi
		# WARNING: these are two separate 'if' statements on purpose!
		# if we're opening a new tag -AND- the tag is NOT already in the opened list, then add it to the beginning of the list
		if ( [ $TAGS -eq 3 ] || [ $TAGS -eq 4 ] ) && [ "$(echo "$XML_TAGS" | cut -f 1 -d ' ')" != "$TAG" ]; then
			XML_TAGS="$TAG $XML_TAGS"
		# if we're opening a new tag -AND- the tag IS the first one in the opened list, then close the prior one first
		elif ( [ $TAGS -eq 3 ] || [ $TAGS -eq 4 ] ) && [ "$(echo "$XML_TAGS" | cut -f 1 -d ' ')" = "$TAG" ]; then
			TEMP="$(echo "$XML_TAGS" | sed -E 's/ $//;s/[a-z]+/\\t/g;s/ //g')"
			PREFIX="${PREFIX}${TEMP}</${TAG}>\n"
		# if we're closing an open tag -AND- the tag IS the first one in the list, then delete it from the list
		elif [ $TAGS -eq 5 ] && [ "$(echo "$XML_TAGS" | cut -f 1 -d ' ')" = "$TAG" ]; then
			XML_TAGS="$(echo "$XML_TAGS" | sed "s/^${TAG} //")"
		fi

		# PROCESS TAG AND INDENTATION							  NOTE: this MUST come below the 'PROCESS OPENED TAGS' section
		TEMP="$(echo "$XML_TAGS" | sed -E 's/ $//;s/[a-z]+/\\t/g;s/ //g')"

		[ "$XML_TAGS" ] && [ $TAGS -lt 3 ] && TEMP="\t${TEMP}"
		case "$TAGS" in
			0)	PREFIX=''							# if no tags are to be displayed (e.g. the MESSAGE contains them)
				SUFFIX=''
				;;
			1|2)	PREFIX="${PREFIX}${TEMP}<${TAG}>"				# if both opening and closing tags need to be displayed
				SUFFIX="</${TAG}>"
				;;
			3)	[ ! "$CR" ] && PREFIX="${PREFIX}${TEMP}<${TAG}>\n${TEMP}\t"	# if only the opening tag needs to be displayed
				[ "$CR" ] && PREFIX="${PREFIX}${TEMP}<${TAG}>"			#   WARNING: the CR detection here is backwards since a value of 'n' means NOT to CR!
				SUFFIX=''
				;;
			4)	PREFIX="${PREFIX}${TEMP}<${TAG} tag=\"$(echo -e "$2" | sed 's|^\s*||;s|\s*$||;/^$/d')\">"			# if only the alt opening tag needs to be displayed
				SUFFIX=''
				MSG=''								#   erase this value since it's already been added to the output
				;;
			5)	PREFIX=''							# if only the closing tag needs to be displayed; this is typically used to close an open tag on the same line (e.g. "<action>Doing some action: [done]</action>")
				SUFFIX="</${TAG}>"
				;;
			6)	PREFIX=''							# if all the closing tags need to be displayed
				for ITEM in $(echo "$XML_TAGS"); do
					SUFFIX="${SUFFIX}${TEMP}</${ITEM}>\n"
					XML_TAGS="$(echo "$XML_TAGS" | sed "s/^${ITEM} //")"	# " (this is to return the coloring correctly in gedit)
					TEMP="$(echo "$XML_TAGS" | sed -E 's/ $//;s/[a-z]+/\\t/g;s/ //g')"
				done
				[ "$OUTPUT" = 'xml' ] && XML="${XML}${SUFFIX}"
				[ "$OUTPUT" = 'xmLive' ] && SUFFIX="$(echo "${SUFFIX}" | sed 's/\\n$//')"					# cleans up trailing blank line in output
				;;
		esac

		# APPLY TRIM AND TAG ENCAPSULATE
		if [ $TRIM -eq 0 ]; then							# if we're leaving the output untrimmed, then...
			[ $TAGS -lt 2 ] && MSG="$(echo "$MSG" | sed ':a;N;$!ba;s|\n|<br />|g')"	# replace any CR's with <br />'s		https://stackoverflow.com/questions/1251999/how-can-i-replace-each-newline-n-with-a-space-using-sed
			[ $TAGS -eq 2 ] && MSG="$(echo "$MSG" | sed ":a;N;\$!ba;s|\n|${SUFFIX}\n${PREFIX}|g")"	# replace any CR's with XML tags (plus indentation)
		else										# otherwise, do the same as above, but apply trimming
			[ $TAGS -lt 2 ] && {
				MSG="$(echo "$MSG" | sed 's|^\s*||;s|\s*$||')"			# trim pre/post spacing
				MSG="$(echo -e "$MSG" | sed '/^$/d')"				# removes any blank lines
				MSG="$(echo -e "$MSG" | sed ':a;N;$!ba;s|\n\s*|<br />|g')"	# convert CR's to <br />'s
			}
			[ $TAGS -eq 2 ] && {
				MSG="$(echo "$MSG" | sed "s|^\s*||;s|\s*$||")"
				MSG="$(echo -e "$MSG" | sed '/^$/d')"
				MSG="$(echo -e "$MSG" | sed ":a;N;\$!ba;s|\n\s*|${SUFFIX}\n${PREFIX}|g")"
			}
			[ $TAGS -gt 2 ] && MSG="$(echo "$MSG" | sed 's|^\s*||;s|\s*$||')"
		fi

		# PROCESS XML
		[ "$OUTPUT" = 'xmLive' ] && {
			[ "$TAG" = 'failure' ] && [ $TAGS -eq 6 ] && PREFIX='<failure>' && SUFFIX="</failure>\n${SUFFIX}"			# for exitGracefully calls that need to close open tags while still showing <failure>
			[ "$TAG" = 'failure' ] && [ "$XML_TAGS" = '' ] && PREFIX="\t${PREFIX}"							# for inline failure calls
			[ "$TAG" = 'success' ] && [ "$XML_TAGS" = '' ] && PREFIX="${PREFIX}"							# for inline failure calls
			[ "${PREFIX}${MSG}${SUFFIX}" != '' ] && echo -e${CR} "${PREFIX}${MSG}${SUFFIX}"						# to prevent blank lines from showing in output
			( [ "$TAG" = 'success' ] || [ "$TAG" = 'failure' ] || [ $TAGS -eq 6 ] ) && echo '</xml>'
		}
		if [ "$OUTPUT" = 'xml' ]; then
			if [ "$TAG" = 'success' ]; then
				( echo "$XML" | grep -q '\\n' ) && echo -e "<s>\n    <xml>\n${XML}    </xml>\n</s>" || echo -e "<s>${XML}</s>"
			elif [ "$TAG" = 'failure' ]; then
				echo -e "<f><msg>${MSG}</msg></f>"
			else
				( ( [ $TAGS -eq 3 ] || [ $TAGS -eq 0 ] ) && [ "$CR" ] ) && CR='' || CR='\n'
				XML="${XML}${PREFIX}${MSG}${SUFFIX}${CR}"
			fi
		fi
	fi
}


# Usage syntax: splitName NAME EXTENSION
# Overview:	seperates/creates the passed name into its various parts
# Parameters:
# NAME		[string] the name of the package to parse (e.g. bash.i64.dev.soft)
# EXTENSION	[string] [optional] the file extension to process (EXT_SOFT is default)
splitName() {
	local NAME="$(echo "$1" | sed 's|.*/||;s|^\s*||;s|^\+||;s|^ ||')"			# remove any directory structure and store the raw name value	NOTE: we also remove any preceeding spacing that gets injected when using -o for some reason, and '+' from addDependency(), and ' ' from processDependencies()
	local EXT="${EXT_SOFT}"
	local TEMP=''

	[ ! "$NAME" ] && {
		showMsg 'failure' "No package name was passed to splitName()." 'screen' 1 1
		return 1
	}
	[ "$2" ] && EXT="$2"

	# WARNING: this 'if' must be in this exact order to operate correctly
	OPTFILE=''										#   erase any existing value from this variable to prevent bugs
	if ( echo "$NAME" | grep -q ^'\[' ); then						# if an optional package (e.g. [xorg_3d.i32.bin.soft|xorg.bin]) was passed, then...
		VERSION=''									#   erase any existing value from this variable to prevent bugs
		OPTFILE="$(echo "$NAME" | sed 's/^\[//;s/\]$//;s/.*|//')"			#   remove the brackets and store just the optional package (xorg.bin)
		NAME="$(echo "$NAME" | sed 's/^\[//;s/\]$//;s/|.*//')"				#   remove the brackets and store just the dependency name (xorg_3d.i32.bin.soft)
	elif ( echo "$NAME" | grep -q '\]'$ ); then						# if a version number has been included (e.g. bash.bin[4.0.2]) in the name, then...
		VERSION="$(echo "$NAME" | sed 's/.*\[//;s/\]$//')"				#   store just the included version number (4.0.2)
		NAME="${NAME%%[*}"								#   remove the version number and store just the name (bash.bin)
	fi

	[ "$VERSION" ] && [ $INDEX -le 1 ] && ( echo "$NAME" | grep -q ^"$PARAMETER" ) && NAME="$PARAMETER"					# if a version number was passed -AND- we've looped back to the first package after all the script processing (since only one package can be passed with -V)

	# NOTE: this block needs to execute no matter what so that the schema's can be applied properly
	NAME="$(echo $NAME | sed "s/KERNEL/${KERNEL}/")"					# perform KERNEL substitution first thing so ALL the various names have the change
	if ( echo "$NAME" | grep -q "$EXT"$ ); then						# if the whole filename was passed, then...
		TEMP="${FILE_SCHEMA#*\}}"							#   remove just the package name portion from the package filename 'schema' - everything before the first '}' character
		TEMP="$(echo "$TEMP" | sed 's/\./\\\\\./g;s/${TYPE}/.../')"			#   escape any periods in the schema and replace TYPE with three dots (to match any TYPE - bin,dev,doc,...)
		eval TEMP="${TEMP}"								#   eval the variable to get any variable substitution done (except TYPE which was replaced by three dots)

		PACKAGE="$(echo "$NAME" | sed "s/${TEMP}\.${EXT}$//")"				#   remove the TEMP string that was just created to isolate just the package name
		BASENAME="$(echo "$NAME" | sed "s/.${EXT}$//")"					#   remove the file extension from the name and perform the KERNEL keyword substitution
		FILENAME="$NAME"
	else											# otherwise just the package name was (so no altering is necessary), so...
		PACKAGE="$NAME"
		eval BASENAME="${FILE_SCHEMA}"							#   eval the variable to get any variable substitution done
		FILENAME="${BASENAME}.${EXT}"
	fi
	FILETYPE="$(echo "$FILENAME" | grep -oE '[\._\-](bin|dev|doc|drv|gir|lib|loc)' | head -n 1 | sed -E 's/^[\._\-]//')"			# search for any variation of known type abbreviations and remove the preceeding separation character
	[ "$FILETYPE" = '' ] && FILETYPE="$TYPE"						#   if the line above did not return any value, then default to whatever is specified as TYPE

	# NOTE: the VERS* variables are used for the foreign (source repo) package filename
	[ "$VERSION" ] && ( echo "$NAME" | grep -q ^"$PARAMETER" ) && eval VERBASE="${VERS_SCHEMA}" || VERBASE=''				# apply the source schema, or blank out the variable value
	[ "$VERBASE" ] && VERFILE="${VERBASE}.${EXT}" || VERFILE=''

	# NOTE: the VERT* variables are used for the local (target) package filename
	#	we only perform the following if the VERBASE has a value (e.g. for the passed package, not any of its dependencies)
	#	we do NOT adjust PACKAGE since it's purpose is for display, not functionality
	[ "$VERBASE" ] && eval BASENAME="${VERT_SCHEMA}"
	[ "$VERBASE" ] && FILENAME="${BASENAME}.${EXT_SOFT}"
}


# Usage syntax: addDependency FILENAME DEPENDENCY
# Overview:	adds the passed package name onto the top of the stack of dependencies
# Parameters:
# FILENAME	[string] the package name that needs to be added to the stack
# DEPENDENCY	[boolean] if the FILENAME is a passed package or one of its dependencies
addDependency() {
	[ $DEBUG -gt 0 ] && echo -e "addDependency (old):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|" >>"$LOG_DBUG"

	INDEX=$(( INDEX + 1 ))
	TOTAL=$(( TOTAL + 1 ))
	[ "$2" = 'FALSE' ] && eval "DEP${INDEX}=$1" || eval "DEP${INDEX}=\"+$1\""		# add the package or its dependency (notated with a preceeding '+')	NOTE: since busybox shell (ash) can't handle arrays (ugh!), we have to use this work around...
	eval "DEPENDENCY=\$DEP${INDEX}"

	[ $DEBUG -gt 0 ] && echo -e "addDependency (new):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|" >>"$LOG_DBUG"
}


# Usage syntax: deleteDependency [ADJUST]
# Overview:	deletes the top-most (last added) package from the stack of dependencies
# Parameters:
# ADJUST	[character] if the INDEX variable needs to be adjusted: (i)ncrease by 1, (d)ecrease by 1, null makes no adjustments
deleteDependency() {
	local TARGET										# the value that should exit this function

	[ $DEBUG -gt 0 ] && echo -e "deleteDependency (old):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|" >>"$LOG_DBUG"

	eval "unset DEP${INDEX}"
	[ "$1" = 'd' ] && {									# if we need to decrease the INDEX value, then do so!
		INDEX=$(( INDEX - 1 ))
		TARGET=0									#   so if INDEX = 0, then we've decreased to the last dependency and there's nothing left to process
	}
	[ "$1" = 'i' ] && {									# if we need to decrease the INDEX value, then do so!
		INDEX=$(( INDEX + 1 ))
		TARGET=$TOTAL									#   so if INDEX = TARGET, then we've increased to the last dependency and there's nothing left to process
	}
	[ $INDEX -eq $TARGET ] && {								# if there isn't anything left in the stack, delete the variable and exit
		unset DEPENDENCY
		[ $DEBUG -gt 0 ] && echo -e "deleteDependency (new):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  ||" >>"$LOG_DBUG"
		return 0
	}
	[ "$1" ] && eval "DEPENDENCY=\$DEP${INDEX}"

	[ $DEBUG -gt 0 ] && echo -e "deleteDependency (new):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|" >>"$LOG_DBUG"
}


# Usage syntax: inDependencies FILENAME
# Overview:	checks if the package is already in the list of to-be-processed dependencies
# FILENAME	[string] the package name that needs to be looked up
inDependencies() {
	local I

	for I in $(seq 1 $INDEX); do								# check if the dependencies has already been added to the list to be processed, so...
		eval TEMP="\$DEP${I}"								#   since busybox 'sh' does not support arrays, we have to use this method to check each stored dependency
		( [ "$TEMP" = "$1" ] || [ "$TEMP" = "+$1" ] ) && return 0			#   if the iterated package or dependency (notated with the preceeding '+') is already in the list (including any specific version number), then...
	done
	return 1
}


# Usage syntax: listDependencies
# Overview:	lists the currently stored dependencies
listDependencies() {
	local I=$INDEX
	local D=' '

	( echo "$DEPENDENCY" | grep -qe ^'+' ) && DEPENDENCY="${DEPENDENCY#*+}"			# if there was a preceeding '+' from addDependency(), then we need to remove that
	TEMP="$DEPENDENCY"									# start with the DEPENDENCY that was last processed by addDependency()

	while [ "$D" ]; do
		I=$(( I - 1 ))
		eval "D=\$DEP${I}"
		( echo "$D" | grep -qe ^'+' ) && D="${D#*+}"					# if there was a preceeding '+' from addDependency(), then we need to remove that
		TEMP="${D}\n${TEMP}"
		[ $I -eq 1 ] && unset D
		[ $I -eq -1 ] && break								# this is a safety net for any issues that may get encountered
	done

	( echo "$TEMP" | grep -qe ^'\\n' ) && TEMP=$(echo -e "$TEMP" | tail -n +2)		# NOTE: if the string begins with a '  \n' that starts the 'while' loop, then erase that line
	showMsg 'package' "${TEMP}" 'both' 1 2
}


# Usage syntax: processDependencies PACKAGE DEPENDENCY [INDENT]
# Overview:	adds all the dependencies for the passed package onto the stack of dependencies to be installed
# Parameters:
# PACKAGE	[string] the package name that is being installed
# DEPENDENCY	[boolean] if the PACKAGE is a specified package or one of its dependencies
# INDENT	[string] [optional] passed tabs (e.g. '\t\t') to indent the output (for the -t switch)
processDependencies() {
	local SOURCE=''
	local DEPFILE
	local DEP="$2"
	local INDENT="$3"

	splitName "$1"

	[ $DEBUG -gt 0 ] && { echo -en "processDependencies:\n\tPARAMETER   |${PARAMETER}|\n\tPASSED      |${1}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${ARCH}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\tOPTFILE     |${OPTFILE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         |" >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	# perform a few basic checks...
	if [ "$BOOTING" ] && ( grep -qwE ^"${PACKAGE}|${FILENAME}"$ "${REPO_PREFIX}/${FLAG_BOOT}" 2>/dev/null ); then				# if the package (by its PACKAGE name -or- complete FILENAME) IS listed as being flagged to not load, then...
		showMsg 'dependency' "[ flagged ] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0															# NOTE: to prevent issues during a bootup, just skip this package
	fi
	if [ ! "$BOOTING" ] && ( grep -qwE ^"${PACKAGE}|${FILENAME}"$ "${REPO_PREFIX}/${FLAG_LIVE}" 2>/dev/null ); then				# if the package (by its PACKAGE name -or- complete FILENAME) IS listed as being flagged to not load, then...
		showMsg 'dependency' "[ flagged ] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is flagged from being loaded." 'log'
# DEV NOTE: you can force an install to just skip processing the overall request
		if [ "$FORCE" ]; then
			return 0
		else
			showMsg 'failure' "The package is flagged from being loaded." 'log'
			return 1
		fi
	fi

	# NOTE: the -u automatically sets DEPS='all'
	[ "$OPTFILE" ] && [ "$DEPS" != 'all' ] && {												# if we've encountered a conditional package -AND- we are not using the '-D all' option, then we can safely skip it!
		showMsg 'dependency' "[ optional] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0															# NOTE: don't error with exit status for a conditional package
	}
# UPDATED 2026/01/12 - we use BASENAME not FILENAME
#	[ "$OPTFILE" ] && [ "$DEPS" = 'all' ] && ( [ ! -e "${DIR_LIST}/${OPTFILE}" ] || [ ! -e "${DIR_LIST}/${FILENAME}" ] ) && {		# if we've encountered a conditional package -AND- we are using the '-D all' option -AND- it's dependency -or- the optional package is not installed, then...
	[ "$OPTFILE" ] && [ "$DEPS" = 'all' ] && ( [ ! -e "${DIR_LIST}/${OPTFILE}" ] || [ ! -e "${DIR_LIST}/${BASENAME}" ] ) && {		# if we've encountered a conditional package -AND- we are using the '-D all' option -AND- it's dependency -or- the optional package is not installed, then...
		showMsg 'dependency' "[ unloaded] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'warning' "The conditional package is not installed." 'log'
		return 0															# NOTE: don't error with exit status for a conditional package
	}

	# perform checks for the actions...
	( echo ",${IGNORE}," | grep -qE ",(${PACKAGE}|${FILENAME})," ) && ( [ "$COPY" ] || [ "$DOWNLOAD" ] || [ "$EXTRACT" ] || [ "$INSTALL" ] || [ "$UNLOAD" ] || [ "$VALIDATE" ] ) && {	# if the iterated dependency is ignored -AND- we are performing any of these actions, then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tThe package was passed in the ignore list..." >>"$LOG_DBUG"					# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'dependency' "[ ignored ] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0
	}

	[ "$COPY" ] && [ "$DEPS" = 'source' ] && [ ! -e "${REPO_SOURCE}/${FILENAME}" ] && {							# if we're copying -AND- all deps need to be in the same directory -AND- the package does NOT exist there, then...
		showMsg 'dependency' "[ missing ] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is missing from REPO_SOURCE." 'log'
		return 1
	}
	( [ "$COPY" ] || [ "$DOWNLOAD" ] ) && [ ! "$FORCE" ] && [ -e "${FILENAME}" ] && {							# if we're copying or downloading -AND- not forcing -AND- the package exists in the target DIRECTORY, then...
		[ $DEBUG -gt 0 ] && echo -e "\tPackage already exists in the target location." >>"$LOG_DBUG"					# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'dependency' "[  exist  ] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0															# NOTE: do NOT return error, we will just simply skip the file so the user isn't forced to pass '-F' a lot
	}

# UPDATED 2026/01/12 - we use BASENAME not FILENAME
#	[ "$DOWNLOAD" ] && [ -e "${DIR_LIST}/${FILENAME}" ] && [ ! -s "${DIR_LIST}/${FILENAME}" ] && {
	[ "$DOWNLOAD" ] && [ -e "${DIR_LIST}/${BASENAME}" ] && [ ! -s "${DIR_LIST}/${BASENAME}" ] && {
		[ $DEBUG -gt 0 ] && echo -e "\tPackage is already installed in the OS." >>"$LOG_DBUG"						# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'dependency' "[installed] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0															# NOTE: do NOT return error, we will just simply skip the file so the user isn't forced to pass '-F' a lot
	}

# UPDATED 2026/01/12 - we use BASENAME not FILENAME
#	[ "$INSTALL" ] && [ ! "$FORCE" ] && [ -e "${DIR_LIST}/${FILENAME}" ] && {								# if we're installing -AND- not forcing -AND- the software is already installed, then...
	[ "$INSTALL" ] && [ ! "$FORCE" ] && [ -e "${DIR_LIST}/${BASENAME}" ] && {								# if we're installing -AND- not forcing -AND- the software is already installed, then...
		showMsg 'dependency' "[installed] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		[ $INDEX -eq 0 ] && showMsg 'failure' "The package is currently installed." 'log'
		[ $DEBUG -gt 0 ] && echo -e "\tThe dependency is currently installed." >>"$LOG_DBUG"
		return 0															# NOTE: this has to be a 0 because already installed packages (e.g. dependencies) would trigger failure otherwise
	}

	[ "$RESTORE" ] && [ "$RESTORE" != 'none' ] && [ ! -e "${REPO_SOURCE}/${FILENAME}" ] && {						# if we're restoring -AND- the package is not in the restore point directory, then...
		showMsg 'dependency' "[ missing ] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is not in the restore point." 'log'
		return 1
	}

# UPDATED 2026/01/12 - we use BASENAME not FILENAME
#	( [ "$UNLOAD" = 'unload' ] || [ "$UNLOAD" = 'unlist' ] || [ "$UNLOAD" = 'update' ] ) && [ ! -e "${DIR_LIST}/${FILENAME}" ] && {		# if we're unloading, unlisting, or updating -AND- the package is already unloaded, then go to the next one!
	( [ "$UNLOAD" = 'unload' ] || [ "$UNLOAD" = 'unlist' ] || [ "$UNLOAD" = 'update' ] ) && [ ! -e "${DIR_LIST}/${BASENAME}" ] && {		# if we're unloading, unlisting, or updating -AND- the package is already unloaded, then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tThe package is already unloaded." >>"$LOG_DBUG"							# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'dependency' "[ unloaded] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0
	}
	# NOTE: REPO_SYSTEM holds the pwd when the script was executed so make sure that the updated package exists there
	[ "$UNLOAD" = 'update' ] && [ ! -e "${REPO_SYSTEM}/${FILENAME}" ] && {									# if we're just undating -AND- the update is not in the pwd (see NOTE above), then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tThe package update is not in the current directory." >>"$LOG_DBUG"				# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'dependency' "[ missing ] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0
	}
# UPDATED 2026/01/12 - we use BASENAME not FILENAME
#	[ "$UNLOAD" = 'update' ] && [ ! -s "${DIR_LIST}/${FILENAME}" ] && [ $(id -u) -gt 0 ] && {						# if we're updating -AND- the package is on BOOT (via 0 byte file) -AND- we're not root or sudo, then...
	[ "$UNLOAD" = 'update' ] && [ ! -s "${DIR_LIST}/${BASENAME}" ] && [ $(id -u) -gt 0 ] && {						# if we're updating -AND- the package is on BOOT (via 0 byte file) -AND- we're not root or sudo, then...
		[ $DEBUG -gt 0 ] && echo -e "\tWARNING:    The user account does not have sufficient priviledges to update base OS packages." >>"$LOG_DBUG"
		showMsg 'dependency' "[ account ] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0															# NOTE: we don't exit with failure since this could just be a dependency and left installed
	}
# DEV NOTE: the REPO_OPTION directory can no longer contain 0-byte REPO_SYSTEM files; everything needs to go into REPO_LIST/BASENAME[.list|info|hash|deps]
	# if we're unloading, but not updating -AND- the package has a 'base os' marker (e.g. TinyCore) -OR- ( the package exists in DIR_LIST -AND- we're working in REPO_OPTION -AND- the package does NOT exist there (since it would be in REPO_SYSTEM), then...
# UPDATED 2026/01/12 - we use BASENAME not FILENAME
#	[ "$UNLOAD" ] && [ "$UNLOAD" != 'update' ] && ( [ -e "${DIR_LIST}/${BASENAME}.${EXT_CORE}" ] || ( [ -e "${DIR_LIST}/${FILENAME}" ] && [ "$DIRECTORY" = "$REPO_OPTION" ] && [ ! -e "${REPO_OPTION}/${FILENAME}" ] ) ) && {
	[ "$UNLOAD" ] && [ "$UNLOAD" != 'update' ] && ( [ -e "${DIR_LIST}/${BASENAME}.${EXT_CORE}" ] || ( [ -e "${DIR_LIST}/${BASENAME}" ] && [ "$DIRECTORY" = "$REPO_OPTION" ] && [ ! -e "${REPO_OPTION}/${FILENAME}" ] ) ) && {
		[ $DEBUG -gt 0 ] && echo -e "\tWARNING:    The package is part of the base OS and can't be modified." >>"$LOG_DBUG"
		showMsg 'dependency' "[ CORE OS ] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0															# NOTE: we don't exit with failure since this could just be a dependency and left installed
	}
	# if we're unloading -or- validating -AND- the iterated dependency is not present anywhere, then...
	( [ "$UNLOAD" ] || [ "$VALIDATE" ] ) && [ ! -e "${REPO_SOURCE}/${FILENAME}" ] && [ ! -e "${REPO_SYSTEM}/${FILENAME}" ] && [ ! -e "${REPO_OPTION}/${FILENAME}" ] && {
		showMsg 'dependency' "[ missing ] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package can not be located in REPO_SOURCE, REPO_SYSTEM, or REPO_OPTION." 'log'
		return 1
	}

	# check that the dependency is not already in the list to be processed
	[ $DEBUG -gt 0 ] && echo -en "\tChecking if dependency is already marked for processing:" >>"$LOG_DBUG"
	if [ "$UNLOAD" ] && ( ! echo "${UNLOAD}" | grep -q 2 ); then										# if we're unloading, but not on the second stage of the process, then...
		[ -e "${DIR_TEMP}/unload.${EXEID}" ] && ( grep -q "$FILENAME" "${DIR_TEMP}/unload.${EXEID}" ) && {				#    if the unload text file exists -AND- the package is in it, then...
			[ $DEBUG -gt 0 ] && echo " [yes]" >>"$LOG_DBUG"
			showMsg 'duplicate' "[duplicate] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1					# other possible values: marked, double, listed
			return 0
		}
	else																	# otherwise we need to see if the package is in the dependency variable list
		if ( inDependencies "$FILENAME" ); then
			[ $DEBUG -gt 0 ] && echo " [yes]" >>"$LOG_DBUG"

			[ "$VALIDATE" ] && showMsg 'duplicate' "[duplicate] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1		# other possible values: processed
			[ ! "$VALIDATE" ] && showMsg 'duplicate' "[duplicate] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1		# other possible values: marked, double, listed
			return 0
		fi
	fi
	[ $DEBUG -gt 0 ] && echo " [no]" >>"$LOG_DBUG"

	# --- IF WE HAVE MADE IT HERE, THEN DO SOME WORK ---

	# determine if the SOURCE is remote or local, then...					# NOTE: for any actions that must perform locally, an error would have already been issued above
	SOURCE=''										# reset the variable
	( ! echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) && [ "$DEPS" = 'source' ] && [ ! -e "${REPO_SOURCE}/${FILENAME}" ] && {		#   if all deps need to be in the same directory -AND- the package does NOT exist there, then...
		showMsg 'dependency' "[ missing ] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is missing from REPO_SOURCE." 'log'
		return 1
	}

	if [ -e "${REPO_SOURCE}/${FILENAME}" ]; then SOURCE='  local  '				# if the package is in the specified directory, then...
	elif [ -e "${REPO_OPTION}/${FILENAME}" ]; then SOURCE='local opt'			# if the package is in the REPO_OPTION directory, then...
	elif [ -e "${REPO_SYSTEM}/${FILENAME}" ]; then SOURCE='local sys'; fi			# if the package is in the REPO_SYSTEM directory, then...
	[ ! "$SOURCE" ] && ( echo "$REPO_SOURCE"|grep -qE ^'(http|ftp)' ) && SOURCE=' foreign '	# if there IS a remote REPO_SOURCE value (either by the action default -OR- a passed -S value), then...
	[ ! "$SOURCE" ] && {									# if the package could not be found, then...
		showMsg 'dependency' "[ missing ] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is missing from REPO_SOURCE, REPO_OPTION, and REPO_SYSTEM." 'log'
		return 1
	}

	# display the package name to the output targets
	if [ "$TREE" ]; then
		[ ! "$INDENT" ] && [ ! "$OPTFILE" ] && showMsg 'package' "${INDENT}${PACKAGE} (${FILETYPE})" 'screen' 1 4			# if this is the package being processed, then...
		[ "$INDENT" ] && [ ! "$OPTFILE" ] && showMsg 'file' "${INDENT}${PACKAGE} (${FILETYPE})" 'screen' 1 1				# if this is a depends/dependency package, then...
		[ "$OPTFILE" ] && showMsg 'file' "${INDENT}${PACKAGE} {COLOR}(${FILETYPE}) [optional]" 'screen' 1 1				# if this is an optional depends/dependency package, then...
	elif [ "$VALIDATE" ]; then
# UPDATED 2026/01/12 - we use BASENAME not FILENAME
#		[ -e "${DIR_LIST}/${FILENAME}" ] && showMsg 'step' "[installed] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1 || showMsg 'issue' "[ unloaded] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		[ -e "${DIR_LIST}/${BASENAME}" ] && showMsg 'step' "[installed] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1 || showMsg 'issue' "[ unloaded] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
	else
		showMsg 'dependency' "[${SOURCE}] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
	fi

	# add the passed dependency to the stack
	[ ! "$TREE" ] && ( [ ! "$UNLOAD" ] || ( echo "${UNLOAD}" | grep -q 2 ) ) && addDependency "$FILENAME" "$DEP"				# if we're NOT unloading -OR- we're on the 2nd stage of unloading, then add the passed package to the stack to be processed outside of this function
	[ ! "$TREE" ] && ( [ ! "$UNLOAD" ] || ( echo "${UNLOAD}" | grep -q 2 ) ) && [ $DEBUG -gt 0 ] && echo "processDependencies (returned):" >>"$LOG_DBUG"

	[ "$UNLOAD" ] && ( ! echo "${UNLOAD}" | grep -q 2 ) && [ "$DEP" = 'FALSE' ] && echo "$FILENAME" >>"${DIR_TEMP}/unload.${EXEID}"		# if we ARE unloading -AND- it's the first stage -AND- it's a specified package, then add it to the unload listing
	[ "$UNLOAD" ] && ( ! echo "${UNLOAD}" | grep -q 2 ) && [ "$DEP" = 'TRUE' ] && echo "+$FILENAME" >>"${DIR_TEMP}/unload.${EXEID}"		# if we ARE unloading -AND- it's the first stage -AND- it's a package dependency, then add it to the unload listing
	[ "$UNLOAD" ] && ( ! echo "${UNLOAD}" | grep -q 2 ) && [ $DEBUG -gt 0 ] && echo -e "\tAdding dependency to the unload list: [done]" >>"$LOG_DBUG"

	[ "$UNLOAD" = 'update' ] && continue							# if we're updating an installed package, then we don't worry about its dependencies (since they should already be installed)

	# obtain or copy the software .deps file
	if ( [ "$DOWNLOAD" ] || [ "$INSTALL" ] ) && [ "$SOURCE" = ' foreign ' ]; then
		downloadPackage DEPS || return 0						#   get any .deps file for the dependency itself	NOTE: we can't exit with an error since some packages do not have one of these files
		[ $DEBUG -gt 0 ] && echo "processDependencies (returned):" >>"$LOG_DBUG"
	elif [ "$COPY" ] && [ -e "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" ]; then		# if we're copying and the dependency has a .deps file, then copy it over too!
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}\" './'" >>"$LOG_DBUG"
		cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" './' >/dev/null 2>&1 || {	#   copy the corresponding deps file
			showMsg 'failure' "The package deps file copy failed (${BASENAME}.${EXT_DEPS})." 'log'
			return 1
		}
	fi

	[ "$DEPS" = 'none' ] && {								# if we are only affecting the package itself and not any dependencies, then there's no reason to continue processing anything
		[ $DEBUG -gt 0 ] && echo -e "\tProcessing only the package, not any dependencies..." >>"$LOG_DBUG"
		return 0									#   now exit this function!
	}

	# process all the dependencies of the passed software
	[ $DEBUG -gt 0 ] && echo -en "\tChecking for package dependency file:" >>"$LOG_DBUG"
	[ ! -e "${BASENAME}.${EXT_DEPS}" ] && [ $DEBUG -gt 0 ] && echo -e " [absent] [done]" >>"$LOG_DBUG"
	if [ -e "${BASENAME}.${EXT_DEPS}" ]; then
		[ $DEBUG -gt 0 ] && echo -e " [exists] [processing]" >>"$LOG_DBUG"
		# NOTE: we have to include DRYRUN as part of the command so the file gets deleted correctly; BASENAME would only have the name of the last dependency for an after-for-loop removal
		for DEPFILE in $(cat "./${BASENAME}.${EXT_DEPS}" 2>/dev/null && [ "$DRYRUN" ] && ( [ "$COPY" ] || [ "$DOWNLOAD" ] ) && rm -f "./${BASENAME}.${EXT_DEPS}" 2>>"$LOG_ERRS"); do	# if the passed dependency also has dependencies, then...
			processDependencies "$DEPFILE" 'TRUE' "$INDENT  " || return 1		# WARNING: this line needs to execute no matter the outcome of the 'wget' call above (so the addDependency() call can be made if needed) -AND- it needs to be the unaltered DEPFILE variable with any contained version number!!!
		done
	fi
	return 0
}


# Usage syntax: copyPackage
# Overview:	copies the .soft and .hash files from a local directory to another local directory
# Notes:	the target directory to copy the specified file(s) into should already be entered BEFORE calling this function!
#		no need to copy the .deps file since that was handled via processDependencies().
copyPackage() {
	local SOURCE

	if [ -e "${REPO_SOURCE}/${FILENAME}" ]; then SOURCE="$REPO_SOURCE"			# if the package is in the specified directory, then...
	elif [ -e "${REPO_OPTION}/${FILENAME}" ]; then SOURCE="$REPO_OPTION"			# if the package is in the REPO_OPTION directory, then...
	elif [ -e "${REPO_SYSTEM}/${FILENAME}" ]; then SOURCE="$REPO_SYSTEM"; fi		# if the package is in the REPO_SYSTEM directory, then...

	[ $DEBUG -gt 0 ] && { echo -en "copyPackage:\n\tPARAMETER   |${PARAMETER}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${ARCH}|\n\tSOURCE      |${SOURCE}|\n\tpwd         |" >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	[ "$REPO_SOURCE" = "$DIRECTORY" ] && {
		showMsg 'failure' "The source and target locations are the same."
		return 1
	}

	showMsg 'file' " [pack]" 'both' 0 0
	[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"${SOURCE}/${BASENAME}.${EXT_SOFT}\" './'" >>"$LOG_DBUG"
	[ ! "$DRYRUN" ] && ( cp -f "${SOURCE}/${BASENAME}.${EXT_SOFT}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {					# copy the .soft file from the source directory
		showMsg 'failure' "The package copy failed (${BASENAME}.${EXT_SOFT})." 'log'
		return 1
	}

	showMsg 'file' " [hash]" 'both' 0 0
	[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"${SOURCE}/${BASENAME}.${EXT_HASH}\" './'" >>"$LOG_DBUG"
	[ ! "$DRYRUN" ] && ( cp -f "${SOURCE}/${BASENAME}.${EXT_HASH}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {					# copy the corresponding hash file
		showMsg 'failure' "The package hash file copy failed (${BASENAME}.${EXT_HASH})." 'log'
		return 1
	}

	if [ -e "${SOURCE}/${BASENAME}.${EXT_DEPS}" ] && [ ! -e "./${BASENAME}.${EXT_DEPS}" ]; then												# NOTE: this had to be added in case '-D none' was passed
		showMsg 'file' " [deps]" 'both' 0 0
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"${SOURCE}/${BASENAME}.${EXT_DEPS}\" './'" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && ( cp -f "${SOURCE}/${BASENAME}.${EXT_DEPS}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {				# copy the corresponding hash file
			showMsg 'failure' "The package hash file copy failed (${BASENAME}.${EXT_DEPS})." 'log'
			return 1
		}
	fi

	if [ "$EXTRA" ]; then
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'code' ]; then
			if [ -e "${SOURCE}/${BASENAME}.${EXT_CODE}" ]; then
				showMsg 'file' " [code]" 'both' 0 0
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.${EXT_CODE}\" './'" >>"$LOG_DBUG"
				[ ! "$DRYRUN" ] && ( cp -f "${SOURCE}/${BASENAME}.${EXT_CODE}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {		# copy the corresponding code file
					showMsg 'failure' "The package source code file copy failed (${BASENAME}.${EXT_CODE})." 'log'
					return 1
				}
			fi
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'cpio' ]; then
			if [ -e "${SOURCE}/${BASENAME}.cpio" ]; then
				showMsg 'file' " [cpio]" 'both' 0 0
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.cpio\" './'" >>"$LOG_DBUG"
				[ ! "$DRYRUN" ] && ( cp -f "${SOURCE}/${BASENAME}.cpio" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {			# copy the corresponding cpio file
					showMsg 'failure' "The package cpio file copy failed (${BASENAME}.cpio)." 'log'
					return 1
				}
			fi
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'info' ]; then
			if [ -e "${SOURCE}/${BASENAME}.${EXT_INFO}" ]; then
				showMsg 'file' " [info]" 'both' 0 0
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.${EXT_INFO}\" './'" >>"$LOG_DBUG"
				[ ! "$DRYRUN" ] && ( cp -f "${SOURCE}/${BASENAME}.${EXT_INFO}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {		# copy the corresponding info file
					showMsg 'failure' "The package info file copy failed (${BASENAME}.${EXT_INFO})." 'log'
					return 1
				}
			fi
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'list' ]; then
			if [ -e "${SOURCE}/${BASENAME}.${EXT_LIST}" ]; then
				showMsg 'file' " [list]" 'both' 0 0
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.${EXT_LIST}\" './'" >>"$LOG_DBUG"
				[ ! "$DRYRUN" ] && ( cp -f "${SOURCE}/${BASENAME}.${EXT_LIST}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {		# copy the corresponding list file
					showMsg 'failure' "The package manifest file copy failed (${BASENAME}.${EXT_LIST})." 'log'
					return 1
				}
			fi
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'make' ]; then
			if [ -e "${SOURCE}/${BASENAME}.${EXT_MAKE}" ]; then
				showMsg 'file' " [make]" 'both' 0 0
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.${EXT_MAKE}\" './'" >>"$LOG_DBUG"
				[ ! "$DRYRUN" ] && ( cp -f "${SOURCE}/${BASENAME}.${EXT_MAKE}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {		# copy the corresponding make file
					showMsg 'failure' "The package make file copy failed (${BASENAME}.${EXT_MAKE})." 'log'
					return 1
				}
			fi
		fi
	fi

	return 0
}


# Usage syntax: downloadPackage DEPS
# Overview:	downloads the .soft and .hash (and optionally others) files from the repo and compares the package checksum to validate the download
# Notes:	the directory to store the obtained file(s) should already be entered BEFORE calling this function!
# Parameters:
# DEPS		[boolean] if we just need to get the .deps file for the package (via a processDependencies() call)
downloadPackage() {
	local BASE_SOURCE="${BASENAME}"
	local FILE_SOURCE="${BASENAME}.${EXT_SOFT}"
	[ "$VERBASE" ] && eval BASE_SOURCE="${VERBASE}"
	[ "$VERFILE" ] && eval FILE_SOURCE="${VERFILE}"
	local BASE_TARGET="${BASENAME}"								# NOTE: these would already have any VERT_SCHEMA applied to them in splitName()
	local FILE_TARGET="${BASENAME}.${EXT_SOFT}"
	eval REPO_SOURCE="${REPO_SCHEMA}"							# eval REPO_SOURCE incase it has any variables in it

	[ $DEBUG -gt 0 ] && { echo -en "downloadPackage:\n\tOBTAIN .deps|${1}|\n\tPARAMETER   |${PARAMETER}|\n\tFILENAME    |${FILE_TARGET}|\n\tBASENAME    |${BASE_TARGET}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${ARCH}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\tOPTFILE     |${OPTFILE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         |" >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	( echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) || {					# make sure the SOURCE is remote
		showMsg 'failure' "A non-Internet value is set for REPO_SOURCE." 'log'
		return 1
	}

	if [ "$1" ]; then
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_DEPS}\" -O \"./${BASE_TARGET}.${EXT_DEPS}\"" >>"$LOG_DBUG"
		wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_DEPS}" -O "./${BASE_TARGET}.${EXT_DEPS}" >/dev/null 2>&1
		[ ! -e "./${BASE_TARGET}.${EXT_DEPS}" ] && return 1				# if no .deps file exists, then exit so processDependencies() knows to exit

		BASENAME="${BASE_TARGET}"							# adjust the name so processDependencies() can perform the last step before this variable value gets overwritten
		return 0
	fi

	showMsg 'file' " [pack]" 'both' 0 0
	[ $DEBUG -gt 0 ] && echo -e "\tCalling:    wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_SOFT}\" -O \"./${BASE_TARGET}.${EXT_SOFT}\"" >>"$LOG_DBUG"
	# NOTE: the string of commands outputs to the pax.log correctly while still returning a proper exit code from wget
	[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_SOFT}" -O "./${BASE_TARGET}.${EXT_SOFT}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && { 			# download the package file from the repo
		showMsg 'failure' "The package file download failed (${BASE_SOURCE}.${EXT_SOFT})." 'log'
		return 1
	}

	showMsg 'file' " [hash]" 'both' 0 0
	[ $DEBUG -gt 0 ] && echo -e "\tCalling:    wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_HASH}\" -O \"./${BASE_TARGET}.${EXT_HASH}\"" >>"$LOG_DBUG"
	[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_HASH}" -O "./${BASE_TARGET}.${EXT_HASH}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && { 			# download the corresponding hash file
		showMsg 'failure' "The package hash file download failed (${BASE_SOURCE}.${EXT_HASH})." 'log'
		return 1
	}

	# if we ARE installing a specific version of the software, then...
	[ $DEBUG -gt 0 ] && [ ! "$DRYRUN" ] && [ "$VERFILE" ] && echo -e "\tCalling:    sed -i \"s/  .*/  ${FILENAME}/\" \"./${BASE_TARGET}.${EXT_HASH}\"" >>"$LOG_DBUG"
	[ ! "$DRYRUN" ] && [ "$VERFILE" ] && sed -i "s/  .*/  ${FILENAME}/" "./${BASE_TARGET}.${EXT_HASH}"					# changing the package name to match the version number in the hash file

	if [ "$EXTRA" ]; then
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'code' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_CODE}\" -O \"./${BASE_TARGET}.${EXT_CODE}\"" >>"$LOG_DBUG"
			[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_CODE}" -O "./${BASE_TARGET}.${EXT_CODE}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the corresponding source code file
				showMsg 'warning' "The package source code file download failed (${BASE_SOURCE}.${EXT_CODE})." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
			[ -e "./${BASE_SOURCE}.${EXT_CODE}" ] && showMsg 'file' " [code]" 'both' 0 0
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'cpio' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.cpio\" -O \"./${BASE_TARGET}.cpio\"" >>"$LOG_DBUG"
			[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.cpio" -O "./${BASE_TARGET}.cpio" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {			# download the corresponding cpio file
				showMsg 'warning' "The package cpio file download failed (${BASE_SOURCE}.cpio)." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
			[ -e "./${BASE_SOURCE}.cpio" ] && showMsg 'file' " [cpio]" 'both' 0 0
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'info' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_INFO}\" -O \"./${BASE_TARGET}.${EXT_INFO}\"" >>"$LOG_DBUG"
			[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_INFO}" -O "./${BASE_TARGET}.${EXT_INFO}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the corresponding info file
				showMsg 'warning' "The package info file download failed (${BASE_SOURCE}.${EXT_INFO})." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
			[ -e "./${BASE_SOURCE}.${EXT_INFO}" ] && showMsg 'file' " [info]" 'both' 0 0
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'list' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_LIST}\" -O \"./${BASE_TARGET}.${EXT_LIST}\"" >>"$LOG_DBUG"
			[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_LIST}" -O "./${BASE_TARGET}.${EXT_LIST}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the corresponding manifest file
				showMsg 'warning' "The package manifest file download failed (${BASE_SOURCE}.${EXT_LIST})." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
			[ -e "./${BASE_SOURCE}.${EXT_LIST}" ] && showMsg 'file' " [list]" 'both' 0 0
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'make' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    wget -cq \"${REPO_SOURCE}/${BASE_SOURCE}.${EXT_MAKE}\" -O \"./${BASE_TARGET}.${EXT_MAKE}\"" >>"$LOG_DBUG"
			[ ! "$DRYRUN" ] && ( wget -cq "${REPO_SOURCE}/${BASE_SOURCE}.${EXT_MAKE}" -O "./${BASE_TARGET}.${EXT_MAKE}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the corresponding manifest file
				showMsg 'warning' "The package make file download failed (${BASE_SOURCE}.${EXT_MAKE})." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
			[ -e "./${BASE_SOURCE}.${EXT_MAKE}" ] && showMsg 'file' " [make]" 'both' 0 0
		fi
	fi

	return 0
}


# Usage syntax: installPackage
# Overview:	performs the actual work of installing the contents of the package to the system via copy or symlink
#		this function is also used to perform package validation
installPackage() {
	local ITEM
	local SOURCE=''
	local TARGET=''
	local TARGET_ROOT
	local TARGET_LIVE
	local TARGET_HOME

	if [ -e "${REPO_SOURCE}/${FILENAME}" ]; then SOURCE="$REPO_SOURCE"			# if the package is in the specified directory, then...
	elif [ -e "${REPO_OPTION}/${FILENAME}" ]; then SOURCE="$REPO_OPTION"			# if the package is in the REPO_OPTION directory, then...
	elif [ -e "${REPO_SYSTEM}/${FILENAME}" ]; then SOURCE="$REPO_SYSTEM"; fi		# if the package is in the REPO_SYSTEM directory, then...

	[ $DEBUG -gt 0 ] && { echo -en "installPackage:\n\tPARAMETER   |${PARAMETER}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${ARCH}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\tOPTFILE     |${OPTFILE}|\n\tSOURCE      |${SOURCE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         |" >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	showMsg 'step' " [validate]" 'both' 0 0
	( md5sum -c "${BASENAME}.${EXT_HASH}" >/dev/null 2>&1 | sed "s/^${FILENAME}: OK//;s/^m/ \[failure\]\nm/" | tee -a "$LOG_ERRS" | grep -q ^'md5sum: ' ) && {	# validate the package checksum before we install anything!!!
		showMsg 'failure' "The package file failed hash checksum (${BASENAME}.${EXT_HASH})." 'log'
		# NOTE: no removal of failed packages takes place any longer, and will now fall on the user to do so. Besides, nothing will be installed as long as the hash doesn't match the package.
		return 1
	}
	showMsg 'step' " [${MODE}]" 'both' 0 0

	# since we have to do this step no matter what, lets setup and mount the package now
	[ ! -d "${DIR_LOOP}/${BASENAME}" ] && /bin/mkdir -p "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1					# make the mounting directory if it doesn't exist
	if ( ! /bin/mount 2>>"$LOG_ERRS" | grep -q "${DIR_LOOP}/${BASENAME} type squashfs" ); then						# if the package is NOT already mounted and symlinked, then...
		[ "$UNLOAD" = 'update2' ] && TEMP="./${FILENAME}"										# we need to use the package in the current directory where the update is
		[ "$UNLOAD" != 'update2' ] && TEMP="${SOURCE}/${FILENAME}"									# we need to use the package in SOURCE

		[ "$PROXY" ] && TEMP="${PROXY}"													# if a '-X -i' was issued, then mount an alternative location
		[ ! "$PROXY" ] && ( echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) && TEMP="${REPO_OPTION}"					# if a remote -S was passed, then mount from the default local repo storage location
		[ ! "$PROXY" ] && ( ! echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) && TEMP="${SOURCE}"					# if a local -S was passed, then mount from the provided, local location

		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    sudo /bin/mount -t squashfs -o loop,ro \"${TEMP}/${FILENAME}\" \"${DIR_LOOP}/${BASENAME}\"" >>"$LOG_DBUG"
		[ $DEBUG -gt 0 ] && [ ! -e "${TEMP}/${FILENAME}" ] && echo -e "\tNote:       The package is foreign so no additional debug commands will be shown for this package" >>"$LOG_DBUG"
		[ -e "${TEMP}/${FILENAME}" ] && { sudo /bin/mount -t squashfs -o loop,ro "${TEMP}/${FILENAME}" "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || return 1; }		# NOTE: we test for package existance in case we're doing a dryrun and it's remote (which it wouldn't be if that's true)
	fi

	# check if the package has any libs we need to load later										  NOTE: we check this way because simply checking for the directory can produce false positives
	( ls -1p "${DIR_LOOP}/${BASENAME}/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE							# NOTE: the "grep -qv '/'$" removes directories from the listing so only files remain (otherwise /lib/modules/ would provide a false positive)
	( ls -1p "${DIR_LOOP}/${BASENAME}/lib64" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	( ls -1p "${DIR_LOOP}/${BASENAME}/usr/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	( ls -1p "${DIR_LOOP}/${BASENAME}/usr/local/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	# check if the package has a [/usr[/local]]'/lib/modules' directory to indicate we need to load modules later
	( [ -d "${DIR_LOOP}/${BASENAME}/lib/modules" ] || [ -d "${DIR_LOOP}/${BASENAME}/usr/lib/modules" ] || [ -d "${DIR_LOOP}/${BASENAME}/usr/local/lib/modules" ] ) && MODULES=TRUE		# NOTE: we CAN simply check for directories here since files would be packaged under them

	TEMP=''											# set a default value
	( [ "$FORCE" ] || [ "$VALIDATE" = 'fix' ] ) && {					# if we've been instructed to force (overwrite) -OR- are validating (which always overwrites), then...
		[ ! "$VALIDATE" ] && showMsg 'notice' " [overwrite]" 'both' 0 0			#   indicate this to the user
		TEMP='f'									#   store the force flag for usage below
		unalias cp >/dev/null 2>&1							#   remove anything existing that would force prompting for overwritting (e.g. alias cp='cp -i')
		unalias ln >/dev/null 2>&1
	}

	[ "$VALIDATE" ] && showMsg 'step' " [${VALIDATE}] ${PURPLE}..." 'both' 1 0

# VER2 - if BOOTING or not -N or '-M link' then just issue a cp command for speed (instead of the below 'for' loop)?
	# if we only need to copy specified files out of the package, then lets obtain that list
	# NOTES:
	#	- if the passed file does NOT exist, it will NOT be in the filelist.txt
	#	- the final sed adds the directory to the listing so the 'for' loop below works correctly (since it needs preceeding directories, then files)
	#	  EXPLAINED: stores the entire line (with the filename) in the hold buffer; removes the filename from the line (leaving just the directory); prints the line; prints the hold buffer
	#	  SEE: https://stackoverflow.com/questions/12833714/the-concept-of-hold-space-and-pattern-space-in-sed
	[ "$FILELIST" ] && find "${DIR_LOOP}/${BASENAME}" ! -type d -name $(echo "$FILELIST" | sed 's/,/ -o -name /g;s/ / -o -name /g') | sed 'h;s|[^/]*$||;p;x' >"${DIR_TEMP}/filelist.${EXEID}" 2>>"$LOG_ERRS"

	# if a filelist.EXEID file does NOT exist, then we need to process all files in the package, otherwise -N was passed so only certain ones need to be
	# NOTES:
	#	- the sub-shell was constructed using to different conditions so the failure of a prior execution did not erroneously trigger an '||' execution
	#	- the '| tail -n +2' skips the first line of output, which is the current directory and should NOT be processed
	#	- we use EXEID here so simultaneous pax executions can operate without issues
	# WARNING: multiple problems occurred trying to use 'cp' (with these params: -aisL, -LRis, -HRis) but the task failed for one reason or another; the below was used instead
	for ITEM in $([ ! -e "${DIR_TEMP}/filelist.${EXEID}" ] && find "${DIR_LOOP}/${BASENAME}" | tail -n +2; [ -e "${DIR_TEMP}/filelist.${EXEID}" ] && cat "${DIR_TEMP}/filelist.${EXEID}"); do
		TARGET_ROOT="$(echo "$ITEM" | sed "s|^${DIR_LOOP}/${BASENAME}||")"		# (re)set the value; remove the loopback mount point prefix to store only the target '/directory/filename' string
		( echo "$DIR_LIVE" | grep -q '\.'$ ) && TARGET_LIVE="${DIR_LIVE}$(echo "${TARGET_ROOT}" | tail -c +2)" || TARGET_LIVE="${DIR_LIVE}${TARGET_ROOT}"
		TARGET_HOME="${HOME}${TARGET_ROOT}"
		TARGET="${DIRECTORY}${TARGET_ROOT}"						# set an initial value
		[ "$DIRECTORY" = '/' ] && TARGET="${TARGET_ROOT}"				# adjust if we need to search ROOT (so TARGET != '//...')
		( echo "$DIR_LIVE" | grep -q '\.'$ ) && ( echo "$DIRECTORY" | grep -q ^"${DIR_LIVE}" ) && TARGET="${DIR_LIVE}$(echo "${TARGET_ROOT}" | tail -c +2)"				# adjust if DIR_LIVE ends with a '.' -AND- that's the DIRECTORY value, to remove the preceeding '/' (for XSB)

		if [ "$VALIDATE" ] && [ ! -d "$ITEM" ]; then					# NOTE: we had to add the directory checking since it would prevent non-root directory structures from getting created (e.g. /usr/local)
			showMsg 'file' "  $TARGET:" 'both' 0 3 1

			TEMP=''
			# determine where the file is located (in case the package was installed one place [e.g. HOME] and a dependency in another [e.g. ROOT])
			# NOTE: this search pattern comes in order of presidence: passed DIRECTORY, HOME, DIR_LIVE, ROOT
			#	the 'misc' comes first since the package could also be in any of the following directories too, storing an incorrect TARGET path if they were triggered first
			# if the file exists -AND- ( we're dealing with a passed package [that should be in the passed DIRECTORY] -OR- it's a dependency [that could be somewhere else] -and- DIRECTORY is not HOME, DIR_LIVE, or ROOT [that need to be triggered below] ), then...
			if [ -e "$TARGET" ] && ( [ $INDEX -eq 1 ] || ( [ $INDEX -gt 1 ] && ( ! echo "$DIRECTORY" | grep -q ^"$HOME" ) && [ "$DIRECTORY" != "$DIR_LIVE" ] && [ "$DIRECTORY" != '/' ] ) ); then	# if it's in the passed DIRECTORY (DIV_LIVE would be default value), then...
				echo -n ''
			elif [ $INDEX -gt 1 ] && [ -e "$TARGET_HOME" ]; then			# if it's in HOME, then...
				TARGET="$TARGET_HOME"
			elif [ $INDEX -gt 1 ] && [ -e "$TARGET_LIVE" ]; then			# if it's in DIR_LIVE (default), then...
				TARGET="$TARGET_LIVE"
			elif [ $INDEX -gt 1 ] && [ -e "$TARGET_ROOT" ]; then			# if it's in the root of the OS, then...
				TARGET="$TARGET_ROOT"
			else									# if none of the above were triggered, the file isn't installed
				TEMP='else'
			fi

			# NOTE: this needs to be a separate 'if' so the proper location can be found (in the order of presidence)
			if [ "$TARGET" = "$TARGET_HOME" ]; then
				showMsg 'location' " [home]" 'both' 0 0
			elif [ "$TARGET" = "$TARGET_LIVE" ]; then
				showMsg 'location' " [live]" 'both' 0 0
			elif [ "$TARGET" = "$TARGET_ROOT" ]; then
				showMsg 'location' " [root]" 'both' 0 0
			else
				[ ! "$TEMP" ] && showMsg 'location' " [misc]" 'both' 0 0
			fi

			if [ "$TEMP" ]; then							# if none of the directory locations matched above, then go in here...
				[ "$VALIDATE" != 'fix' ] && showMsg 'issue' " !missing!" 'both' 0 0
				[ "$VALIDATE" = 'fix' ] && showMsg 'issue' " [restore]" 'both' 0 0
			fi
		fi

		if [ ! -d "$ITEM" ]; then													# for each file...
			[ ! "$DRYRUN" ] && [ ! "$FORCE" ] && [ ! "$VALIDATE" ] && [ -e "${TARGET}" ] && continue				#   if we're NOT forcing -AND- we're NOT validating -AND- the file does exist then go to the next file

			# NOE: the PREFIX will already be part of DIRECTORY (assigned at the beginning of the script processing)
			if ( [ "$INSTALL" ] || [ "$VALIDATE" = 'fix' ] || [ "$UNLOAD" = 'update2' ] ) && [ "$MODE" = 'copy' ]; then
				# NOTE: if the package installation is done with root, the USER:GROUP ownership is preserved (e.g. when installing to /), otherwise it will default to the user and their default group (e.g. when installing to /Users/Public or $HOME)
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -dp${TEMP} \"${ITEM}\" \"${TARGET}\"" >>"$LOG_DBUG"
				[ ! "$DRYRUN" ] && ( cp -dp${TEMP} "${ITEM}" "${TARGET}" 2>&1 | sed "s/^cp: can't preserve ownership.*//;/^$/d;s/^c/ \[failure\]\nc/" | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {		# copy the file from the source directory
					showMsg 'failure' "The package file copy failed (${ITEM})." 'log'
					return 1
				}
			elif ( [ "$INSTALL" ] || [ "$VALIDATE" = 'fix' ] || [ "$UNLOAD" = 'update2' ] ) && [ "$MODE" = 'link' ]; then
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    ln -s${TEMP} \"${ITEM}\" \"${TARGET}\"" >>"$LOG_DBUG"
				[ ! "$DRYRUN" ] && ( ln -s${TEMP} "${ITEM}" "${TARGET}" 2>&1 | sed 's/^l/ \[failure\]\nl/' | tee -a "$LOG_ERRS" | grep -q ^'ln: ' ) && {			# symlink the file from the source directory
					showMsg 'failure' "The package file symlink failed (${ITEM})." 'log'
					return 1
				}
			elif [ ! "$INSTALL" ] && [ ! "$UNLOAD" ] && ( [ "$VALIDATE" = 'data' ] || [ "$VALIDATE" = 'hash' ] ); then
				if [ -e "$TARGET" ]; then											# NOTE: the TARGET value will be altered in the 'if' block above
					if [ "$MODE" = 'copy' ]; then
						if [ ! -L "$ITEM" ] && [ -L "$TARGET" ]; then
							showMsg 'issue' " !symlink!" 'both' 0 0
							showMsg 'file' ' [done]' 'both' 1 5
							continue
						else
							# check for possible malicious (malware?) replacements with mismatched file sizes or hashing
							[ "$VALIDATE" = 'data' ] && ( [ "$(stat -c %s "$ITEM" 2>/dev/null)" = "$(stat -c %s "$TARGET" 2>/dev/null)" ] && showMsg 'step' " [size]" 'both' 0 0 || showMsg 'issue' " !size!" 'both' 0 0 )
							[ "$VALIDATE" = 'hash' ] && ( [ "$(md5sum "$ITEM" | sed 's/  .*//')" = "$(md5sum "$TARGET" | sed 's/  .*//')" ] && showMsg 'step' " [hash]" 'both' 0 0 || showMsg 'issue' " !hash!" 'both' 0 0 )
							# check the file permissions match those in the package
							[ "$(stat -c %a "$ITEM" 2>/dev/null)" = "$(stat -c %a "$TARGET" 2>/dev/null)" ] && showMsg 'step' " [perm]" 'both' 0 0 || showMsg 'issue' " !perm!" 'both' 0 0
						fi
					elif [ "$MODE" = 'link' ]; then
						[ "$(readlink "${TARGET}")" = "$ITEM" ] && showMsg 'step' " [link]" 'both' 0 0 || showMsg 'issue' " !link!" 'both' 0 0				# if the symlink isn't pointing to the source file, then...
						[ "$(stat -c %a "$TARGET" 2>/dev/null)" = '777' ] && showMsg 'step' " [perm]" 'both' 0 0 || showMsg 'issue' " !perm!" 'both' 0 0		# if the symlink permissions aren't correct, then...
					fi

					if [ "$DIRECTORY" = '/' ]; then				# if the package was installed in the root of the filesystem, then make sure the ownership is root
						[ "$(stat -c %G "$TARGET" 2>/dev/null)" = 'root' ] && showMsg 'step' " [owner]" 'both' 0 0 || showMsg 'issue' " !owner!" 'both' 0 0
					# if the package was installed anywhere else (/Users/Public or HOME), then it should match the default group of the user account that installed the software (e.g. 'everyone')
					elif [ "$DIRECTORY" != '/' ]; then
						 [ "$(stat -c %G "$TARGET" 2>/dev/null)" = "$OWN_GROUP" ] && showMsg 'step' " [owner]" 'both' 0 0 || showMsg 'issue' " !owner!" 'both' 0 0
					fi
				fi

			fi
			[ "$VALIDATE" ] && showMsg 'file' ' [done]' 'both' 1 5
			continue
		fi

		# if we're validating, we can skip checks on directories
		[ "$VALIDATE" ] && [ "$VALIDATE" != 'fix' ] && continue

		# if we've made it here, then we're dealing with a directory, so...
		( [ ! "$FORCE" ] && [ ! "$VALIDATE" ] ) && [ -e "${TARGET}" ] && continue	#   if we're NOT forcing -AND- we're NOT validating -AND- the directory does exist then cycle the 'for' loop

		if [ ! -e "${TARGET}" ]; then							# create the directory
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    mkdir -p \"${TARGET}\"" >>"$LOG_DBUG"
			[ ! "$DRYRUN" ] && ( mkdir -p "${TARGET}" 2>&1 | sed 's/^m/ \[failure\]\nm/' | tee -a "$LOG_ERRS" | grep -q ^'mkdir: ' ) && {
				showMsg 'failure' "The package directory creation failed (${TARGET})." 'log'
				 return 1;
			}
		fi
	done

	# remove any -N filelist files
	[ -e "${DIR_TEMP}/filelist.${EXEID}" ] && rm -f "${DIR_TEMP}/filelist.${EXEID}" 2>>"$LOG_ERRS"

	# unmount if we copied -OR- are doing a dryrun
	( [ "$MODE" = 'copy' ] || [ "$DRYRUN" ] ) && ( /bin/mount | grep -q "${DIR_LOOP}/${BASENAME} type squashfs" ) && { sudo /bin/umount -d "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || return 1; }	# NOTE: we test for mouting in case we're doing a dryrun and the package is remote (which it wouldn't be if that's true)

	# update the "install" list
	# if we are NOT validating -AND- installing a requested package [INDEX==1] (not a dependency for it [INDEX>1]) -AND- it needs to be added to a list -AND- the package isn't already in the LIST, then add the package to the LIST file
	[ ! "$DRYRUN" ] && [ ! "$VALIDATE" ] && [ "$PACKLIST" = 'boot' ] && ( ! echo "$DEPENDENCY" | grep -qe ^'+' ) && ( ! grep -q "$FILENAME" "${REPO_PREFIX}/${LIST_BOOT}" 2>>"$LOG_ERRS" ) && echo "$FILENAME" >>"${REPO_PREFIX}/${LIST_BOOT}" 2>>"$LOG_ERRS"
	[ ! "$DRYRUN" ] && [ ! "$VALIDATE" ] && [ "$PACKLIST" = 'live' ] && ( ! echo "$DEPENDENCY" | grep -qe ^'+' ) && ( ! grep -q "$FILENAME" "${REPO_PREFIX}/${LIST_LIVE}" 2>>"$LOG_ERRS" ) && echo "$FILENAME" >>"${REPO_PREFIX}/${LIST_LIVE}" 2>>"$LOG_ERRS"

	# defer the execution of any related marker/service scripts from the package(s) until everything is installed - if we are not validating package data!
	[ ! "$VALIDATE" ] && [ -x "${DIR_INST}/${BASENAME}" ] && ( ! grep -q "${DIR_INST}/${BASENAME}" ${DIR_TEMP}/installs.${EXEID} 2>/dev/null ) && echo "${BASENAME}" >>${DIR_TEMP}/installs.${EXEID} 2>>"$LOG_ERRS"
	[ ! "$VALIDATE" ] && [ -e "${DIR_INIT}/${BASENAME}" ] && ( ! grep -q "${DIR_INIT}/${BASENAME}" ${DIR_TEMP}/services.${EXEID} 2>/dev/null ) && echo "${BASENAME}" >>${DIR_TEMP}/services.${EXEID} 2>>"$LOG_ERRS"

	# now add to the 'catalog' of installed packages
	[ "$PROXY" ] && TEMP="${PROXY}"														# if a '-X -i' was issued, then mount an alternative location
	[ ! "$PROXY" ] && ( echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) && TEMP="${REPO_OPTION}"						# if a remote -S was passed, then mount from the default local repo storage location
	[ ! "$PROXY" ] && ( ! echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) && TEMP="${SOURCE}"						# if a local -S was passed, then mount from the provided, local location

# UPDATED 2026/01/12 - we use BASENAME not FILENAME
#	[ ! "$DRYRUN" ] && [ ! "$VALIDATE" ] && ln -sf "${TEMP}/${FILENAME}" "${DIR_LIST}/${FILENAME}" 2>>"$LOG_ERRS"
	[ ! "$DRYRUN" ] && [ ! "$VALIDATE" ] && [ ! -e "${DIR_LIST}/${BASENAME}" ] && touch "${DIR_LIST}/${BASENAME}" 2>>"$LOG_ERRS"
	[ ! "$DRYRUN" ] && [ ! "$VALIDATE" ] && [ -e "${BASENAME}.${EXT_HASH}" ] && ln -sf "${TEMP}/${BASENAME}.${EXT_HASH}" "${DIR_LIST}/${BASENAME}.${EXT_HASH}" 2>>"$LOG_ERRS"
	[ ! "$DRYRUN" ] && [ ! "$VALIDATE" ] && [ -e "${BASENAME}.${EXT_DEPS}" ] && ln -sf "${TEMP}/${BASENAME}.${EXT_DEPS}" "${DIR_LIST}/${BASENAME}.${EXT_DEPS}" 2>>"$LOG_ERRS"
	[ ! "$DRYRUN" ] && [ ! "$VALIDATE" ] && [ -e "${BASENAME}.${EXT_INFO}" ] && ln -sf "${TEMP}/${BASENAME}.${EXT_INFO}" "${DIR_LIST}/${BASENAME}.${EXT_INFO}" 2>>"$LOG_ERRS"
# MOVED 2026/01/15 - this needs to go into the -z action
#	# if we're installing -AND- not a dryrun -AND- we're booting the device -AND- there's a single package repo (e.g. TinyCore), then make a marker file indicating the package in a base OS package
#	[ ! "$VALIDATE" ] && [ ! "$DRYRUN" ] && [ "$BOOTING" ] && [ "$REPO_SYSTEM" = "$REPO_OPTION" ] && touch "${DIR_LIST}/${BASENAME}.${EXT_CORE}" 2>>"$LOG_ERRS"

	return 0
}


# Usage syntax: proxyAction
# Overview:	proxy's the action by creating a temporary shell script to execute on another device
# Notes:	https://unix.stackexchange.com/questions/22623/extract-middle-section-of-lines-of-a-text-file
#		https://unix.stackexchange.com/questions/2072/whats-the-best-way-to-take-a-segment-out-of-a-text-file
proxyAction() {
	# NOTE: we don't check for proxy.sh existence any longer to make sure it's not stale

	echo '#!/bin/sh' >"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo '# Variable Declarations' >>"${DIR_TEMP}/proxy.sh"
	echo -e "FLAG_LIVE='IncludedToPreventErrors'" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo -e "DIR_LIST='./optional.proxy'\nDIR_TEMP='./TEMP'" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo -e "EXT_CODE=\"${EXT_CODE}\"\nEXT_DEPS=\"${EXT_DEPS}\"\nEXT_HASH=\"${EXT_HASH}\"\nEXT_INFO=\"${EXT_INFO}\"\nEXT_LIST=\"${EXT_LIST}\"\nEXT_MAKE=\"${EXT_MAKE}\"\nEXT_SOFT=\"${EXT_SOFT}\"" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo -e "LOG_DBUG='../proxy.debug'\nLOG_ERRS='../proxy.log'" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo -e "ARCH_SCHEMA='${ARCH_SCHEMA}'\nFILE_SCHEMA='${FILE_SCHEMA}'\nKRNL_SCHEMA='${KRNL_SCHEMA}'\nREPO_SCHEMA='${REPO_SCHEMA}'\nVERS_SCHEMA='${VERS_SCHEMA}'\nVERT_SCHEMA='${VERT_SCHEMA}'" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo '# [system'] >> "${DIR_TEMP}/proxy.sh"
	echo -e "DEBUG=${DEBUG}\nINDEX=0\nTOTAL=0\nTEMP=''\nPARAMETER=''\nDIRECTORY=\"\$DIR_LIST\"\nDEPENDENCY=''\nPACKAGE=''\nBASENAME=''\nFILENAME=''\nFILETYPE=''\nOPTFILE=''\nVERBASE=''\nVERFILE=''" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo '# [actions'] >>"${DIR_TEMP}/proxy.sh"
	echo -e "COPY=\"${COPY}\"\nDOWNLOAD=\"${DOWNLOAD}\"" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo '# [options'] >>"${DIR_TEMP}/proxy.sh"
	echo -e "ARCH=\"${ARCH}\"\nDEPS=\"${DEPS}\"\nEXTRA=\"${EXTRA}\"\nFORCE=\"${FORCE}\"\nIGNORE=\"${IGNORE}\"\nKERNEL=\"${KERNEL}\"\nOUTPUT='text'\nQUIET=\"${QUIET}\"\nREPO_SOURCE=\"${REPO_SOURCE}\"\nTYPE=\"${TYPE}\"\nVERSION=\"${VERSION}\"" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo '# Function Declarations' >>"${DIR_TEMP}/proxy.sh"
	sed -n '/^exitGracefully()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >>"${DIR_TEMP}/proxy.sh"							# https://stackoverflow.com/questions/6916856/can-bash-show-a-functions-definition
	echo >>"${DIR_TEMP}/proxy.sh"
	sed -n '/^showMsg()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	sed -n '/^splitName()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	sed -n '/^addDependency()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	sed -n '/^deleteDependency()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	sed -n '/^inDependencies()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	sed -n '/^processDependencies()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	sed -n '/^copyPackage()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	sed -n '/^downloadPackage()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo '# Directory Checks' >>"${DIR_TEMP}/proxy.sh"
	echo "if [ ! -d \"\$DIR_TEMP\" ]; then" >>"${DIR_TEMP}/proxy.sh"
	echo "	mkdir -p \"\${DIR_TEMP}\" >>\"\${LOG_ERRS#*/}\" 2>&1 || { echo \"ERROR: The temp directory (DIR_TEMP) does not exist and could not be created.\" | tee -a \"\${LOG_ERRS#*/}\"; exit 1; }" >>"${DIR_TEMP}/proxy.sh"
	echo "fi" >>"${DIR_TEMP}/proxy.sh"
	echo "if [ ! -d \"\${DIRECTORY}\" ]; then" >>"${DIR_TEMP}/proxy.sh"
	echo "	mkdir -p \"\${DIRECTORY}\" >>\"\${LOG_ERRS#*/}\" 2>&1 || { echo \"ERROR: The storage directory (DIRECTORY) does not exist and could not be created.\" | tee -a \"\${LOG_ERRS#*/}\"; exit 1; }" >>"${DIR_TEMP}/proxy.sh"
	echo "fi" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo "if [ \"\$(ls -A \"\$DIRECTORY\" 2>/dev/null)\" ]; then" >>"${DIR_TEMP}/proxy.sh"
	echo "	showMsg 'prompt' \"This looks like the second invocation of the script. Do you want to install\nthe packages from the removable media into this device? [Y/N] (N): \" 'screen' 0 1 1" >>"${DIR_TEMP}/proxy.sh"
	echo "	read" >>"${DIR_TEMP}/proxy.sh"
	echo "	[ \"\$REPLY\" != 'Y' ] && [ \"\$REPLY\" != 'y' ] && exitGracefully 0 'both' 6 'success'" >>"${DIR_TEMP}/proxy.sh"
	echo "	TEMP=\"\$(pwd)\"" >>"${DIR_TEMP}/proxy.sh"
	echo "	pax -D none -X \"\${TEMP%/*}\" -i" >>"${DIR_TEMP}/proxy.sh"
	echo "	exitGracefully 0 'both' 6 'success'" >>"${DIR_TEMP}/proxy.sh"
	echo "fi" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo "cd \"\$DIRECTORY\" >>\"$LOG_ERRS\" 2>&1 || exitGracefully 2 'screen'" >>"${DIR_TEMP}/proxy.sh"					# NOTE: we need to cd immediately so the log file doesn't get split into various spots
	echo >>"${DIR_TEMP}/proxy.sh"
	echo '# Start Execution' >>"${DIR_TEMP}/proxy.sh"
	echo "showMsg 'start' \"\n\n---------- [ Script Execution ] ----------\" 'log'" >>"${DIR_TEMP}/proxy.sh"
	echo "showMsg 'start' \"           \$(date +'%Y-%m-%d  %H:%M:%S')\n\" 'log'" >>"${DIR_TEMP}/proxy.sh"
	echo "showMsg 'start' "\${0##*/} \$@" 'log'" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo "[ \"\$DEPS\" != 'none' ] && showMsg 'action' \"Processing dependencies for the packages...\" 'both' 1 4" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo "for PARAMETER in \$(cat ../proxy.list); do" >>"${DIR_TEMP}/proxy.sh"
	echo "	splitName \"\$PARAMETER\"" >>"${DIR_TEMP}/proxy.sh"
	echo "	processDependencies \"\${PARAMETER}\" 'FALSE'" >>"${DIR_TEMP}/proxy.sh"
	echo "done" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo "[ \"\$COPY\" ] && showMsg 'action' \"Copying the specified package(s)...\" 'both' 1 4" >>"${DIR_TEMP}/proxy.sh"
	echo "[ \"\$DOWNLOAD\" ] && showMsg 'action' \"Downloading the specified package(s)...\" 'both' 1 4" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo "while [ \"\$DEPENDENCY\" ] && [ \$INDEX -gt 0 ]; do" >>"${DIR_TEMP}/proxy.sh"
	echo "	splitName \"\$DEPENDENCY\"" >>"${DIR_TEMP}/proxy.sh"
	echo >>"${DIR_TEMP}/proxy.sh"
	echo "	if [ \"\$DOWNLOAD\" ]; then" >>"${DIR_TEMP}/proxy.sh"
	echo "		showMsg 'file' \"(\${FILETYPE}) ${PACKAGE}:\" 'both' 0 3" >>"${DIR_TEMP}/proxy.sh"
	echo "		downloadPackage || exitGracefully 1" >>"${DIR_TEMP}/proxy.sh"
	echo "	elif [ \"\$COPY\" ]; then" >>"${DIR_TEMP}/proxy.sh"
	echo "		showMsg 'file' \"(\${FILETYPE}) \${PACKAGE}:\" 'both' 0 3" >>"${DIR_TEMP}/proxy.sh"
	echo "		copyPackage || exitGracefully 1" >>"${DIR_TEMP}/proxy.sh"
	echo "	fi" >>"${DIR_TEMP}/proxy.sh"
	echo "	showMsg 'file' \" [done]\" 'both' 1 5" >> "${DIR_TEMP}/proxy.sh"
	echo "	deleteDependency 'd'" >> "${DIR_TEMP}/proxy.sh"
	echo "done">>"${DIR_TEMP}/proxy.sh"
}


# Usage syntax: unloadPackage
# Overview:	performs the actual work of deleting the package contents from the system no matter if they were copied or symlinked
# Notes:	the package unload-able checking is performed in processDependencies()
#		if [ "$PARAMETER" != "$FILENAME" ] then a specific version was passed
#		http://forum.tinycorelinux.net/index.php/topic,5012.msg26650.html#msg26650
unloadPackage() {
	local PARAMS=''
	local FILE=''
	local SOURCE

	if [ -e "${REPO_SOURCE}/${FILENAME}" ]; then SOURCE="$REPO_SOURCE"			# if the package is in the specified directory, then...
	elif [ -e "${REPO_OPTION}/${FILENAME}" ]; then SOURCE="$REPO_OPTION"			# if the package is in the REPO_OPTION directory, then...
	elif [ -e "${REPO_SYSTEM}/${FILENAME}" ]; then SOURCE="$REPO_SYSTEM"; fi		# if the package is in the REPO_SYSTEM directory, then...

	MODE='copy'

	[ $DEBUG -gt 0 ] && { echo -en "unloadPackage:\n\tPARAMETER   |${PARAMETER}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${ARCH}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\tOPTFILE     |${OPTFILE}|\n\tSOURCE      |${SOURCE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         |" >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	showMsg 'file' "(${FILETYPE}) ${PACKAGE}:" 'both' 0 1
	[ "$DRYRUN" ] && showMsg 'notice' " [dryrun]" 'both' 0 0

# UPDATED 2026/01/12 - we use BASENAME not FILENAME
#	[ "$UNLOAD" != 'unload2' ] && [ ! -e "${DIR_LIST}/${FILENAME}" ] && {			# if the package has been marked for uninstallation (unlist, delete, purge, or update) -AND- it currently is NOT installed, then...
	[ "$UNLOAD" != 'unload2' ] && [ ! -e "${DIR_LIST}/${BASENAME}" ] && {			# if the package has been marked for uninstallation (unlist, delete, purge, or update) -AND- it currently is NOT installed, then...
		uninstallPackage || return 1							#   uninstall the package files
		return 0									#   no need to process anything further!
	}

	showMsg 'step' " [unload]" 'both' 0 0

	# if the package has a service start/stop script, then stop the service before continuing
	if [ -e "${DIR_INIT}/${PACKAGE}" ]; then
		[ $DEBUG -gt 0 ] && echo -e "\tPackage has service script...\n\tCalling:    \"${DIR_INIT}/${PACKAGE}\" stop" >>"$LOG_DBUG"
# UPDATED 2026/01/15
#		[ ! "$DRYRUN" ] && { "${DIR_INIT}/${PACKAGE}" stop >>"$LOG_ERRS" 2>&1 || return 1; }
		[ ! "$DRYRUN" ] && "${DIR_INIT}/${PACKAGE}" stop >>"$LOG_ERRS" 2>&1		# NOTE: we no longer return with an error since a poorly written script would mess up an entire uninstall chain; any errors are logged though
	fi

	# determine how the package was installed (copied or symlinked) -AND- make sure it's not in use by something else
	if ( /bin/mount 2>>"$LOG_ERRS" | grep -q "${DIR_LOOP}/${BASENAME} type squashfs" ); then						# if the package has been mounted and symlinked, then...
		MODE='link'
		[ $DEBUG -gt 0 ] && echo -e "\tPackage is symlinked...\n\tCalling:    sudo /bin/umount -d \"${DIR_LOOP}/${BASENAME}\"" >>"$LOG_DBUG"
# UPDATED 2026/01/15
#		[ ! "$DRYRUN" ] && { sudo /bin/umount -d "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || return 1; }				#   umount the squashfs file to make sure no contents are being used by other software (thanks Marco Caminati)
		[ ! "$DRYRUN" ] && { sudo /bin/umount -d "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || return 0; }				#   umount the squashfs file to make sure no contents are being used by other software (thanks Marco Caminati)
	elif [ $DEBUG -gt 0 ]; then
		echo -e "\tPackage is copied..." >>"$LOG_DBUG"
	fi

	# NOTE: some of these actions can take place even if it's a DRYRUN
	[ ! -e "${DIR_LOOP}/${BASENAME}" ] && {			# if the mount point doesn't exist, then create it!
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    mkdir -p \"${DIR_LOOP}/${BASENAME}\"" >>"$LOG_DBUG"
		mkdir -p "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || return 1
	}

	[ $DEBUG -gt 0 ] && echo -e "\tCalling:    sudo /bin/mount \"${SOURCE}/${FILENAME}\" \"${DIR_LOOP}/${BASENAME}\" -t squashfs -o loop,ro" >>"$LOG_DBUG"
	( [ ! "$DRYRUN" ] || ( [ "$DRYRUN" ] && [ "$MODE" = 'copy' ] ) ) && { sudo /bin/mount "${SOURCE}/${FILENAME}" "${DIR_LOOP}/${BASENAME}" -t squashfs -o loop,ro >>"$LOG_ERRS" 2>&1 || return 1; }	# now mount it for processing
	if [ ! "$DRYRUN" ] && [ "$MODE" = 'copy' ]; then
		for FILE in $(find "${DIR_LOOP}/${BASENAME}" ! -type d 2>>"$LOG_ERRS" | sed "s|^${DIR_LOOP}/${BASENAME}||"); do			# scan to make sure that no software in the package is being used
# UPDATED 2026/01/15
#			fuser "$FILE" >>"$LOG_ERRS" 2>&1 && return 1				#   if one of the files in the package is currently in use, then exit this function	https://liquidat.wordpress.com/2015/08/26/short-tip-show-processes-accessing-a-file-fuser-lsof/   http://unix.stackexchange.com/questions/60492/whats-the-difference-between-lsof-and-fuser-uvm
			fuser "$FILE" >>"$LOG_ERRS" 2>&1 && return 0				#   if one of the files in the package is currently in use, then exit this function	https://liquidat.wordpress.com/2015/08/26/short-tip-show-processes-accessing-a-file-fuser-lsof/   http://unix.stackexchange.com/questions/60492/whats-the-difference-between-lsof-and-fuser-uvm
		done
	fi

	# check if the package has any libs we need to unload later				  NOTE: we check this way because simply checking for the directory can produce false positives
	[ $DEBUG -gt 0 ] && echo -en "\tChecking for libraries and modules:" >>"$LOG_DBUG"
	( ls -1p "${DIR_LOOP}/${BASENAME}/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE	# NOTE: the "grep -qv '/'$" removes directories from the listing so only files remain (otherwise /lib/modules/ would provide a false positive)
	( ls -1p "${DIR_LOOP}/${BASENAME}/lib64" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	( ls -1p "${DIR_LOOP}/${BASENAME}/usr/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	( ls -1p "${DIR_LOOP}/${BASENAME}/usr/local/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	# check if the package has a [/usr[/local]]'/lib/modules' directory to indicate we need to load modules later
	[ -d "${DIR_LOOP}/${BASENAME}/lib/modules" ] || [ -d "${DIR_LOOP}/${BASENAME}/usr/lib/modules" ] || [ -d "${DIR_LOOP}/${BASENAME}/usr/local/lib/modules" ] && MODULES=TRUE		# NOTE: we CAN simply check for directories here since files would be packaged under them
	[ $DEBUG -gt 0 ] && [ "$LIBRARIES" ] && echo -n " [libraries]" >>"$LOG_DBUG"
	[ $DEBUG -gt 0 ] && [ "$MODULES" ] && echo -n " [modules]" >>"$LOG_DBUG"
	[ $DEBUG -gt 0 ] && echo " [done]" >>"$LOG_DBUG"

	# if we've made it here, delete all the files/dirs contained in the package from the OS
	[ "$UNLOAD" != 'purge2' ] && PARAMS='! -path "*/etc/*"'					# if we have been instructed to NOT purge any 'etc' files, then add these parameters to the 'find' calls below   http://www.cyberciti.biz/faq/find-command-exclude-ignore-files/

	[ $DEBUG -gt 0 ] && echo -e "\tRemoving package contents from filesystem..." >>"$LOG_DBUG"
	for FILE in $(eval find "${DIR_LOOP}/${BASENAME}" $PARAMS 2>/dev/null | tail -n +2 | sed "s|^${DIR_LOOP}/${BASENAME}/||" | sort -r); do	# NOTE: the 'tail' removes the first line (mount point); we 'sort -r' to place the file above the directories since they have to be removed first!
		( echo "$DIRECTORY" | grep -q '\.'$ ) && TEMP="${DIRECTORY}${FILE}" || TEMP="${DIRECTORY}/${FILE}"				# adjusts the path if the DIR_LIVE ends with a dot (e.g. /Users/Public/.etc/pax)
		if [ ! -d "${TEMP}" ]; then							#   if the iterated FILE is anything but a directory (e.g. device file, symlink, text file, ...), then delete it!
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rm -f \"${TEMP}/\"" >>"$LOG_DBUG"
# REVERTED 2026/01/15
			[ ! "$DRYRUN" ] && { rm -f "${TEMP}" >>"$LOG_ERRS" 2>&1 || return 1; }
#			[ ! "$DRYRUN" ] && rm -f "${TEMP}" >>"$LOG_ERRS" 2>&1			#   NOTE: we no longer return with an error here in case of a trivial matter (e.g. a file is missing) that would mess up an entire uninstall chain; any errors are logged though
		elif [ -d "${TEMP}" ] && [ ! "$(ls -A "${TEMP}" 2>/dev/null)" ]; then		#   otherwise it is a directory, so check if it's empty and delete it if so!
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rmdir \"${TEMP}\"" >>"$LOG_DBUG"
			[ ! "$DRYRUN" ] && rmdir "${TEMP}" >>"$LOG_ERRS" 2>&1			#   NOTE: we do NOT error out here if we can't delete it!
		fi
	done

	[ ! "$DRYRUN" ] && 
	[ -e "${DIR_LIST}/${BASENAME}" ] && {
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rm -f \"${DIR_LIST}/${BASENAME}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/${BASENAME}" >>"$LOG_ERRS" 2>&1		# delete the installed marker
	}
# REMOVED 2026/01/12 - we use BASENAME not FILENAME
#	[ -e "${DIR_LIST}/${FILENAME}" ] && {
#		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rm -f \"${DIR_LIST}/${FILENAME}\"" >>"$LOG_DBUG"
#		[ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/${FILENAME}" >>"$LOG_ERRS" 2>&1		# delete the installed marker
#	}
	[ -e "${DIR_LIST}/${BASENAME}.${EXT_HASH}" ] && {
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rm -f \"${DIR_LIST}/${BASENAME}.${EXT_HASH}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/${BASENAME}.${EXT_HASH}" >>"$LOG_ERRS" 2>&1
	}
	[ -e "${DIR_LIST}/${BASENAME}.${EXT_DEPS}" ] && {
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rm -f \"${DIR_LIST}/${BASENAME}.${EXT_DEPS}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/${BASENAME}.${EXT_DEPS}" >>"$LOG_ERRS" 2>&1
	}
	[ -e "${DIR_LIST}/${BASENAME}.${EXT_INFO}" ] && {
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rm -f \"${DIR_LIST}/${BASENAME}.${EXT_INFO}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/${BASENAME}.${EXT_INFO}" >>"$LOG_ERRS" 2>&1
	}
	if [ ! "$DRYRUN" ] || ( [ "$DRYRUN" ] && [ "$MODE" = 'copy' ] ); then
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    sudo /bin/umount -d \"${DIR_LOOP}/${BASENAME}\"" >>"$LOG_DBUG"
		sudo /bin/umount -d "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || return 1	# finally umount the package

		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    rmdir \"${DIR_LOOP}/${BASENAME}\"" >>"$LOG_DBUG"
		rmdir "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1				# delete the packages mount point
	fi

	# if we also need to uninstall (delete, purge, or update), then...
	[ "$UNLOAD" != 'unload2' ] && { uninstallPackage || return 1; }				# if the package has been marked for uninstallation, then...
# VER2 - when installing, and a file exists (e.g. grep symlink to busybox), then rename to FILE.-PACK.TYPE (or 'SYS' if not part of package); when the PACK.TYPE is uninstalled and one of those files exists, restore it
#		is this necessary if we are creating restore points?

	return 0
}


# Usage syntax: uninstallPackage
# Overview:	performs the work of actually removing the package files (not contents - see unloadPackage()), optionally to a restore point
# Notes:	this should be called after the package has been unloaded first!!!
uninstallPackage() {
	local SOURCE=''

	if [ -e "${REPO_SOURCE}/${FILENAME}" ]; then SOURCE="$REPO_SOURCE"			# if the package is in the specified directory, then...
	elif [ -e "${REPO_OPTION}/${FILENAME}" ]; then SOURCE="$REPO_OPTION"			# if the package is in the REPO_OPTION directory, then...
	elif [ -e "${REPO_SYSTEM}/${FILENAME}" ]; then SOURCE="$REPO_SYSTEM"; fi		# if the package is in the REPO_SYSTEM directory, then...

	# remove the package from the specified list
	if [ "$UNLOAD" != 'unload2' ] && [ "$UNLOAD" != 'update2' ]; then
		[ "$PACKLIST" = 'boot' ] && TEMP="${LIST_BOOT}"
		[ "$PACKLIST" = 'live' ] && TEMP="${LIST_LIVE}"

		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    sed -i \"/${FILENAME}/d\" \"${REPO_PREFIX}/${TEMP}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && ( grep -q "$FILENAME" "${REPO_PREFIX}/${TEMP}" 2>>"$LOG_ERRS" ) && sed -i "/${FILENAME}/d" "${REPO_PREFIX}/${TEMP}" 2>>"$LOG_ERRS"				# if this is a requested package and not one of its dependencies (via INDEX==1) -AND- we're are actually uninstalling (deleting or purging), then remove the package from the LIST file

		[ "$UNLOAD" = 'unlist2' ] && return 0						# if we're unlisting the package, then we can now exit
	fi

	# if we've made it down here then we need to delete package files

	[ $DEBUG -gt 0 ] && { echo -en "uninstallPackage:\n\tPARAMETER   |${PARAMETER}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${ARCH}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\tOPTFILE     |${OPTFILE}|\n\tSOURCE      |${SOURCE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         |" >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }
	if [ "$RESTORE" = 'none' ]; then							# if we do NOT need a restore point (via -u -R none), then...
		showMsg 'step' " [${UNLOAD%2*}]" 'both' 0 0					# remove the trailing '2' (indicating the second stage of processing)

		[ $DEBUG -gt 0 ] && echo -e "\tSkip creating a restore point...\n\trm -f ${SOURCE}/${BASENAME}.*" >>$LOG_DBUG
		[ ! "$DRYRUN" ] && { rm -f "${SOURCE}/${BASENAME}".* >>"$LOG_ERRS" 2>&1 || return 1; }						# just delete the packages' files (e.g. .deps, .hash, .soft, ...) and exit
		return 0
	fi

	# if we've made it here then we need to create a restore point
	[ $DEBUG -gt 0 ] && echo -e "\tCreating a restore point..." >>$LOG_DBUG
	showMsg 'step' " [archive]" 'both' 0 0

# VER2 - this will be re-worked in XiniX so this step will no longer be necessary; the /var, /etc directories will be mounted to DATA; DIR_MOUNT does not exist so this code isn't being executed
#	# For XiniX only so the archives have permanence
#	if [ ! -e "${REPO_RESTOR}" ] && [ -e "${DIR_MOUNT}/DATA/Links" ]; then			# if the root-level restore directory doesn't exist (e.g. /var/restore/2017-01-01 > /var/restore) -AND- there's a DATA, then...
#		if [ ! -e "${DIR_MOUNT}/DATA/Links${REPO_RESTOR}" ]; then
#			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    mkdir -p \"${DIR_MOUNT}/DATA/Links${REPO_RESTOR}\"" >>"$LOG_DBUG"
#			if [ ! "$DRYRUN" ]; then
#				mkdir -p "${DIR_MOUNT}/DATA/Links${REPO_RESTOR}" >>"$LOG_ERRS" 2>&1 || {					#   create the restore directory on the DATA partition so that it actually gets preserved between reboots of the device
#					echo "ERROR: the restore directory could not be created." >>"$LOG_ERRS"					# NOTE: we only write this to the log
#					return 1
#				}
#			fi
#		fi
#		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    ln -sf \"${DIR_MOUNT}/DATA/Links${REPO_RESTOR}\" \"${REPO_RESTOR}\"" >>"$LOG_DBUG"
#		if [ ! "$DRYRUN" ]; then
#			ln -sf "${DIR_MOUNT}/DATA/Links${REPO_RESTOR}" "${REPO_RESTOR}" >>"$LOG_ERRS" 2>&1 || {					#   now symlink to it so we can reference its contents
#				echo "ERROR: The symlink to the restore directory could not be created." >>"$LOG_ERRS"				# NOTE: we only write this to the log
#				return 1
#			}
#		fi
#	fi

	# now create a unique name for the restore point: ACTION PACKAGE_NAMES/DIR_NAME (e.g. Updating sdl)
	if ( ! echo "$DEPENDENCY" | grep -qe ^'+' ); then
		RPD="$(date +%F)/"
		[ "$INSTALL" ] && [ "$RESTORE" ] && RPD="${RPD}Restored ${BASENAME}"		# add a description of this process to the restore point
		[ "$UNLOAD" = 'update2' ] && RPD="${RPD}Updated ${BASENAME}"			# add a description of this process to the restore point
		( [ "$UNLOAD" = 'delete2' ] || [ "$UNLOAD" = 'purge2' ] ) && RPD="${RPD}Uninstalled ${BASENAME}"

		[ -e "${REPO_RESTOR}/${RPD}" ] && RPD="${RPD} $(date +%T)"			# if the restore point already exists (e.g. manipulating various package versions), then append time at the end
	fi

	# NOTE: the below line will create the entire REPO_RESTOR directory structure if there is no DATA, or just the date directory in the event there is one
	if [ ! -e "${REPO_RESTOR}/${RPD}" ]; then
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    mkdir -p \"${REPO_RESTOR}/${RPD}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && { mkdir -p "${REPO_RESTOR}/${RPD}" >>"$LOG_ERRS" 2>&1 || return 1; }						# if the restore point directory doesn't exist, then create it!
	fi

	[ $DEBUG -gt 0 ] && echo -e "\tCalling:    mv -f ${SOURCE}/${BASENAME}.* \"${REPO_RESTOR}/${RPD}\"" >>"$LOG_DBUG"
	[ ! "$DRYRUN" ] && { mv -f "${SOURCE}/${BASENAME}".* "${REPO_RESTOR}/${RPD}" >>"$LOG_ERRS" 2>&1 || return 1; }				# now move the iterated dependency into the restore point	NOTE: it will be symlinks if VERSION has a value

	return 0
}




# LOAD VARIABLE PERSONALIZATION

[ -e "${DIR_CONF}/config" ] && . "${DIR_CONF}/config"						# overwrite any of the variables set above by reading in a global config file
[ -e "${HOME}/.$(echo "${DIR_CONF}" | tail -c +2)/config" ] && . "${HOME}/.$(echo "${DIR_CONF}" | tail -c +2)/config"				# same using a personalized config file - using XSB
[ -e "${HOME}/.${DIR_CONF##*/}/config" ] && . "${HOME}/.${DIR_CONF##*/}/config"			# same using a personalized config file - using LSB




# SCRIPT PARAMETER PROCESSING

if [ "$1" = '--help' ]; then									# displays ACTION and OPTION help for this script
	TEMP="${0##*/}"										# isolate just the script name

	echo
	echo " This script provides package management for a Linux distro that currently does"
	echo " not have this functionality, or is interested in switching from its existing"
	echo " implementation. The packages created and used by this system can be copied out"
	echo " or mounted and linked-to using the read-only and compact squashfs file system."
	echo
	echo "  Usage: ${TEMP} [OPTIONS] ACTION {PACKAGE(S)|FILELIST} [DIRECTORY]"
	echo
	echo '  ACTIONS:'
#	echo '	-a   '
#	echo '	-b   '
	echo '	-c   copy local packages to another directory'
	echo '	-d   download package(s) only'
	echo '	-e   extract local package(s) contents'
	echo '	-f   find which local package(s) a file belongs to'
#	echo '	-g   '
#	echo '	-h   '
	echo '	-i   install package(s)'
#	echo '	-j   '
#	echo '	-k   '
# VER2 - ability to show packages that are downloaded, but not installed (e.g. -l -Q none > *package_name [* indicating is downloaded but not installed]); also '-l -Q default' just lists: package, version; '-l -Q verbose' lists the current way with all the package info
	echo '	-l   list all currently installed packages'
	echo '	-m   make a new package (requires DIRECTORY)'					# this makes a new .soft package tarball based on the passed directory; 	NOTE: you can just have the .make file call builder to do all the heavy lifting
#	echo '	-n   '
	echo '	-o   open a fifo for (remote) communication'					# this will allow remote administration; uses DIR_TEMP/input
# VER2 - check for updates to installed packages (compare the version numbers in the local .list files vs ones dl'ed from repo server); use cron to do this regularly
#	echo '	-p   process updates for installed packages'
#			check		one-time check for updates and notifies
#			download	one-time check and download of updates
#			install		one-time check, download, and install of updates	  just calls 'pax -p' for the first two steps, then 'pax -u update' for the install
#			checks(etup)	installs a cron job to routinely check and notify
#			downloads(etup)	installs a cron job to routinely check and download
#			installs(etup)	installs a cron job to routinely do everything
#			deletes(etup)	deletes any existing update cron job
#	echo '	-q   '
#	echo '	-r   '
# VER2 - implement the below; it's like apt-search; this needs to work with both directory structure and URL submissions; make it so you can search for packages (names) or files (within a package, like the -f action but for all packages in the repo)
#		maybe create a php file that can be used in TC repo to allow this
#	echo '	-s   search the repo to find matches of passed term(s)'
#		non-db queries will need to download all the manifest files and grep them to find the file
#		db queries will need to utilize another variable REPO_QUERY specifying the URI of the script to submit the search to
	echo '	-t   show the dependency trees of package(s): relies, reliant'
# DEV NOTE: you must be in the directory that contains the updates when doing '-u update' so that the -S and DIRECTORY values will still work; -S for where the existing installed package file is (in case it is not in REPO_OPTION); pwd is used to install from
#		update: uninstalls the existing package (creating a restore point unless told not to)
#		unload: unloads the application (and all possible dependencies) from the file system, leaving the package in the optional.list file
#		unlist: does the same as 'unload' but also removes the packages from optional.list
#		delete: same as unlist, but deletes the package files from REPO_SOURCE, REPO_OPTION, REPO_SYSTEM, leaving /etc files
#		purge : same as delete, but also removes /etc files
	echo '	-u   uninstall package(s): update, unload, unlist, delete, purge'
	echo "	-v   validate package(s) info: data, deep, deps, fix"				# makes sure all data files/dirs from packages are installed, all the dependencies are installed, validate contents md5sum checks, ownership and permissions are correct; data=files,dirs,hash,owner,perms
#	echo '	-w   '
#	echo '	-x   '
#	echo '	-y   '
	echo '	-z   populates DIR_LIST with package files'
	echo
	echo '	--help      shows this screen'
	echo '	--install   installs pax as the default package manager'
	echo '	--uninstall uninstalls pax as the default package manager'
	echo '	--version   displays the software version'
	echo
	echo '  OPTIONS:'
# VER2 - implement
#	echo '	-A   approval code/key from the server when making purchases'			# so after the software is purchased, the code/key can be passed as authentication to download the software package(s)
	echo '	-B   indicates we are currently booting the system'				# use this to indicate everything gets installed to root (PREFIX=/) and obtain files from REPO_SYSTEM
	echo '	-C   specifies an alternative CPU architecture: i32, i64, r32, r64'		# this allows for alternative CPU software downloads		r01 (raspi 0 and 1), r23 (raspi 2 and 3)
# DEV NOTE: a 'source' value indicates that all dependencies need to come from a single source location (specified by -S or the default action location); this will prevent the ability to use 'all'; 'none' would only take from the specified location anyways, and 'default' grabs from wherever the package can be found
	echo '	-D   dependency handling: none, default, all, source'
	echo '	-E   include extra package files: all, code, cpio, info, list, make'		# not installed by default to keep size down
	echo '	-F   force the ACTION to take place'						# NOTE: this ignores the package installed status on the existing system so if we need to download packages to another device (e.g. installing XiniX to other media) we can do so
#	echo '	-G   '
#	echo '	-H   '
	echo '	-I   list of dependencies to ignore'						# for example, web.de can be listed for theme uninstalls
#	echo '	-J'
	echo '	-K   specifies an alternative kernel name (4.1.6_xinix)'			# this allows for alternative kernel software downloads
	echo '	-L   the list to adjust: none, boot, live'					# this only is useful when installing
	echo '	-M   defines the package install mode: copy, link (default)'			# if the OS is run from RAM, then the 'copy' value will copy into RAM, if it is on a disk, then it copies to the disk
	echo '	-N   do NOT install all files in the package, just those specified'		# allows users to install desired file(s) from a package so all the contents don't get installed (to keep the system as small as possible); keeps attack vector to a minimum
# VER2 - implement the 'html' values
	echo '	-O   display output format: fifo, text, xml, xmLive'
	echo '	-P   prompt before taking action'
# VER2 - 'default' just shows the final action (without the header), verbose shows the current 'default', 'none' shows everything - duplicates, etc	-OR- add a 'brief' value to just show the final action
	echo '	-Q   quiets the output: all, errors, default, verbose, none'
	echo '	-R   the action applies to restore points'
	echo '	-S   changes the source directory/repo to obtain software from'			# mainly used when creating installation media to pull the files from an existing BOOT instead of an online repo
	echo '	-T   specifies the package type: bin, dev, doc, drv, gir, lib, loc'
#	echo '	-U   '
# DEV NOTE: can use -S and DIRECTORY to validate files on a separate hard drive (e.g. diagnostics using one computer for another computers' hard drive via USB)
	echo '	-V   the specific version of a package to install'
#	echo '	-W'
# VER2 - proxy other actions via ssh so that administrators can push software to clients, or reinstall/delete software that's currently installed
	echo '	-X   obtain packages via proxy using another device'				# Can be used when one location has little or no Internet access. For example, @home has bad internet connection, but work is good, can dl @work for @home.
	echo '	-Y   performs a dry run of the action'
	echo '	-Z   add color to the output'
	echo
	echo '  NOTES:'
	echo "	The '-e' ACTION will always overwrite data due to the unsquashfs binary"
	echo "	     always exiting with success - even when it fails if data already"
	echo "	     exists in the target destination."
	echo "	The '-i' ACTION first checks locally, then uses the repo."
	echo "	     NOTES:"
	echo "	     - For faster processing when DIRECTORY is used for PACKAGE(S),"
	echo "	       include a '-D none' option, skipping that check"
	echo "	The '-m' ACTION can be used with pre-compiled software, or if a .make"
	echo "	     file is present, it will execute it to compile everything."
	echo "	     NOTES:"
	echo "	     - only one package can be processed per script execution"
	echo "	     - place the .make file alongside the source code directory"
	echo "	     - if using a .make file, install the compiled software into a"
	echo "	       'package' directory alongside the .make file and source code"
	echo "	The '-o' ACTION requires the 'clear' command to always be last."
	echo "	The '-u' ACTION will always leave user data in place (docs, pics, etc)."
	echo "	     NOTES:"
	echo "	     - Unloading removes the application files, but leaves the config"
	echo "	       files and package for easy future re-installation"
	echo "	     - Deleting leaves the configs, but removes the application files"
	echo "	       and the package so it would need to be re-downloaded before"
	echo "	       another installation could occur"
	echo "	     - Purging does the same as deleting, but also deletes the config"
	echo "	       files as well"
	echo "	     - When updating packages, you need to be in the directory that"
	echo "	       contains the updates before starting this script"
	echo "	The '-v' ACTION can perform various package integrity checks:"
	echo "	     - data: ownership, permissions, {symlink source|file size}"
	echo "	     - deps: verifies the package dependencies are all installed"
	echo "	     - fix : resolves any issues detected"
	echo "	     - hash: same as 'data' but md5sum hashes instead of file size"
	echo "	The '-D' OPTION will search for dependencies in the following manner:"
	echo "	     - none: no searching, file must be in the specified location"
	echo "	     - default: searches in REPO_SOURCE, REPO_OPTION, REPO_SYSTEM"
	echo "	     - all: same as 'default'"
	echo "	     - source: all dependencies must be in the specified location"
	echo "	The '-I' OPTION value must be comma separated."
	echo "	The '-N' OPTION takes a comma separated list of filenames, or a quoted"
	echo "	     space separated list. This option also implies '-D none'."
	echo "	The '-O' and '-Q' OPTIONS need to start the parameters (for init errs)."
	echo "	The '-O xmLive' OPTION does NOT encapsulate with <s> tags, so assume"
	echo "	     success unless an <f> tag is relayed."
	echo "	When using '-O fifo', the fifo must be managed by the calling script"
	echo "	     or binary, and must use DIR_TEMP/output as its location."
	echo "	The '-R' OPTION can only be used with the '-i', '-l', and '-u' ACTIONS."
	echo "	     The '-u' can take '-R none' to skip creating a restore point."
	echo "	The '-S' OPTION can take a directory or URL as its value."
	echo "	     URL's need to begin with 'http' or 'ftp'."
	echo "	The '-T' OPTION can only be used once per call, so all the packages"
	echo "	     need to be of the same type. Alternatively, you can skip using"
	echo "	     this option and specify the full name of each package."
	echo "	The '-U' OPTION will default to '-D all' unless specified otherwise"
	echo "	     to keep the system as tidy as possible."
	echo "	When using the '-V' OPTION, you can only list one package at a time."
	echo
	echo "	The PACKAGE(S) value can be:"
	echo "	     - a file containing a list (one package per line)"
	echo "	     - directory containing the package(s)"
	echo "	     - or a space separated list of package names"
	echo "	The DIRECTORY as the last parameter must be:"
	echo "	     - a full path: /tmp/pax/"
	echo "	     - or a relative path: ./pax"
	echo "	     - or have a trailing slash: pax/"
	echo
	echo "	The presence of a REPO_PREFIX/${FLAG_COPY} file will indicate that"
	echo "	     all packages will be copied instead of symlinked."
	echo "	The presence of a REPO_PREFIX/${FLAG_FIRM} file will indicate that"
	echo "	     all the packages in REPO_SYSTEM or LIST_BOOT will be copied"
	echo "	     instead of symlinked."
	echo
	echo '  EXAMPLES:'
	echo '	Performing action with all packages [to current directory]:'
	echo "	     ${TEMP} -{ceilt}"
	echo '	Performing action with specific packages [to current directory]:'
	echo "	     ${TEMP} -{cdeilt} package1 package2"
	echo '	Performing action with package list [to current directory]:'
	echo "	     ${TEMP} -{cdeilt} packages.txt"
	echo '	Performing action with specific packages to/in a specified directory:'
	echo "	     ${TEMP} -{cdeilt} package1 package2 /target/path"
	echo '	Performing action with a package list to/in a specified directory:'
	echo "	     ${TEMP} -{cdeilt} packages.txt /target/path"
	echo '	Performing action with specific packages from/in a specified directory:'
	echo "	     ${TEMP} -S {URL|/source/path} -{cdeilt} package1 package2"
	echo '	Performing action with a package list from/in a specified directory:'
	echo "	     ${TEMP} -S {URL|/source/path} -{cdeilt} packages.txt"
	echo '	Performing action with all packages between specified directories:'
	echo "	     ${TEMP} -S {URL|/source/path} -{cdei} /target/path"
	echo '	Performing action with a package list between specified directories:'
	echo "	     ${TEMP} -S {URL|/source/path} -{cdei} packages.txt /target/path"
	echo
	echo '	Find files in available packages:'
	echo "	     ${TEMP} -f file1 file2"
	echo '	Find files in available packages from a filelist:'
	echo "	     ${TEMP} -f files.txt"
	echo '	Find files in packages within a specified directory:'
	echo "	     ${TEMP} -f file1 file2 /source/path"
	echo "	     ${TEMP} -S /source/path -f file1 file2"
	echo '	Install a specific version:'
	echo "	     ${TEMP} -V 1.2.3 -i package"
	echo '	Install a package from a valid restore point:'
	echo "	     ${TEMP} -R 'YYYY-MM-DD/Restore Point' -i package"
	echo '	List all restore points:'
	echo "	     ${TEMP} -R '*' -l"
	echo '	List all restore points in a valid date:'
	echo "	     ${TEMP} -R 'YYYY-MM-DD' -l"
	echo '	List all packages in a valid restore point:'
	echo "	     ${TEMP} -R 'YYYY-MM-DD/Restore Point' -l"
	echo '	Make a package for distribution:'
	echo "	     ${TEMP} -m package /path/containing/{package|source}"
	echo "	     ${TEMP} -S /path/containing/{package|source} -m package"
	echo "	     ${TEMP} -S /path/containing/{package|source} -m file"
	echo '	Open a fifo to operate pax:'
	echo "	     ${TEMP} -o"
	echo '	Open a fifo to operate pax in a specified directory:'
	echo "	     ${TEMP} -o /path/to/fifo"
	echo "	     ${TEMP} -S /path/to/fifo -o"
	echo '	Open a fifo to operate pax using a specific fifo:'
	echo "	     ${TEMP} -o name"
	echo '	Open a fifo to operate pax, clearing a prior failure:'
	echo "	     ${TEMP} -o clear"
	echo '	Open a fifo to operate pax, clearing and using specific fifo:'
	echo "	     ${TEMP} -o name clear"
	echo '	Proxy a download:'
	echo "	     ${TEMP} -X /mnt/sdb1 -d package1 package2"
	echo '	Proxy an install:'
	echo "	     ${TEMP} -X /mnt/sdb1 -i package1 package2"
	echo '	Unload a package:'
	echo "	     ${TEMP} -u unload package"
	echo '	Uninstall a package, leaving configs:'
	echo "	     ${TEMP} -u delete package"
	echo '	Uninstall a package, including configs too:'
	echo "	     ${TEMP} -u purge package"
	echo '	Uninstall a package, without a restore point:'
	echo "	     ${TEMP} -R none -u delete package"
	echo '	Update a package (uninstall old, install new):'
	echo "	     ${TEMP} -u update package"
	echo '	Delete a restore point(s):'
	echo "	     ${TEMP} -R 'DATE[/Restore Point]' -u {delete|purge}"
	echo
	exit 0
elif [ "$1" = '--install' ] || [ "$3" = '--install' ]; then					# so a user can do 'pax -O xml --install'
	if [ $# -gt 1 ]; then									# if we were passed more than just the '--version' option, it has to be '-O', so...
		if ( echo "$2" | grep -qE ^'(fifo|text|xml|xmLive)'$ ); then
			[ "$SILENT" ] || echo "ERROR: you must supply a proper value to the -O option." | tee -a "$LOG_ERRS"			# NOTE: we can't use showMsg() yet because we don't have it's value, so...
			exit 1
		fi
		OUTPUT=$2									# set that value to use from now on
	fi
	[ ! -e "${DIR_CONF}/install" ] && {
		showMsg 'failure' "The install script is missing to make pax the default package manager." 'screen'
		exit 1
	}
	"${DIR_CONF}/install" || exit 1
	exit 0
elif [ "$1" = '--uninstall' ] || [ "$3" = '--uninstall' ]; then					# so a user can do 'pax -O xml --uninstall'
	if [ $# -gt 1 ]; then									# if we were passed more than just the '--version' option, it has to be '-O', so...
		if ( echo "$2" | grep -qE ^'(fifo|text|xml|xmLive)'$ ); then
			[ "$SILENT" ] || echo "ERROR: you must supply a proper value to the -O option." | tee -a "$LOG_ERRS"			# NOTE: we can't use showMsg() yet because we don't have it's value, so...
			exit 1
		fi
		OUTPUT=$2									# set that value to use from now on
	fi
	[ ! -e "${DIR_CONF}/uninstall" ] && {
		showMsg 'failure' "The uninstall script is missing to remove pax as the default package manager." 'screen'
		exit 1
	}
	"${DIR_CONF}/uninstall" || exit 1
	exit 0
elif [ "$1" = '--version' ] || [ "$3" = '--version' ]; then					# so a user can do 'pax -O xml --version'
	if [ $# -gt 1 ]; then									# if we were passed more than just the '--version' option, it has to be '-O', so...
		if ( echo "$2" | grep -qE ^'(fifo|text|xml|xmLive)'$ ); then
			[ "$SILENT" ] || echo "ERROR: you must supply a proper value to the -O option." | tee -a "$LOG_ERRS"			# NOTE: we can't use showMsg() yet because we don't have it's value, so...
			exit 1
		fi
		OUTPUT=$2									# set that value to use from now on
	fi
	TEMP=$(head -10 $0 | grep ^'# updated' | sed "s/.*\\t//;s/ .*//;s:/:.:g")
	showMsg 'success' "$TEMP" 'screen'
	exit 0
else
	# PROCESS PASSED PARAMETERS

	TEMP=0
	while getopts BcC:dD:eE:fFiI:K:lL:mM:N:oO:PQ:R:S:t:T:u:v:V:X:YzZ OPTION; do		# NOTE: the 'V:' indicates that the '-V' parameter requires a value!
		( echo $OPTION | grep -qe '[a-z]' ) && TEMP=1					# if we've reached an ACTION, then...
		if [ $TEMP -gt 0 ] && ( echo $OPTION | grep -qe '[A-Z]' ); then			# if an ACTION was already processed -AND- we've reached an OPTION, then...
			showMsg 'failure' "All OPTIONS must preceed the ACTION." 'screen'
			exit 1
		fi

		case ${OPTION} in
			B) BOOTING=TRUE ;;
			c) COPY=TRUE ;;
			C) ( echo "${OPTARG}" | grep -qE ^"($ARCH_VALUES)"$ ) || {
				showMsg 'failure' "You must provide a CPU architecture to the -C option." 'screen'
				exit 1
			   }
			   ARCH="$OPTARG" ;;
			d) [ "$REPO_SOURCE" = "$REPO_OPTION" ] && eval REPO_SOURCE="$REPO_SCHEMA"						# NOTE: we use the condition in case the -S might has been passed and processed already
			   DOWNLOAD=TRUE ;;
			D) ( echo "${OPTARG}" | grep -qE ^'(none|default|all|source)'$ ) || {
				showMsg 'failure' "You must provide a proper value to the -D option." 'screen'
				exit 1
			   }
			   DEPS="$OPTARG" ;;
			e) EXTRACT=TRUE ;;
			E) ( echo "${OPTARG}" | grep -qE ^'(all|info|list)'$ ) || {
				showMsg 'failure' "You must provide a proper value to the -E option." 'screen'
				exit 1
			   }
			   EXTRA="$OPTARG" ;;
			f) FIND=TRUE ;;
			F) FORCE=TRUE ;;
			i) eval LIST_BOOT="$LIST_BOOT"						# eval the variables to store processed values
			   INSTALL=TRUE ;;
			I) ( echo "${OPTARG:0:1}" | grep -q ^[0-9a-zA-Z] ) || {
				showMsg 'failure' "You must provide a comma separated list to the -I option." 'screen'
				exit 1
			   }
			   IGNORE="$OPTARG" ;;
			K) KERNEL="$OPTARG" ;;
			l) LIST=TRUE ;;
			L) ( echo "${OPTARG}" | grep -qE ^'(none|boot|live)'$ ) || {
				showMsg 'failure' "You must provide a proper value to the -L option." 'screen'
				exit 1
			   }
			   PACKLIST="${OPTARG}" ;;
			m) MAKE=TRUE ;;
			M) if [ "$OPTARG" != 'copy' ] && [ "$OPTARG" != 'link' ]; then
				showMsg 'failure' "You must provide a proper mode type to the -M option." 'screen'
				exit 1
			   fi
			   MODE="$OPTARG" ;;
			N) DEPS='none'								# '-D none' is implied with -N
			   FILELIST="$OPTARG" ;;
			o) OPEN=TRUE ;;
			O) ( echo "${OPTARG}" | grep -qE ^'(fifo|text|xml|xmLive)'$ ) || {
				showMsg 'failure' "You must provide a proper value to the -O option." 'screen'
				exit 1
			   }
			   [ "$OPTARG" = 'fifo' ] && [ ! -e "${DIR_TEMP}/output" ] && {
				showMsg 'failure' "The fifo does not exist, aborting execution." 'screen'
				exit 1
			   }
			   ( [ "$OPTARG" = 'xml' ] || [ "$OPTARG" = 'xmLive' ] ) && {
				echo -e 'Content-Type: text/xml; charset=utf-8'
				echo -e "<?xml version='1.0' encoding='UTF-8'?>\n\n"
			   }
			   [ "$OPTARG" = 'xmLive' ] && echo '<xml>'
			   OUTPUT="$OPTARG" ;;
			P) PROMPT=TRUE ;;
			Q) ( echo "${OPTARG}" | grep -qE ^'(all|errors|default|verbose|none)'$ ) || {
				showMsg 'failure' "You must provide a proper value to the -Q option." 'screen'
				exit 1
			   }
			   QUIET="$OPTARG" ;;
# DEV NOTE: -R acts in place of -S; '*' means show all
			R) ( echo "${OPTARG}" | grep -qe ^'\-.' ) && {				# checks if something like 'pax -R -l' was entered
				showMsg 'failure' "You must provide a proper value to the -R option." 'screen'
				exit 1
			   }
			   RESTORE="${OPTARG}" ;;
			S) ( echo "${OPTARG}" | grep -qE '(^(http|ftp|/|./)|(/)$)' ) || {
				showMsg 'failure' "You must provide a directory or http/ftp URI to the -S option." 'screen'
				exit 1
			   }
			   ( echo "$OPTARG" | grep -q '/'$ ) && OPTARG="${OPTARG%/*}"		# if the user included a trailing '/' on the passed directory, then remove it
			   ( echo "$OPTARG" | grep -q ^'./' ) && OPTARG="$(pwd)${OPTARG#*.}"	# if a relative directory was passed, adjust the value to be the whole path
			   ( echo "$OPTARG" | grep -q ^'/' ) || OPTARG="$(pwd)/${OPTARG}" 
			   REPO_SOURCE="$OPTARG" ;;						# " (this is to return correct coloring in gedit)
			t) ( echo "${OPTARG}" | grep -qE ^'(relies|reliant)' ) || {
				showMsg 'failure' "You must provide a proper value to the -t action." 'screen'
				exit 1
			   }
			   TREE="$OPTARG" ;;
			T) ( echo "${OPTARG}" | grep -qE ^'(bin|dev|doc|drv|gir|lib|loc)' ) || {
				showMsg 'failure' "You must provide a proper value to the -T option." 'screen'
				exit 1
			   }
			   TYPE="$OPTARG" ;;
			u) ( echo "${OPTARG}" | grep -qE ^'(update|unload|unlist|delete|purge)' ) || {
				showMsg 'failure' "You must provide a proper value to the -u action." 'screen'
				exit 1
			   }
			   UNLOAD="$OPTARG" ;;
			v) ( echo "${OPTARG}" | grep -qE ^'(data|deps|fix|hash)' ) || {
				showMsg 'failure' "You must provide a proper value to the -v action." 'screen'
				exit 1
			   }
			   VALIDATE="$OPTARG" ;;
			V) ( echo "${OPTARG:0:1}" | grep -q ^[0-9] ) || {
				showMsg 'failure' "You must provide a version number to the -V option." 'screen'
				exit 1
			   }
			   VERSION="$OPTARG" ;;
			X) ( echo "${OPTARG}" | grep -q ^'/' ) || {
				showMsg 'failure' "You must provide a device mount point to the -X option." 'screen'
				exit 1
			   }
			   PROXY="$OPTARG" ;;
			Y) DRYRUN=TRUE ;;
# DEV NOTE: -z must be called for any non-consecutive package manager call to make sure the files represent an up-to-date system (e.g. if pax is used to install something, then tce-load is, the catalog list with become out-of-sync and pax could malfunction)
#	if a package is in a non-standard directory (e.g. HOME, LIVE, ROOT), then cd into the directory containing those files to be picked up by this action (since we can't process DIRECTORY here)
			z) # we're booting the device -AND- there's a single package repo (e.g. TinyCore), then make a marker file indicating the package is part of the core OS
			   if [ "$BOOTING" ] && [ "$REPO_SYSTEM" = "$REPO_OPTION" ]; then
				for BASENAME in $(ls -1 "$DIR_LIST"); do
					touch "${DIR_LIST}/${BASENAME}.${EXT_CORE}" 2>>"$LOG_ERRS"
				done
				exit 0
			   fi

			   # remove anything existing that would force prompting for overwritting (e.g. alias cp='cp -i')
			   unalias cp >/dev/null 2>&1
			   unalias ln >/dev/null 2>&1

			   # remove any existing of these files (in case the original package manager was used between runs)
			   showMsg 'action' "Clearing any prior -z action contents:" 'screen' 0 3
# REMOVED 2026/01/12 - we use BASENAME not FILENAME
#			   [ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/"*.${EXT_SOFT}
			   [ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/"*.${EXT_HASH}
			   [ ! "$DRYRUN" ] && rm -f "${DIR_LIST}/"*.${EXT_DEPS}
			   showMsg 'action' " [done]" 'screen' 1 5

			   # (re-)sync the package contents
			   showMsg 'action' "Sync'ing necessary package files:" 'screen' 0 4
			   showMsg 'step' " [marked]" 'screen' 0 1
# UPDATED 2026/01/12
#			   for BASENAME in $(ls -1 "$DIR_LIST" | grep -vE ".(${EXT_SOFT}|${EXT_DEPS}|${EXT_HASH})"$); do
			   for BASENAME in $(ls -1 "$DIR_LIST" | grep -vE ".(${EXT_DEPS}|${EXT_HASH})"$); do
					[ ! "$DRYRUN" ] && [ ! -e "${DIR_LIST}/${BASENAME}" ] && { touch "${DIR_LIST}/${BASENAME}" 2>>"$LOG_ERRS" || exit 1; }
# REMOVED 2026/01/12 - we use BASENAME not FILENAME
#				[ ! "$DRYRUN" ] && { ln -sf "${REPO_OPTION}/${BASENAME}.${EXT_SOFT}" "${DIR_LIST}/${BASENAME}.${EXT_SOFT}" 2>>"$LOG_ERRS" || exit 1; }
				[ ! "$DRYRUN" ] && [ -e "${REPO_OPTION}/${BASENAME}.${EXT_HASH}" ] && { ln -sf "${REPO_OPTION}/${BASENAME}.${EXT_HASH}" "${DIR_LIST}/${BASENAME}.${EXT_HASH}" 2>>"$LOG_ERRS" || exit 1; }
				[ ! "$DRYRUN" ] && [ -e "${REPO_OPTION}/${BASENAME}.${EXT_DEPS}" ] && { ln -sf "${REPO_OPTION}/${BASENAME}.${EXT_DEPS}" "${DIR_LIST}/${BASENAME}.${EXT_DEPS}" 2>>"$LOG_ERRS" || exit 1; }
				[ ! "$DRYRUN" ] && [ -e "${REPO_OPTION}/${BASENAME}.${EXT_INFO}" ] && { ln -sf "${REPO_OPTION}/${BASENAME}.${EXT_INFO}" "${DIR_LIST}/${BASENAME}.${EXT_INFO}" 2>>"$LOG_ERRS" || exit 1; }
			   done
			   showMsg 'step' " [unmarked]" 'screen' 0 1
			   for BASENAME in $(ls -1 "${REPO_OPTION}/"*.${EXT_SOFT} | sed "s|${REPO_OPTION}/||;s|\.${EXT_SOFT}$||"); do
				[ -e "${DIR_LIST}/${BASENAME}" ] && continue									# skip any package that have been already processed in the above 'for' loop

				if ( /bin/mount 2>>"$LOG_ERRS" | grep -q "${DIR_LOOP}/${BASENAME} type squashfs" ); then			# if the package IS already mounted (because it's installed via symlink), then...
					TEMP='TRUE'
				elif ( ! /bin/mount 2>>"$LOG_ERRS" | grep -q "${DIR_LOOP}/${BASENAME} type squashfs" ); then			# if the package is NOT already mounted and symlinked, then...
					MODE='copy'												# so the exitGracefully() call will umount
					[ ! -d "${DIR_LOOP}/${BASENAME}" ] && /bin/mkdir -p "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1	# make the mounting directory if it doesn't exist

					sudo /bin/mount -t squashfs -o loop,ro "${REPO_OPTION}/${BASENAME}.${EXT_SOFT}" "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || exitGracefully 3 'screen' 6 'failure'

					TEMP='FALSE'
					for ITEM in $(find "${DIR_LOOP}/${BASENAME}"); do
#echo "item |$ITEM|"
						TARGET_ROOT="$(echo "$ITEM" | sed "s|^${DIR_LOOP}/${BASENAME}||")"				# (re)set the value; remove the loopback mount point prefix to store only the target '/directory/filename' string "
#echo "root |$TARGET_ROOT|"
						( echo "$DIR_LIVE" | grep -q '\.'$ ) && TARGET_LIVE="${DIR_LIVE}$(echo "${TARGET_ROOT}" | tail -c +2)" || TARGET_LIVE="${DIR_LIVE}${TARGET_ROOT}"
#echo "live |$DIR_LIVE|"
						TARGET_HOME="${HOME}${TARGET_ROOT}"
#echo "home |$TARGET_HOME|"
						TARGET_MISC=".${TARGET_ROOT}"									# set an initial value
#echo "misc |$TARGET_MISC|"

						# determine where the file is located (in case the package was installed one place [e.g. HOME] and a dependency in another [e.g. ROOT])
						# NOTE: this search pattern comes in order of presidence: passed DIRECTORY, HOME, DIR_LIVE, ROOT
						#	the 'misc' comes first since the package could also be in any of the following directories too, storing an incorrect TARGET path if they were triggered first
						# find the first file in the package to check if it's installed in the filesystem (that's why both tests are performed below)
#echo "checking |$TARGET|$TARGET_HOME|$TARGET_LIVE|$TARGET_ROOT|"
						[ ! -d "$ITEM" ] && [ ! -e "$TARGET_MISC" ] && [ ! -e "$TARGET_HOME" ] && [ ! -e "$TARGET_LIVE" ] && [ ! -e "$TARGET_ROOT" ] && break
						[ ! -d "$ITEM" ] && ( [ -e "$TARGET_MISC" ] || [ -e "$TARGET_HOME" ] || [ -e "$TARGET_LIVE" ] || [ -e "$TARGET_ROOT" ] ) && {
#echo installed
							TEMP='TRUE'
							break
						}
					done

					sudo /bin/umount -d "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || exitGracefully 3 'screen' 6 'failure'
				fi	
				if [ "$TEMP" = 'TRUE' ]; then
					[ ! "$DRYRUN" ] && [ ! -e "${DIR_LIST}/${BASENAME}" ] && { touch "${DIR_LIST}/${BASENAME}" 2>>"$LOG_ERRS" || exit 1; }
# REMOVED 2026/01/12 - we use BASENAME not FILENAME
#					[ ! "$DRYRUN" ] && { ln -sf "${REPO_OPTION}/${BASENAME}.${EXT_SOFT}" "${DIR_LIST}/${BASENAME}.${EXT_SOFT}" 2>>"$LOG_ERRS" || exit 1; }
					[ ! "$DRYRUN" ] && [ -e "${REPO_OPTION}/${BASENAME}.${EXT_HASH}" ] && { ln -sf "${REPO_OPTION}/${BASENAME}.${EXT_HASH}" "${DIR_LIST}/${BASENAME}.${EXT_HASH}" 2>>"$LOG_ERRS" || exit 1; }
					[ ! "$DRYRUN" ] && [ -e "${REPO_OPTION}/${BASENAME}.${EXT_DEPS}" ] && { ln -sf "${REPO_OPTION}/${BASENAME}.${EXT_DEPS}" "${DIR_LIST}/${BASENAME}.${EXT_DEPS}" 2>>"$LOG_ERRS" || exit 1; }
					[ ! "$DRYRUN" ] && [ -e "${REPO_OPTION}/${BASENAME}.${EXT_INFO}" ] && { ln -sf "${REPO_OPTION}/${BASENAME}.${EXT_INFO}" "${DIR_LIST}/${BASENAME}.${EXT_INFO}" 2>>"$LOG_ERRS" || exit 1; }
				fi
			   done
			   showMsg 'action' " [done]" 'screen' 1 5
			   exit 0 ;;
			Z) COLORS=TRUE ;;
			*) exit 1 ;;								# NOTE: since 'getopts' presents it own error, we don't need to do so here
		esac
	done


# DEV NOTE: indicate that this can be set via config file (COLORS=TRUE) to always show
	# PROCESS COLORS
	if [ "$COLORS" ] && [ "$OUTPUT" = 'text' ]; then
		NORMAL="\e[0m"
		BLINK="\e[5m"
		INVERSE="\e[7m"
		HIDE="\e[8m"
		UL="\e[4m"

		BLACK="\e[0;30m"
		GARNET="\e[0;31m"
		GREEN="\e[0;32m"
		BROWN="\e[0;33m"
		NAVY="\e[0;34m"
		MAGENTA="\e[1;35m"
		TEAL="\e[0;36m"
		DARKGREY="\e[1;30m"
		GREY="\e[0;37m"
		RED="\e[1;31m"
		LIME="\e[1;32m"
		YELLOW="\e[1;33m"
		BLUE="\e[1;34m"
		PURPLE="\e[0;35m"
		CYAN="\e[1;36m"
		WHITE="\e[1;37m"
	fi


	# PROCESS THE 'DIRECTORY' PARAMETER
	EXE_CMD="${0##*/} $@"									# store the executed command for logging below
	shift $(expr $OPTIND - 1)								# now that the ACTIONS and OPTIONS have been processed, lets process the package name(s)
	eval TEMP=\${$#}									# store the current last passed value to later check if a directory was passed as the last value	http://stackoverflow.com/questions/1853946/getting-the-last-argument-passed-to-a-shell-script

	# WARNING: this MUST come before the directory processing!!!
	if [ "$TEMP" = "$0" ] && ( [ "$INSTALL" ] && [ ! "$RESTORE" ] ) && [ ! "$LIST" ] && [ ! "$OPEN" ] && [ ! "$TREE" ]; then		# if no PACKAGE(S), FILELIST, or DIRECTORY was passed, then...
		showMsg 'failure' "The script must have a PACKAGE(S), FILELIST, and/or DIRECTORY value." 'screen'
		exit 1
	elif [ "$TEMP" != "$0" ] && ( echo "$TEMP" | grep -q '/' ) && [ ! -f "$TEMP" ]; then	# if a DIRECTORY was passed, then...		  NOTE: the last check makes sure a path for a filelist wasn't passed (which would also trigger the 2nd check); the first check is specifically for OPEN and LIST (since they don't require a PACKAGE(S) or DIRECTORY value), and should NOT effect the other actions
		if [ ! -d "$TEMP" ]; then							#   if it does NOT exist, then...
			showMsg 'failure' "The passed directory does not exist (${TEMP})." 'screen'
			exit 1
		fi

		DIRECTORY="$TEMP"								#   store the DIRECTORY value

		TEMP=''
		for PARAMETER in ${@}; do							#   process each remaining parameter (after the OPTIONS and ACTION have been removed)
			[ "$PARAMETER" = "$DIRECTORY" ] && break				#   if we have reached the DIRECTORY value, break out of the 'for' loop to NOT include it
			TEMP="$TEMP $PARAMETER"							#   append each parameter to the list
		done
		set -- $TEMP									#   now reset the $@ array (e.g. $1, $2, $3, etc) with the adjusted parameters list

		( echo "$DIRECTORY" | grep -q '/'$ ) && [ "$DIRECTORY" != '/' ] && DIRECTORY="${DIRECTORY%/*}"					#   if the user included a trailing '/' on the passed directory -AND- it wasn't root, then remove it
		( echo "$DIRECTORY" | grep -q ^'./' ) && DIRECTORY="$(pwd)${DIRECTORY#*.}"	# if a relative directory was passed, adjust the value to be the whole path
		( echo "$DIRECTORY" | grep -q ^'/' ) || DIRECTORY="$(pwd)/${DIRECTORY}" 
	fi

	# WARNING: this MUST be two different 'if' statements so both can execute!!!

	if [ -f "$1" ] && ( ! grep -q '\0' "$1" ); then						# if the parameter is a file -AND- not a binary file, then it's a FILELIST, so...	NOTE: can't check for mime type since busybox doesn't have a 'file' applet	https://stackoverflow.com/questions/567757/how-do-i-distinguish-between-binary-and-text-files
		TEMP="$(cat "$1" | tr '\n' ' ')"						#   store all the packages to load within the FILELIST
		[ ! "$TEMP" ] && exit 0								#   if there are NOT any packages in the directory, there's nothing to process so exit
		set -- $TEMP									#   now reset the $@ array (e.g. $1, $2, $3, etc) with the files in the FILELIST
	# if a -S (or -R) was passed with no PACKAGE(S) -AND- we're not opening a fifo -AND- (a -c, -e, or -t was passed -OR- a -S was passed and it's local -OR- a -R was passed but not -l or -u -OR- -i and -X was passed), then we need to process all packages in REPO_SOURCE|REPO_RESTOR
	# NOTE: we can't [ -d ] since the REPO_SOURCE can be remote				  if no packages were passed...
	elif [ ! "$1" ] && [ ! "$OPEN" ] && ( [ "$COPY" ] || [ "$EXTRACT" ] || [ "$INSTALL" ] || [ "$TREE" ] || ( [ "$REPO_SOURCE" ] && ( ! echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) ) || ( [ "$RESTORE" ] && [ ! "$LIST" ] && [ ! "$UNLOAD" ] ) || ( [ "$INSTALL" ] && [ "$PROXY" ] ) ); then
		[ "$TREE" ] && [ ! "$REPO_SOURCE" ] && cd "$REPO_OPTION"			# NOTE: this MUST be handled in this manner so that the -S and DIRECTORY checking doesn't get triggered
		[ "$REPO_SOURCE" ] && ( ! echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) && cd "${REPO_SOURCE}"
		[ "$RESTORE" ] && [ -e "${REPO_RESTOR}/${RESTORE}" ] && cd "${REPO_RESTOR}/${RESTORE}"						# NOTE: we include the '-e' check since none of the parameter checks below have taken place, to prevent an error from occurring here
		[ "$PROXY" ] && [ -e "${PROXY}/pax/optional.proxy" ] && cd "${PROXY}/pax/optional.proxy"

		TEMP="$(ls -1 *.${EXT_SOFT} 2>/dev/null | tr '\n' ' ')"				#   store all the .soft packages to load within the directory
		[ "$TEMP" ] && set -- $TEMP							#   otherwise reset the $1, $2, $3, etc values (and $@ that is used in the main 'for' loop below) to be the package names in the directory (as if they were passed via the command line)
		cd - >/dev/null									#   now return to the prior directory (so that the proper directory can be entered in code below)
	fi
	TEMP=''											# make sure this value is not contaminating anything
fi




# MANDATORY CHECKS BEFORE **ANY** PROCESSING

# general checking			NOTE: we can't write to a log yet since those checks haven't occurred
# UPDATED 2026/01/15
#( ls -1 "${DIR_LIST}" | grep -q "${EXT_HASH}"$ ) || { showMsg 'failure' "pax does not appear to be the default package manager.\nNOTES: Run 'pax --install' to make it the default package manager, or\n       run 'pax -z' to populate the system.\n       'pax -z' will be required after each non-consecutive action by a\n       package manager. Making pax the default will remove this step." 'screen'; exit 1; }
# TESTED 2026/01/15
#[ ! "$BOOTING" ] && ( ! ls -1 "${DIR_LIST}" | grep -q "${EXT_HASH}"$ ) && { showMsg 'failure' "pax does not appear to be the default package manager.\nNOTES: Run 'pax --install' to make it the default package manager, or\n       run 'pax -z' to populate the system.\n       'pax -z' will be required after each non-consecutive action by a\n       package manager. Making pax the default will remove this step." 'screen'; exit 1; }
( ! ls -1 "${DIR_LIST}" | grep -q "${EXT_CORE}"$ ) && ( ! ls -1 "${DIR_LIST}" | grep -q "${EXT_HASH}"$ ) && { showMsg 'failure' "pax does not appear to be the default package manager.\nNOTES: Run 'pax --install' to make it the default package manager, or\n       run 'pax -z' to populate the system.\n       'pax -z' will be required after each non-consecutive action by a\n       package manager. Making pax the default will remove this step." 'screen'; exit 1; }
[ "$VERSION" ] && [ "$2" ] && { showMsg 'failure' "Only one package can be listed with the -V option." 'screen'; exit 1; }
[ "$RESTORE" ] && ( echo "$RESTORE" | grep -qE '[0-9]/[0-9]{2}/[0-9]' ) && { showMsg 'failure' "The restore point date must be in a YYYY-MM-DD format." 'screen'; exit 1; }

# action checking
TEMP=0
[ "$COPY" ] && TEMP=$(( TEMP + 1 ))
[ "$DOWNLOAD" ] && TEMP=$(( TEMP + 1 ))
[ "$EXTRACT" ] && TEMP=$(( TEMP + 1 ))
[ "$FIND" ] && TEMP=$(( TEMP + 1 ))
[ "$INSTALL" ] && TEMP=$(( TEMP + 1 ))
[ "$LIST" ] && TEMP=$(( TEMP + 1 ))
[ "$MAKE" ] && TEMP=$(( TEMP + 1 ))
[ "$OPEN" ] && TEMP=$(( TEMP + 1 ))
[ "$TREE" ] && TEMP=$(( TEMP + 1 ))
[ "$UNLOAD" ] && TEMP=$(( TEMP + 1 ))
[ "$VALIDATE" ] && TEMP=$(( TEMP + 1 ))
[ $TEMP -gt 1 ] && { showMsg 'failure' "Include only one ACTION when executing this script." 'screen'; exit 1; }
[ ! "$COPY" ] && [ ! "$DOWNLOAD" ] && [ ! "$EXTRACT" ] && [ ! "$FIND" ] && [ ! "$INSTALL" ] && [ ! "$LIST" ] && [ ! "$MAKE" ] && [ ! "$OPEN" ] && [ ! "$TREE" ] && [ ! "$UNLOAD" ] && [ ! "$VALIDATE" ] && { showMsg 'failure' "You must provide an ACTION when executing this script." 'screen'; exit 1; }
[ "$DOWNLOAD" ] && [ ! "$1" ] && { showMsg 'failure' "You must provide at least one package before processing can begin." 'screen'; exit 1; }
[ "$DOWNLOAD" ] && [ "$REPO_SOURCE" ] && ( ! echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) && { showMsg 'failure' "You must provide a remote source with the -d action." 'screen'; exit 1; }
[ "$FIND" ] && [ "$REPO_SOURCE" ] && [ "$DIRECTORY" ] && { showMsg 'failure' "You must provide only the -S or DIRECTORY value with the -f action." 'screen'; exit 1; }
[ "$INSTALL" ] && [ "$RESTORE" ] && ( ! echo "$RESTORE" | grep -q '/' ) && { showMsg 'failure' "You must provide a 'DATE/Restore Point' value with the -R option." 'screen'; exit 1; }
[ "$INSTALL" ] && [ "$RESTORE" ] && ( ! echo "$RESTORE" | grep -qE ^'[0-9]{4}-[0-9]{2}-[0-9]{2}' ) && { showMsg 'failure' "The restore point value must be in a 'DATE/Restore Point' format." 'screen'; exit 1; }
[ "$LIST" ] && [ "$DIRECTORY" ] && { showMsg 'failure' "This action can't be used with the DIRECTORY value." 'screen'; exit 1; }
[ "$LIST" ] && [ "$RESTORE" ] && [ "$REPO_SOURCE" ] && { showMsg 'failure' "The -S option can't be used with the -R option." 'screen'; exit 1; }
[ "$LIST" ] && [ "$RESTORE" ] && [ "$1" ] && { showMsg 'failure' "You can not pass a PACKAGE(S) or DIRECTORY value when using -l and -R." 'screen'; exit 1; }
[ "$LIST" ] && [ "$RESTORE" ] && [ "$RESTORE" != '*' ] && ( ! echo "$RESTORE" | grep -qE ^'[0-9]{4}-[0-9]{2}-[0-9]{2}' ) && { showMsg 'failure' "The restore point value must be in a 'DATE[/Restore Point]' format." 'screen'; exit 1; }
[ "$MAKE" ] && [ "$DIRECTORY" ] && [ "$REPO_SOURCE" ] && { showMsg 'failure' "You must provide only the -S or DIRECTORY value with the -m action." 'screen'; exit 1; }
[ "$MAKE" ] && [ ! "$DIRECTORY" ] && [ ! "$REPO_SOURCE" ] && { showMsg 'failure' "You must provide either the -S or DIRECTORY value with the -m action." 'screen'; exit 1; }
[ "$MAKE" ] && ( [ ! "$1" ] || ( echo "$1" | grep -q '/' ) ) && { showMsg 'failure' "You must provide a package name before processing can begin." 'screen'; exit 1; }
[ "$MAKE" ] && [ "$2" ] && { showMsg 'failure' "Only one package can be processed per call of the -m action." 'screen'; exit 1; }
[ "$OPEN" ] && [ "$DIRECTORY" ] && [ "$REPO_SOURCE" ] && { showMsg 'failure' "You must provide only the -S or DIRECTORY value with the -o action." 'screen'; exit 1; }
[ "$OPEN" ] && [ "$2" ] && [ "$2" != 'clear' ] && { showMsg 'failure' "Only one fifo can be managed per call of the -o action." 'screen'; exit 1; }
[ "$TREE" ] && [ "$DIRECTORY" ] && [ "$REPO_SOURCE" ] && { showMsg 'failure' "You must provide only the -S or DIRECTORY value with the -t action." 'screen'; exit 1; }
[ "$UNLOAD" ] && [ "$RESTORE" ] && [ "$RESTORE" != 'none' ] && ( ! echo "$RESTORE" | grep -qE ^'[0-9]{4}-[0-9]{2}-[0-9]{2}' ) && { showMsg 'failure' "The restore point value must be in a 'DATE[/Restore Point]' format." 'screen'; exit 1; }
[ "$UNLOAD" ] && [ "$RESTORE" ] && [ "$RESTORE" != 'none' ] && [ "$REPO_SOURCE" ] && { showMsg 'failure' "The -S option can only be used with the '-R none' option." 'screen'; exit 1; }

# option checking
[ "$BOOTING" ] && [ ! "$INSTALL" ] && { showMsg 'failure' "This action can't be used with the -B option." 'screen'; exit 1; }
[ "$ARCH" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$OPEN" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -C option." 'screen'; exit 1; }
[ "$DEPS" ] && [ ! "$FILELIST" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] ) && { showMsg 'failure' "This action can't be used with the -D option." 'screen'; exit 1; }	# NOTE: the FILELIST test had to be include to prevent the wrong '-N -l' error from showing
[ "$DEPS" = 'none' ] && [ ! "$FILELIST" ] && [ "$TREE" ] && { showMsg 'failure' "This action can't be used with the '-D none' option." 'screen'; exit 1; }					# NOTE: ditto
[ "$EXTRA" ] && [ ! "$COPY" ] && [ ! "$DOWNLOAD" ] && [ ! "$INSTALL" ] && [ ! "$UNLOAD" ] && { showMsg 'failure' "This action can't be used with the -E option." 'screen'; exit 1; }
[ "$FORCE" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -F option." 'screen'; exit 1; }
[ "$IGNORE" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -I option." 'screen'; exit 1; }
[ "$KERNEL" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -K option." 'screen'; exit 1; }
[ "$PACKLIST" ] && [ ! "$INSTALL" ] && [ "$UNLOAD" != 'delete' ] && [ "$UNLOAD" != 'purge' ] && { showMsg 'failure' "This action can't be used with the -L option." 'screen'; exit 1; }
[ "$MODE" ] && [ ! "$INSTALL" ] && { showMsg 'failure' "This action can't be used with the -M option." 'screen'; exit 1; }
[ "$FILELIST" ] && [ ! "$INSTALL" ] && { showMsg 'failure' "This action can't be used with the -N option." 'screen'; exit 1; }
[ "$OUTPUT" = 'xml' ] && [ "$OPEN" ] && { showMsg 'failure' "This action can't be used with the '-O xml' option." 'screen'; exit 1; }		# NOTE: we can't use this since it requires a final success/failure before any output is shown
[ "$PROMPT" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -P option." 'screen'; exit 1; }
[ "$QUIET" = 'all' ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$TREE" ] ) && { echo "ERROR: This action can't be used with the '-Q all' option."; exit 1; }  # NOTE: this has to be an 'echo' statement because showMsg() won't show it otherwise!
[ "$QUIET" = 'errors' ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the '-Q errors' option." 'screen'; exit 1; }
[ "$RESTORE" ] && [ ! "$INSTALL" ] && [ ! "$LIST" ] && [ ! "$UNLOAD" ] && { showMsg 'failure' "This action can't be used with the -R option." 'screen'; exit 1; }
[ "$REPO_SOURCE" ] && [ "$LIST" ] && { showMsg 'failure' "This action can't be used with the -S option." 'screen'; exit 1; }
[ "$TYPE" != 'bin' ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] ) && { showMsg 'failure' "This action can't be used with the -T option." 'screen'; exit 1; }
[ "$VERSION" ] && [ ! "$DOWNLOAD" ] && [ ! "$INSTALL" ] && [ ! "$UNLOAD" ] && [ ! "$VALIDATE" ] && { showMsg 'failure' "This action can't be used with the -V option." 'screen'; exit 1; }
[ "$PROXY" ] && [ ! "$COPY" ] && [ ! "$DOWNLOAD" ] && [ ! "$INSTALL" ] && { showMsg 'failure' "This action can't be used with the -X option." 'screen'; exit 1; }
[ "$DRYRUN" ] && ( [ "$FIND" ] || [ "$LIST" ] || [ "$MAKE" ] || [ "$OPEN" ] || [ "$TREE" ] ) && { showMsg 'failure' "This action can't be used with the -Y option." 'screen'; exit 1; }

# option combination checking
[ "$ARCH" ] && [ "$RESTORE" ] && { showMsg 'failure' "The -C option can't be used with the -R option." 'screen'; exit 1; }
[ "$IGNORE" ] && [ "$FILELIST" ] && { showMsg 'failure' "The -I option can't be used with the -N option." 'screen'; exit 1; }
[ "$PROMPT" ] && [ "$QUIET" = 'all' ] && { echo "ERROR: The -P option can't be used with the '-Q all' option."; exit 1; }			# NOTE: this has to be an 'echo' statement because showMsg() won't show it otherwise!
[ "$PROMPT" ] && [ "$QUIET" = 'errors' ] && { showMsg 'failure' "The -P option can't be used with the '-Q errors' option." 'screen'; exit 1; }
[ "$PROMPT" ] && [ "$OUTPUT" = 'fifo' ] && [ ! -e "$FIFO_SERVER" ] && { showMsg 'failure' "The -P option can't be used with '-O fifo' without a FIFO_SERVER." 'screen'; exit 1; }
[ "$PROMPT" ] && [ "$OUTPUT" != 'fifo' ] && [ "$OUTPUT" != 'text' ] && [ ! -e "$FIFO_SERVER" ] && { showMsg 'failure' "The -P option can only be used with '-O fifo' or '-O text'." 'screen'; exit 1; }
[ "$PROXY" ] && [ "$DRYRUN" ] && [ ! "$INSTALL" ] && { showMsg 'failure' "The -X option can't be used with the -Y option." 'screen'; exit 1; }
[ "$PROXY" ] && [ "$DIRECTORY" != '' ] && [ ! "$INSTALL" ] && { showMsg 'failure' "The DIRECTORY value can not be used with the -X option." 'screen'; exit 1; }
[ "$NORMAL" ] && [ "$OUTPUT" != 'text' ] && { showMsg 'failure' "The -Z option can only be used with the '-O text' option." 'screen'; exit 1; }

# set default/uninitialized variable values							  NOTE: we have to set these here since they rely on functions above
eval LIST_BOOT="$LIST_BOOT"
eval FLAG_BOOT="$FLAG_BOOT"
eval LIST_LIVE="$LIST_LIVE"
eval FLAG_LIVE="$FLAG_LIVE"
[ ! "$ARCH" ] && eval ARCH="$ARCH_SCHEMA"
[ ! "$DEPS" ] && [ ! "$UNLOAD" ] && DEPS='default'
[ ! "$DEPS" ] && [ "$UNLOAD" ] && DEPS='all'							# this becomes the default if unloading (to keep a tidy system) and -D is not passed
[ ! "$KERNEL" ] && eval KERNEL="$KRNL_SCHEMA"
[ ! "$PACKLIST" ] && PACKLIST='live'


# check the directories		NOTE: we can't write to a log yet since those checks are occurring
if [ ! -d "${DIR_LIST}" ]; then
	mkdir -p "${DIR_LIST}" >/dev/null 2>&1 || { showMsg 'failure' "The catalog directory (DIR_LIST) does not exist and could not be created." 'screen'; exit 1; }
fi
touch "${DIR_LIST}/writable" >/dev/null 2>&1 || { showMsg 'failure' "The catalog directory (DIR_LIST) is not writable." 'screen'; exit 1; }
rm "${DIR_LIST}/writable" >/dev/null 2>&1

if [ "$INSTALL" ] && ( [ ! "$DIRECTORY" ] || [ "$DIRECTORY" = '/' ] ); then			# if we're installing -AND- the files need to be copied to the root (e.g. system package update)
	# NOTE: if we aren't installing to the root (e.g. DIRECTORY=/), then it will be another place (e.g. /Users/Public, HOME, /tmp[/staging], etc) which will be presumed to be writable

	if [ ! -d "${DIR_INIT}" ]; then
		mkdir -p "${DIR_INIT}" >/dev/null 2>&1 || { showMsg 'failure' "The service script directory (DIR_INIT) does not exist and could not be created." 'screen'; exit 1; }
	fi
	touch "${DIR_INIT}/writable" >/dev/null 2>&1 || { showMsg 'failure' "The service script directory (DIR_INIT) is not writable.\n       You may need to execute the command using 'sudo'." 'screen'; exit 1; }
	rm "${DIR_INIT}/writable" >/dev/null 2>&1

	if [ ! -d "${DIR_INST}" ]; then
		mkdir -p "${DIR_INST}" >/dev/null 2>&1 || { showMsg 'failure' "The package script directory (DIR_INST) does not exist and could not be created." 'screen'; exit 1; }
	fi
	touch "${DIR_INST}/writable" >/dev/null 2>&1 || { showMsg 'failure' "The package script directory (DIR_INST) is not writable." 'screen'; exit 1; }
	rm "${DIR_INST}/writable" >/dev/null 2>&1
fi

if [ ! -d "${DIR_LIST}" ]; then
	mkdir -p "${DIR_LIST}" >/dev/null 2>&1 || { showMsg 'failure' "The installed package cache directory (DIR_LIST) does not exist and could not be created." 'screen'; exit 1; }
fi
touch "${DIR_LIST}/writable" >/dev/null 2>&1 || { showMsg 'failure' "The installed package cache directory (DIR_LIST) is not writable." 'screen'; exit 1; }
rm "${DIR_LIST}/writable" >/dev/null 2>&1

if [ ! -d "${DIR_LOGS}" ]; then
	mkdir -p "${DIR_LOGS}" >/dev/null 2>&1 || { showMsg 'failure' "The logs directory (DIR_LOGS) does not exist and could not be created." 'screen'; exit 1; }
fi
touch "${DIR_LOGS}/writable" >/dev/null 2>&1 || { showMsg 'failure' "The logs directory (DIR_LOGS) is not writable." 'screen'; exit 1; }
rm "${DIR_LOGS}/writable" >/dev/null 2>&1

if [ ! -d "${DIR_LOOP}" ]; then
	mkdir -p "${DIR_LOOP}" >/dev/null 2>&1 || { showMsg 'failure' "The mounting directory (DIR_LOOP) does not exist and could not be created." 'screen'; exit 1; }
fi
touch "${DIR_LOOP}/writable" >/dev/null 2>&1 || { showMsg 'failure' "The mounting directory (DIR_LOOP) is not writable." 'screen'; exit 1; }
rm "${DIR_LOOP}/writable" >/dev/null 2>&1

if [ ! -d "${DIR_TEMP}" ]; then
	mkdir -p "${DIR_TEMP}" >/dev/null 2>&1 || { showMsg 'failure' "The temp directory (DIR_TEMP) does not exist and could not be created." 'screen'; exit 1; }
fi
touch "${DIR_TEMP}/writable" >/dev/null 2>&1 || { showMsg 'failure' "The temp directory (DIR_TEMP) is not writable." 'screen'; exit 1; }
rm "${DIR_TEMP}/writable" >/dev/null 2>&1

if [ ! -d "$REPO_PREFIX" ]; then
	mkdir -p "$REPO_PREFIX" >/dev/null 2>&1 || { showMsg 'failure' "The package storage directory (REPO_PREFIX) could not be created." 'screen'; exit 1; }
fi
touch "${REPO_PREFIX}/writable" >/dev/null 2>&1 || { showMsg 'failure' "The package storage directory (REPO_PREFIX) is not writable." 'screen'; exit 1; }
rm "${REPO_PREFIX}/writable" >/dev/null 2>&1

if ( [ "$DOWNLOAD" ] || [ "$INSTALL" ] ) && [ ! -d "$REPO_OPTION" ]; then
	mkdir -p "$REPO_OPTION" >/dev/null 2>&1 || { showMsg 'failure' "The optional package storage directory (REPO_OPTION) could not be created." 'screen'; exit 1; }
fi
touch "${REPO_OPTION}/writable" >/dev/null 2>&1 || { showMsg 'failure' "The optional package storage directory (REPO_OPTION) is not writable." 'screen'; exit 1; }
rm "${REPO_OPTION}/writable" >/dev/null 2>&1

# if we're download -or- installing -AND- the passed directory was '/' -or- we need to use the default DIR_LIVE value and it's '/' -AND- the REPO_SYSTEM doesn't exist, then...
if ( [ "$DOWNLOAD" ] || [ "$INSTALL" ] ) && ( [ "$DIRECTORY" = '/' ] || ( [ ! "$DIRECTORY" ] && [ "$DIR_LIVE" = '/' ] ) ) && [ ! -d "$REPO_SYSTEM" ]; then
	mkdir -p "$REPO_SYSTEM" >/dev/null 2>&1 || { showMsg 'failure' "The system package storage directory (REPO_SYSTEM) could not be created." 'screen'; exit 1; }
fi
if ( [ "$DOWNLOAD" ] || [ "$INSTALL" ] ) && ( [ "$DIRECTORY" = '/' ] || ( [ ! "$DIRECTORY" ] && [ "$DIR_LIVE" = '/' ] ) ); then
	touch "${REPO_SYSTEM}/writable" >/dev/null 2>&1 || { showMsg 'failure' "The system package storage directory (REPO_SYSTEM) is not writable." 'screen'; exit 1; }
	rm "${REPO_SYSTEM}/writable" >/dev/null 2>&1

	[ "$(stat -c %a "$REPO_SYSTEM" 2>/dev/null)" != "$PRM_SYSTEM" ] && { showMsg 'failure' "The system package storage directory (REPO_SYSTEM) has invalid permissions." 'screen'; exit 1; }
	[ "$(stat -c %U "$REPO_SYSTEM" 2>/dev/null)" != "${OWN_SYSTEM%:*}" ] && { showMsg 'failure' "The system package storage directory (REPO_SYSTEM) has invalid owner ownership." 'screen'; exit 1; }
	[ "$(stat -c %G "$REPO_SYSTEM" 2>/dev/null)" != "${OWN_SYSTEM#*:}" ] && { showMsg 'failure' "The system package storage directory (REPO_SYSTEM) has invalid group ownership." 'screen'; exit 1; }
fi

if [ "$PROXY" ]; then
	[ ! -d "$PROXY" ] && { showMsg 'failure' "The proxy media mount point does not exist." 'screen'; exit 1; }

	touch "${PROXY}/writable" >/dev/null 2>&1 || { showMsg 'failure' "The proxy media mount point is not writable." 'screen'; exit 1; }
	rm "${PROXY}/writable" >/dev/null 2>&1

	# check that a '-X -d' or '-X -c' was performed first
	[ "$INSTALL" ] && [ ! -e "${PROXY}/pax/optional.proxy" ] && { showMsg 'failure' "There are no packages to install on the proxy media." 'screen'; exit 1; }
fi




showMsg 'start' "\n\n---------- [ Script Execution ] ----------" 'log'
showMsg 'start' "           $(date +'%Y-%m-%d  %H:%M:%S')\n" 'log'
showMsg 'start' "$EXE_CMD" 'log'




# SET DIRECTORY VALUES

[ "$DIRECTORY" = '' ] && DIRECTORY="$REPO_OPTION"						# set default values if none were specified in the passed parameters
[ "$REPO_SOURCE" = '' ] && REPO_SOURCE="$REPO_SCHEMA"

if [ "$COPY" ]; then										# if we are copying package(s), then...
	[ "$DIRECTORY" = "$REPO_OPTION" ] && DIRECTORY='./'					#   if no directory was passed, then set the current directory as the target location to extract
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since we can only copy from local packages
	cd "$DIRECTORY" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'				#   now cd into the DIRECTORY where the packages are to be copied
elif [ "$DOWNLOAD" ]; then									# if we are downloading package(s), then...
	# NOTE: REPO_SOURCE can NOT be processed here because it has variables that need to be parsed each time it's called
	cd "$DIRECTORY" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'				#   now cd into the DIRECTORY where the packages will be downloaded
elif [ "$EXTRACT" ]; then									# if we are extracting package(s) contents, then...
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the current directory (this allows for directories to be processed as package list)
	[ "$DIRECTORY" = "$REPO_OPTION" ] && DIRECTORY="$(pwd)"					#   if no directory was passed, then set the current directory as the target location to extract
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the DIRECTORY where the packages are
elif [ "$FIND" ]; then										# if we are finding file(s) in packages, then...
	[ "$DIRECTORY" != "$REPO_OPTION" ] && REPO_SOURCE="$DIRECTORY"				#   if a directory was passed, then set the REPO_SOURCE as that value (so it can be used with '-S' interchangably)
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since we can only search local packages
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the REPO_SOURCE where the packages are
elif [ "$INSTALL" ] || [ "$VALIDATE" ]; then							# if we are installing -OR- validating package(s), then...
	if [ "$BOOTING" ]; then									#   if we're booting the device, then...
		DIRECTORY='/'									#     set DIRECTORY to the filesystem root
		REPO_SOURCE="$REPO_SYSTEM"							#     set REPO_SOURCE to the 'FIRMWARE' packages location
	else											#   otherwise the system is live and can use parameters, so...
		# NOTE: we can't change REPO_SOURCE since install may need to download packages; moved below
		[ "$RESTORE" ] && {								# NOTE: the REPO_RESTOR and REPO_SOURCE values are switched so that the script operates as usual!!!
			[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"	#     if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since this is were we need to store packages by default
			TEMP="$REPO_SOURCE"							# store the existing value first
			REPO_SOURCE="${REPO_RESTOR}/${RESTORE}"					# store the passed restore point directory
			REPO_RESTOR="$TEMP"							# store the original REPO_SOURCE value in REPO_RESTOR (so we can copy those packages back into the system)
		}
		[ "$PROXY" ] && {								# NOTE: the REPO_RESTOR and REPO_SOURCE values are switched so that the script operates as usual!!!
			TEMP="$REPO_SOURCE"							# store the existing value first
			REPO_SOURCE="${PROXY}/pax/optional.proxy"				# store the passed proxy directory and append the rest of the path
			PROXY="$TEMP"								# store the original REPO_SOURCE value in PROXY (so we can copy those packages back into the system)
		}
		[ "$DIRECTORY" = "$REPO_OPTION" ] && {						#     if the DIRECTORY was NOT passed, then set to the default installation location
			( echo "$DIR_LIVE" | grep -qE '(/|\.)'$ ) || DIR_LIVE="${DIR_LIVE}/"	#        make sure the directory ends with a '/' or '.' (because the first '/' is stripped from the package files' path to allow for ~/.whatever)
			DIRECTORY="$DIR_LIVE"
		}
	fi
	if ( echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ); then				#   if the REPO_SOURCE is remote, then...
		cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'		#      change it to the REPO_OPTION directory since this is were we need to store packages by default
	else											#   otherwise a local REPO_SOURCE was passed, so...
		cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'		#      change into the local REPO_SOURCE
	fi
elif [ "$LIST" ]; then										# if we are listing installed packages, then...
	REPO_SOURCE="$DIR_LIST"									#   set the default value to DIR_LIVE for installed packages
	[ "$RESTORE" ] && REPO_SOURCE="$REPO_RESTOR"						#   if -R was passed, then we need to change to the restore point directory
	[ "$RESTORE" ] && ( echo "$RESTORE" | grep -q '/' ) && REPO_SOURCE="${REPO_SOURCE}/${RESTORE}"		# if a full restore path was passed to -R, then append it to REPO_SOURCE
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the DIRECTORY where the packages are located
elif [ "$MAKE" ]; then										# if we are creating a package for distribution, then...
	[ "$DIRECTORY" != "$REPO_OPTION" ] && REPO_SOURCE="$DIRECTORY"				#   if a directory was passed, then set the REPO_SOURCE as that value (so it can be used with '-S' interchangably)
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE='./'					#   if the REPO_SOURCE is still remote, then change it to the current directory
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the REPO_SOURCE where the source code or compiled software is
elif [ "$OPEN" ]; then
	[ "$DIRECTORY" != "$REPO_OPTION" ] && REPO_SOURCE="$DIRECTORY"				#   if a directory was appended to the list, then use that for the REPO_SOURCE
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$DIR_TEMP"				#   if the -S option was NOT passed, then use the default temp directory
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the REPO_SOURCE where the fifo needs to be created
elif [ "$TREE" ]; then										# if we are showing the dependency tree, then...
	[ "$DIRECTORY" != "$REPO_OPTION" ] && REPO_SOURCE="$DIRECTORY"				#   if a directory was appended to the list, then use that for the REPO_SOURCE
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$DIR_LIST"				#   if the -S option was NOT passed, then use the DIR_LIST for the REPO_SOURCE
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the DIRECTORY where the packages are located
elif [ "$UNLOAD" ]; then									# if we are unloading/uninstalling package(s), then...
	[ "$DIRECTORY" = "$REPO_OPTION" ] && {							#   if the DIRECTORY was NOT passed, then set to the default installation location
		( echo "$DIR_LIVE" | grep -qE '(/|\.)'$ ) || DIR_LIVE="${DIR_LIVE}/"		#     make sure the directory ends with a '/' or '.'
		DIRECTORY="$DIR_LIVE"
	}
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since we can only unload local packages
	[ "$RESTORE" ] && [ "$RESTORE" != 'none' ] && REPO_SOURCE="${REPO_RESTOR}"		# if a full restore path was passed to -R, then append it to REPO_SOURCE

	REPO_SYSTEM="$(pwd)"									# store the current directory for package checking (we use REPO_SYSTEM since it's only used by install during bootup)
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the REPO_SOURCE where the packages are
#elif [ "$VALIDATE" ]; then									# if we are validating package(s) information, then...
	# see the [ "$INSTALL" ] block above (to prevent code duplication)
fi




# PERFORM SOME ACTUAL WORK

[ "$COPY" ] && [ "$DEPS" != 'none' ] && [ ! "$PROXY" ] && showMsg 'action' "Processing dependencies for the packages..." 'both' 1 4
[ "$COPY" ] && ( [ "$DEPS" = 'none' ] || [ "$PROXY" ] ) && showMsg 'action' "Generating a package list to copy..." 'both' 1 4
[ "$DOWNLOAD" ] && [ "$DEPS" != 'none' ] && [ ! "$PROXY" ] && showMsg 'action' "Processing dependencies for the package(s)..." 'both' 1 4
[ "$DOWNLOAD" ] && ( [ "$DEPS" = 'none' ] || [ "$PROXY" ] ) && showMsg 'action' "Generating a package list to download..." 'both' 1 4
[ "$EXTRACT" ] && [ "$DEPS" != 'none' ] && showMsg 'action' "Processing dependencies for the package(s)..." 'both' 1 4
[ "$EXTRACT" ] && [ "$DEPS" = 'none' ] && showMsg 'action' "Generating a package list to extract..." 'both' 1 4
#[ "$FIND" ]
[ "$INSTALL" ] && [ "$DEPS" != 'none' ] && showMsg 'action' "Processing dependencies for the package(s)..." 'both' 1 4
[ "$INSTALL" ] && [ "$DEPS" = 'none' ] && showMsg 'action' "Generating a package list to install..." 'both' 1 4
#[ "$LIST" ]
#[ "$MAKE" ]
[ "$OPEN" ] && showMsg 'action' "Starting pax in client mode..." 'both' 1 1
[ "$PROXY" ] && [ ! "$INSTALL" ] && showMsg 'action' "Generating package list..." 'both' 1 4
[ "$TREE" ] && showMsg 'action' "Dependency trees for package(s)..." 'screen' 1 1
[ "$UNLOAD" ] && ( [ ! "$RESTORE" ] || [ "$RESTORE" = 'none' ] ) && showMsg 'action' "Building list for all packages to unload..." 'both' 1 4
[ "$UNLOAD" ] && [ "$RESTORE" ] && [ "$RESTORE" != 'none' ] && showMsg 'action' "Deleting the specified restore point..." 'both' 1 4
[ "$VALIDATE" = 'data' ] && showMsg 'action' "Processing dependencies for the package(s)..." 'both' 1 4
[ "$VALIDATE" = 'deps' ] && showMsg 'action' "Validating dependencies for the package(s)..." 'both' 1 4




# PROCESS PASSED PACKAGES

TEMP=''
for PARAMETER in $@; do
	splitName "$PARAMETER"									# NOTE: the PARAMETER value will be overwritten by the splitName() call

	[ $DEBUG -gt 0 ] && { echo -en "body (dependencies):\n\tPARAMETER   |${PARAMETER}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${ARCH}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\t# @         |${#} ${@}|\n\tpwd         |" >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	if [ "$PROXY" ] && [ ! "$INSTALL" ]; then						# if we are proxying an action, then...
		echo "$FILENAME" >> "${DIR_TEMP}/proxy.list"					# create the proxy package list
		continue
	elif [ ! "$DOWNLOAD" ] && [ ! "$FIND" ] && [ ! "$INSTALL" ] && [ ! "$LIST" ] && [ ! "$MAKE" ] && [ ! "$OPEN" ]; then
		if ( [ "$DEPS" = 'source' ] && [ ! -e "${REPO_SOURCE}/${FILENAME}" ] ) || ( [ ! -e "${REPO_SOURCE}/${FILENAME}" ] && [ ! -e "${REPO_OPTION}/${FILENAME}" ] && [ ! -e "${REPO_SYSTEM}/${FILENAME}" ] ); then
			showMsg 'failure' "The '${FILENAME}' package does not exist." 'both'
			exitGracefully 1 'both' 5 'action'
		fi
	fi

	#if [ "$COPY" ]; then									# if we are copying package(s), then...
		# this executes the processDependencies() call below
	#elif [ "$DOWNLOAD" ]; then								# if we are downloading package(s), then...
		# this executes the processDependencies() call below
	#elif [ "$EXTRACT" ]; then								# if we are extracting package(s) contents, then...
		# this executes the processDependencies() call below
	if [ "$FIND" ]; then									# if we are finding file(s) in packages, then...
		showMsg 'action' "Searching for '${PACKAGE}' in packages..." 'both' 1 4		# NOTE: we store to the log so if any error occurs, we know what it relates to (the rest of this section can just show to the screen)
		for FILE in $(ls -1 *.${EXT_SOFT}); do
			[ $(stat -c %s $FILE) -eq 0 ] && continue				#   skip all 0 byte files (since they can just be placeholders); this really shouldn't come into play in this location, but better safe than sorry
			unsquashfs -ll $FILE | tail -n +5 | grep -v ^d | sed 's:.*/::' | grep -q "$PACKAGE" && {
				showMsg 'package' "   $FILE" 'screen' 1 4 1
				showMsg 'file' "$(unsquashfs -ll "$FILE" | tail -n +5 | grep -v ^d | sed 's/.*squashfs-root/      /' | grep "$PACKAGE")" 'screen' 1 2 1
			}
		done
		continue
	elif [ "$INSTALL" ]; then								# if we are installing package(s), then...
		# this executes the processDependencies() call below (unless PROXY or RESTORE is triggered below)
		if [ "$PROXY" ] || [ "$RESTORE" ]; then
			[ "$PROXY" ] && TEMP="$PROXY" || TEMP="$RESTORE"
			# NOTE: the PROXY|RESTORE and REPO_SOURCE values are switched so that the script operates as usual!!!
			[ -e "${TEMP}/${FILENAME}" ] && [ ! "$FORCE" ] && {
				showMsg 'dependency' "[  exist  ] {COLOR}(${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
				showMsg 'failure' "The package currently exists in the repo (${TEMP})." 'log'
				continue
			}
		fi
	elif [ "$LIST" ]; then									# if we are listing installed packages, then...
		TEMP="${TEMP}${PARAMETER}|"							#   adding to the regex statement
		continue
	elif [ "$MAKE" ]; then									# if we are creating a package for distribution, then...
		if [ -e "./${BASENAME}.${EXT_MAKE}" ] && [ -x "./${BASENAME}.${EXT_MAKE}" ]; then						# if a compile script exists (and is executable), then lets run that first!
			showMsg 'action' "Compiling the '${PACKAGE}' package..." 'both' 1 4							# NOTE: so that the compile script can output if desired
			./${BASENAME}.${EXT_MAKE} >${BASENAME}.${EXT_MAKE}.log 2>&1 || exitGracefully 4 'both' 6 'action'
			showMsg 'action' "" 'both' 1 5
		fi

		showMsg 'action' "Creating the '${PACKAGE}' package..." 'both' 1 4

		showMsg 'step' "   [1/4] Erasing any prior files:" 'both' 0 3			# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
		[ -e "${FILENAME}" ] && { rm -f "${FILENAME}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		[ -e "${BASENAME}.${EXT_HASH}" ] && { rm -f "${BASENAME}.${EXT_HASH}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		[ -e "${BASENAME}.${EXT_LIST}" ] && { rm -f "${BASENAME}.${EXT_LIST}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		[ -e "${BASENAME}.${EXT_INFO}" ] && { rm -f "${BASENAME}.${EXT_INFO}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		[ -e "${BASENAME}.${EXT_DEPS}" ] && { rm -f "${BASENAME}.${EXT_DEPS}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		showMsg 'step' " [done]" 'both' 1 5

		showMsg 'step' "   [2/4] Creating the .${EXT_SOFT} file:" 'both' 0 3
		[ -d "${DIRECTORY}/package" ] && TEMP='package' || TEMP='./'			# if the compiled software call above created a 'package' directory then use it to create the packages below, otherwise use the directory that was passed
		mksquashfs "${TEMP}" "${FILENAME}" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'step'
		showMsg 'step' " [done]" 'both' 1 5

		showMsg 'step' "   [3/4] Creating the .${EXT_HASH} file:" 'both' 0 3
		md5sum "${FILENAME}" >"${BASENAME}.${EXT_HASH}" 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'
		showMsg 'step' " [done]" 'both' 1 5

		showMsg 'step' "   [4/4] Creating the .${EXT_LIST} file:" 'both' 0 3
		find "${TEMP}" -not -type d 2>>"$LOG_ERRS" | sed "s|${TEMP}||" >"${BASENAME}.${EXT_LIST}" 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'
		showMsg 'step' " [done]" 'both' 1 5

		showMsg 'note' "\nThe package has been created!\nDon't forget to create/update the .${EXT_DEPS} and .${EXT_INFO} files!\n" 'both' 1 2 1
		showMsg 'success' "" 'both' 1 6
		exit 0										# prevent the code below from executing since we're done with this ACTION
	elif [ "$OPEN" ]; then									# if we are opening a fifo, then...
		if [ "$PARAMETER" != 'clear' ]; then						#   if a different fifo name was passed, then set it
			FIFO_SERVER="$PARAMETER"
		elif [ -e "${FIFO_SERVER}" ] && [ ! "$FORCE" ]; then				#   if the fifo exists -AND- we're not forcing the action, then there might have been an error previously so...
			rm -f "${FIFO_SERVER}" || {						#      delete it
				showMsg 'failure' "The input FIFO could not be cleared." 'screen'
				exit 1
			}
		fi
		continue
	elif [ "$TREE" ]; then									# if we are showing the dependency tree, then...
		if [ "$TREE" = 'reliant' ]; then						# if we need to show which packages are reliant upon the ones passed, then...
			showMsg 'package' "${PACKAGE} (${FILETYPE})" 'screen' 1 4
			for FILE in $(grep -lE ^"(${BASENAME}|${FILENAME})" *.${EXT_DEPS}); do
				splitName "$FILE" "$EXT_DEPS"
				showMsg 'file' "   (${FILETYPE}) ${PACKAGE}" 'screen' 1 4
			done
			continue
		fi										# otherwise we need to show which packages this one depends on, so lets call processDependencies()!
	#elif [ "$UNLOAD" ]; then								# if we are unloading/uninstalling package(s), then...
		# this executes the processDependencies() call below
	#elif [ "$VALIDATE" ]; then								# if we are validating package(s) information, then...
		# this executes the processDependencies() call below
	fi

	# NOTE: everything below this point in this segment is simply to build the dependency list, the actual work is done in the following 'while' loop
	processDependencies "${FILENAME}" 'FALSE' || exitGracefully 2 'screen' 5 'step'
done




# EXIT CHECK

[ "$VALIDATE" = 'deps' ] && exitGracefully 0 'both' 6 'success'											# there's no more work to perform if this was the action to process
[ "$UNLOAD" ] && [ ! "$RESTORE" ] && [ ! -e "${DIR_TEMP}/unload.${EXEID}" ] && exitGracefully 0 'both' 6 'success'				# there's no more work to perform if the 'unload' file doesn't exist at this point
[ $INDEX -eq 0 ] && [ ! "$FIND" ] && [ ! "$LIST" ] && [ ! "$OPEN" ] && [ ! "$PROXY" ] && [ "$TREE" != 'reliant' ] && [ ! "$UNLOAD" ] && {
	[ "$TREE" != 'relies' ] && showMsg 'action' "There are no package(s) to be processed." 'both' 1 4
	exitGracefully 0 'both' 6 'success'
}




# PROCESS THE ACTION

if ( [ $DEBUG -gt 1 ] || [ "$PROMPT" ] ) && [ ! "$UNLOAD" ]; then				# NOTE: the UNLOAD prompt is below
	if [ "$PROMPT" ] && ( [ ! "$PROXY" ] || ( [ "$PROXY" ] && [ "$INSTALL" ] ) ) && [ ! "$VALIDATE" ]; then
		[ "$COPY" ] && TEMP='copied'
		[ "$DOWNLOAD" ] && TEMP='downloaded'
		[ "$EXTRACT" ] && TEMP='extracted'
		#[ "$FIND" ]
		[ "$INSTALL" ] && TEMP='installed'
		#[ "$LIST" ]
		#[ "$MAKE" ]
		#[ "$OPEN" ]
		#[ "$TREE" ]
		#[ "$UNLOAD" ]
		#[ "$VALIDATE" ]

		showMsg 'action' "The following package(s) will be ${TEMP}:" 'both' 1 4
		listDependencies
	fi

	showMsg 'prompt' "   Do you want to proceed with the action? [Y/N] (N): " 'both' 0 1 1
	[ "$OUTPUT" = 'fifo' ] && read <"$FIFO_SERVER" || read
	( [ "$REPLY" = 'N' ] || [ "$REPLY" = 'n' ] || [ "$REPLY" = '' ] ) && {
		echo 'n' >>"$LOG_ERRS"
		exitGracefully 0 'both' 6 'success'
	}
	echo 'y' >>"$LOG_ERRS"
fi


[ "$COPY" ] && [ ! "$PROXY" ] && showMsg 'action' "Copying the specified package(s)..." 'both' 1 4
[ "$DOWNLOAD" ] && [ ! "$PROXY" ] && showMsg 'action' "Downloading the specified package(s)..." 'both' 1 4
[ "$EXTRACT" ] && showMsg 'action' "Extracting the specified package(s)..." 'both' 1 4
#[ "$FIND" ]
[ "$INSTALL" ] && {
	showMsg 'action' "Installing the specified package(s)..." 'both' 1 4

	# NOTE: this MUST be here and not in the parameter processing section above, because the -M option may not get passed!
	if [ ! "$MODE" ] && ( [ -e "${REPO_PREFIX}/${FLAG_COPY}" ] || ( [ -e "${REPO_PREFIX}/${FLAG_FIRM}" ] && [ "$BOOTING" ] ) || [ "$(getBootcode mode)" != "conservative" ] ); then
		[ $DEBUG -gt 0 ] && echo -e "\tInstall by copying..." >>"$LOG_DBUG"
		MODE='copy'
	elif [ "$MODE" != 'copy' ]; then
		[ $DEBUG -gt 0 ] && echo -e '\tInstall using symlinks...' >>"$LOG_DBUG"
		MODE='link'
	fi

	# now swap the directories back so that the existing code works as normal
	if [ "$PROXY" ]; then
		TEMP="$REPO_SOURCE"
		REPO_SOURCE="${PROXY}"
		PROXY="$TEMP"
		cd "$REPO_SOURCE"
	elif [ "$RESTORE" ]; then
		TEMP="$REPO_SOURCE"
		REPO_SOURCE="${REPO_RESTOR}"
		REPO_RESTOR="$TEMP"
		cd "$REPO_SOURCE"
	fi
}
#[ "$LIST" ]
#[ "$MAKE" ]
#[ "$OPEN" ]
#[ "$TREE" ]
#[ "$UNLOAD" ]
[ "$VALIDATE" ] && showMsg 'action' "Validating the package contents..." 'both' 1 4


# now process the dependencies obtained from the above segment!
for INDEX in $(seq 1 $TOTAL); do								# while we have a dependency to process (via the TOTAL value set by addDependency())
	eval DEPENDENCY="\$DEP${INDEX}"								#   set the dependency to process each iteration

	splitName "$DEPENDENCY"

	[ $DEBUG -gt 0 ] && { echo -en "body (implementation):\n\tINDEX       |${INDEX}|\n\tPARAMETER   |${PARAMETER}|\n\tDEPENDENCY  |${DEPENDENCY}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tTYPE        |${FILETYPE}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |$VERFILE|\n\tVERBASE     |${VERBASE}|\n\tDOWNLOAD    |$DOWNLOAD|\n\tpwd         |" >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	# NOTE: this is a separate 'if' on purpose (since several actions require downloading)!
	if [ "$DOWNLOAD" ] || ( [ "$INSTALL" ] && ( echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) && [ ! -e "${REPO_OPTION}/${FILENAME}" ] ); then
		showMsg 'file' "(${FILETYPE}) ${PACKAGE}:" 'both' 0 3
		[ "$DRYRUN" ] && showMsg 'notice' " [dryrun]" 'both' 0 0
		[ "${INSTALL}" ] && showMsg 'step' " [download]" 'both' 0
		downloadPackage || exitGracefully 4 'screen' 5 'step'
	else
		[ "$VALIDATE" ] && showMsg 'package' "(${FILETYPE}) ${PACKAGE}:" 'both' 0 3
		[ ! "$VALIDATE" ] && showMsg 'file' "(${FILETYPE}) ${PACKAGE}:" 'both' 0 3
		[ "$DRYRUN" ] && showMsg 'notice' " [dryrun]" 'both' 0 0
	fi

	# NOTE: this is a separate 'if' on purpose (since several actions require downloading)!
	if [ "$COPY" ]; then									# if we're copying package(s), then...
		copyPackage || {
# VER2 - we need to re-work the exitGracefully() so that we don't need three different calls
			[ "$OUTPUT" = 'text' ] && exitGracefully 3 'screen' 0
			[ "$OUTPUT" = 'xml' ] && exitGracefully 2 'screen' 6
			[ "$OUTPUT" = 'xmLive' ] && exitGracefully 3 'screen' 6
		}
	#elif [ "$DOWNLOAD" ]; then								# if we are downloading package(s), then...
		# this is required my several actions and is handled above this 'if' block
	elif [ "$EXTRACT" ]; then								# if we are extracting package(s) contents, then...
		SOURCE=''
		if [ -e "${REPO_SOURCE}/${FILENAME}" ]; then SOURCE="$REPO_SOURCE"		# if the package is in the specified directory, then...
		elif [ -e "${REPO_OPTION}/${FILENAME}" ]; then SOURCE="$REPO_OPTION"		# if the package is in the REPO_OPTION directory, then...
		elif [ -e "${REPO_SYSTEM}/${FILENAME}" ]; then SOURCE="$REPO_SYSTEM"; fi	# if the package is in the REPO_SYSTEM directory, then...

		# NOTE: we can NOT make unsquashfs use the 'pax -F' option since it will just error
		#	with success even though it doesn't process anything if files or directory
		#	structures exist. As a result always force unsquashfs to operate to ensure
		#	the process works.
		[ $DEBUG -gt 0 ] && echo -e "\tCalling:    unsquashfs -f -d \"$DIRECTORY\" \"${SOURCE}/${FILENAME}\"" >>"$LOG_DBUG"
		[ ! "$DRYRUN" ] && { unsquashfs -f -d "$DIRECTORY" "${SOURCE}/${FILENAME}" 1>/dev/null 2>>"$LOG_ERRS" || exitGracefully 3 'both' 6 'failure'; }
	#elif [ "$FIND" ]; then									# if we are finding file(s) in packages, then...
		# this is handled in the package processing above
	elif [ "$INSTALL" ]; then								# if we're installing package(s), then...
# UPDATED 2026/01/12 - we use BASENAME not FILENAME
#		[ ! -e "${DIR_LIST}/${FILENAME}" ] && showMsg 'step' " [install]" 'both' 0 0
#		[ -e "${DIR_LIST}/${FILENAME}" ] && showMsg 'step' " [update]" 'both' 0 0
		[ ! -e "${DIR_LIST}/${BASENAME}" ] && showMsg 'step' " [install]" 'both' 0 0
		[ -e "${DIR_LIST}/${BASENAME}" ] && showMsg 'step' " [update]" 'both' 0 0

		# NOTE: we have to copy files this way because they were mounting in the original {proxy|restore} location, so if MODE=link, it would be incorrect
		if [ "$PROXY" ] || [ "$RESTORE" ]; then
			[ "$PROXY" ] && TEMP="$PROXY" || TEMP="$REPO_RESTOR"
			unalias cp >/dev/null 2>&1						#   remove anything existing that would force prompting for overwritting (e.g. alias cp='cp -i')

			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"${TEMP}/${BASENAME}\".* \"./\"" >>"$LOG_DBUG"
			[ ! "$DRYRUN" ] && ( cp -f "${TEMP}/${BASENAME}".* "./" 2>&1 | sed "s/^cp: can't preserve ownership.*//;/^$/d;s/^c/ \[failure\]\nc/" | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {		# copy the file from the source directory
				showMsg 'failure' "The package file copy failed (${TEMP})." 'log'
				return 1
			}
		fi
		installPackage || exitGracefully 4 'screen' 5 'step'
	#elif [ "$LIST" ]; then									# if we are listing the installed packages, then...
		# this is handled in the final processing below
	#elif [ "$MAKE" ]; then									# if we are creating a package for distribution, then...
		# this is handled in the package processing above
	#elif [ "$OPEN" ]; then
		# this is handled in the final processing below
	#elif [ "$TREE" ]; then									# if we are showing the dependency tree, then...
		# this is handled in the final processing below
	#elif [ "$UNLOAD" ]; then								# if we're unloading package(s), then...
		# this is handled in the final processing below
	elif [ "$VALIDATE" ]; then								# if we're validating package(s), then...
		# NOTE: this was put here in case some packages are symlinked and some are copied
		( /bin/mount 2>>"$LOG_ERRS" | grep -q "${DIR_LOOP}/${BASENAME} type squashfs" ) && MODE='link' || MODE='copy'			# store the package installation mode: symlinked or copied

		# NOTE: the installPackage() will process the appropriate validation request
		installPackage || exitGracefully 4 'screen' 5 'step'
	fi
	[ ! "$VALIDATE" ] && showMsg 'file' " [done]" 'both' 1 5 || showMsg 'file' "" 'both' 1 5

	deleteDependency 'i'									# delete the dependency before assigning the next one below
done




# EXECUTE FINAL PROCESSING

if [ "$LIST" ]; then
	# if we're listing parts of a restore point (e.g. '*' or '2025-01-03'), then...
	if [ "$RESTORE" ] && ( ! echo "$RESTORE" | grep -q '/' ); then
		[ "$RESTORE" = '*' ] && RESTORE=''						# this is to prevent recursion into each DATE directory with the 'ls' call
		[ "$RESTORE" ] && ( ! echo "$RESTORE" | grep -q '/' ) && TEMP="$RESTORE"	# if only a date was passed to -R, then use it's value in the 'grep' below

		IFS=$'\n'									# update the IFS to not split strings using spaces
		for DATE in $(ls -1 2>/dev/null | grep "$TEMP"); do
			showMsg 'directory' "${DATE}" 'screen' 1 4

			for POINT in $(cd $DATE && ls -1 2>/dev/null); do
				showMsg 'file' "  $POINT" 'screen' 1 1 1
			done
		done
		exitGracefully 0 'screen' 6 'success'
	fi

	# if we've made it here, then we're perform a normal listing -OR- a listing for a specific restore point (e.g. '2025-01-03/Updating package')

	[ "$TEMP" ] && TEMP="^(${TEMP%|*})"							# if specific packages were passed, then construct a regex grep statement with packages matching the beginning of each name entered

	if [ "$OUTPUT" = 'text' ]; then
		printf "${BLUE}%-30s %-9s %5s %-32s\n" "Name" " Version" "Types" "              Hash"
		printf "${WHITE}%30s %-9s %5s %32s\n" "------------------------------" "---------" "-----" "--------------------------------"
	fi

# UPDATED 2026/01/12
#	for FILE in $(ls -1 *.${EXT_SOFT} 2>/dev/null | grep -E "${TEMP}"); do			# NOTE: using 'grep' allows for passing specific packages
	for FILE in $(ls -1 *.${EXT_CORE} *.${EXT_HASH} 2>/dev/null | grep -E "${TEMP}"); do	# NOTE: using 'grep' allows for passing specific packages
#		splitName "$FILE"
		( echo "$FILE" | grep -q "$EXT_CORE"$ ) && splitName "$FILE" "$EXT_CORE"
		( echo "$FILE" | grep -q "$EXT_HASH"$ ) && splitName "$FILE" "$EXT_HASH"

		case $BASENAME in
			*-dev*|*_dev*|*.dev*) TYPE='dev' ;;
			*-doc*|*_doc*|*.doc*) TYPE='doc' ;;
			*-drv*|*_drv*|*.drv*) TYPE='drv' ;;
			*-gir*|*_gir*|*.gir*) TYPE='gir' ;;
			*-lib*|*_lib*|*.lib*) TYPE='lib' ;;
			*-loc*|*_loc*|*.loc*) TYPE='loc' ;;
			*) TYPE='bin' ;;
		esac
		if [ "$OUTPUT" = 'fifo' ]; then
			echo "$PACKAGE" >"${DIR_TEMP}/output"
			echo "$TYPE" >"${DIR_TEMP}/output"
			[ -e ${BASENAME}.${EXT_INFO} ] && cat ${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//' >"${DIR_TEMP}/output"
			[ -e ${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${BASENAME}.${EXT_HASH} >"${DIR_TEMP}/output"
			[ -e ${BASENAME}.${EXT_INFO} ] && cat ${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//' >"${DIR_TEMP}/output"
		elif [ "$OUTPUT" = 'text' ]; then
			printf "${BLUE}%-30s ${GREY}%-49s\n" "$PACKAGE" "$([ -e ${BASENAME}.${EXT_INFO} ] && cat ${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//' | head -c 48)"
			printf "${TEAL}%40s ${CYAN}%-5s ${DARKGREY}%-32s${NORMAL}\n" "$([ -e ${BASENAME}.${EXT_INFO} ] && cat ${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//')" " $TYPE" "$([ -e ${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${BASENAME}.${EXT_HASH})"
		elif [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ]; then
			showMsg 'package' "$PACKAGE" 'screen' 1 4
			showMsg 'type' "$TYPE" 'screen'
			showMsg 'version' "$([ -e ${BASENAME}.${EXT_INFO} ] && cat ${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//')" 'screen'
			showMsg 'hash' "$([ -e ${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${BASENAME}.${EXT_HASH})" 'screen'
			showMsg 'description' "$([ -e ${BASENAME}.${EXT_INFO} ] && cat ${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//')" 'screen'
		fi
	done

elif [ "$OPEN" ]; then
	if [ -e "${FIFO_SERVER}" ] && [ ! "FORCE" ]; then
		showMsg 'failure' "Pax is already running in this mode." 'screen'
		exit 1
	elif [ ! -e "${FIFO_SERVER}" ]; then
		mknod -m 700 "${FIFO_SERVER}" p || {
			showMsg 'failure' "The FIFO could not be created." 'screen'
			exit 1
		}
	fi

	while true; do
		if read LINE <"${FIFO_SERVER}" 2>>"$LOG_ERRS"; then
			[ "$LINE" == 'quit' ] && break
			showMsg 'start' "\n\n------- [ FIFO: Script Execution ] -------" 'log'
			showMsg 'start' "           $(date +'%Y-%m-%d  %H:%M:%S')\n" 'log'
			showMsg 'action' "EXECUTE: $LINE" 'both'
			( echo "$LINE" | grep -q ^'pax ' ) || {					# first check to make sure that it's a pax command that's getting issued
				showMsg 'failure' "An invalid command was attempted." 'both'
				continue
			}
			( echo "$LINE" | grep -qE '(;|&&|\|\|)' ) && {				# now check that (malicious) chained commands aren't passed (e.g. 'pax ... && rm -Rf /')
				showMsg 'failure' "An invalid command was attempted." 'both'
				continue
			}
			$LINE
		fi
	done
	showMsg 'action' "Shutting down the client communication..." 'both'
	rm -f "${FIFO_SERVER}" 2>>"$LOG_ERRS"

# now move the proxy files to the external storage device
elif [ "$PROXY" ] && [ ! "$INSTALL" ]; then
	showMsg 'action' "Implementing the proxy..." 'both' 1 4

	showMsg 'step' "   [1/5] Creating proxy.sh script:" 'both' 0 3				# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
	proxyAction
	showMsg 'step' " [done]" 'both' 1 5

	showMsg 'step' "   [2/5] Adjusting script permissions:" 'both' 0 3			# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
	chmod 755 "${DIR_TEMP}/proxy.sh" "${DIR_TEMP}/proxy.sh" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'action'
	showMsg 'step' " [done]" 'both' 1 5

	showMsg 'step' "   [3/5] Preparing the media:" 'both' 0 3				# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
	if [ ! -d "${PROXY}/pax" ]; then
		showMsg 'step' " [creating]" 'both' 0 0
		mkdir -p "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'action'
	else
		showMsg 'step' " [exists]" 'both' 0 5
		( [ -e "${PROXY}/pax/TEMP" ] || [ -e "${PROXY}/pax/optional.proxy" ] || [ -e "${PROXY}/pax/proxy.sh" ] || [ -e "${PROXY}/pax/proxy.list" ] ) && showMsg 'step' " [cleaning]" 'both' 0 5

		[ -e "${PROXY}/pax/proxy.sh" ] && { rm -f "${PROXY}/pax/proxy.sh" 2>>"$LOG_ERRS" || exitGracefully 3 'both' 6 'failure'; }
		[ -e "${PROXY}/pax/proxy.list" ] && { rm -f "${PROXY}/pax/proxy.list" 2>>"$LOG_ERRS" || exitGracefully 3 'both' 6 'failure'; }
		[ -e "${PROXY}/pax/TEMP" ] && { rmdir "${PROXY}/pax/TEMP" 2>>"$LOG_ERRS" || exitGracefully 3 'both' 6 'failure'; }
		if [ -e "${PROXY}/pax/optional.proxy" ]; then					# if packages were found on here, then move them to a backup location
			if [ ! -e "${PROXY}/pax/optional.proxy.bak" ]; then			# if a backup directory doesn't already exists, then create it
				mkdir -p "${PROXY}/pax/optional.proxy.bak" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'action'
			fi									# now move the packages into it before proceeding
			if [ "$(ls -A "${PROXY}/pax/optional.proxy" 2>/dev/null)" ]; then
				unalias mv >/dev/null 2>&1
				mv "${PROXY}/pax/optional.proxy/"* "${PROXY}/pax/optional.proxy.bak/" || {
					echo "The removable media has duplicate packages and needs to be cleaned manually." >>"$LOG_ERRS"
					exitGracefully 3 'both' 6 'failure'
				}
			fi
			rmdir "${PROXY}/pax/optional.proxy" 2>>"$LOG_ERRS"
		fi
	fi
	showMsg 'step' " [done]" 'both' 1 5

	showMsg 'step' "   [4/5] Moving proxy.sh script:" 'both' 0 3				# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
	mv "${DIR_TEMP}/proxy.sh" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'action'
	showMsg 'step' " [done]" 'both' 1 5

	showMsg 'step' "   [5/5] Moving the proxy list :" 'both' 0 3				# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
	mv "${DIR_TEMP}/proxy.list" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'action'
	showMsg 'step' " [done]" 'both' 1 5
	showMsg 'note' "\nNext steps...\n  1. Plug the removable media into another Linux device\n  2. Execute the \"proxy.sh\" script under the \"pax\" folder on the media\n  3. Wait for the script to finish and return the media back to this device\n  4. Execute the \"proxy.sh\" script again, or use pax directly for more\n     advanced installations\n" 'both' 1 2 1
	showMsg 'success' "" 'both' 1 6

elif [ "$TREE" ]; then
	# if we need to show which packages are reliant upon the ones passed, then...
	if [ "$TREE" = 'reliant' ] && [ ! "$1" ]; then						# if we need to process ALL installed packages, then...		NOTE: the first 'while' loop for this action is used to process specific PASSED packages
		for PACKAGE in $(ls -1 *.${EXT_SOFT}); do					# cycle each package to see what other packages depend on it
			splitName "$PACKAGE"
			showMsg 'package' "${PACKAGE} (${FILETYPE})" 'screen' 1 4

			for FILE in $(grep -lE ^"(${BASENAME}|${FILENAME})" *.${EXT_DEPS}); do
				splitName "$FILE" "$EXT_DEPS"
				showMsg 'file' "   (${FILETYPE}) ${PACKAGE}" 'screen' 1 4
			done
		done
	fi

elif [ "$UNLOAD" ]; then
	# if we're deleting a restore point, then...
	if [ "$RESTORE" ] && [ "$RESTORE" != 'none' ]; then
		showMsg 'package' "${RESTORE%/*}" 'both' 1 4
		[ "${RESTORE#*/}" != "${RESTORE%/*}" ] && showMsg 'file' "  ${RESTORE#*/}" 'both' 1 1 1

		[ $DEBUG -gt 0 ] && {
			echo -en "body (final processing):\n\tRESTORE PNT |${RESTORE}|\n\tpwd         |" >>"$LOG_DBUG"
			pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS";
			echo -e "\tCalling:    rm -Rf \"${RESTORE}\"" >>"$LOG_DBUG"
		}
		[ ! "$DRYRUN" ] && ( rm -Rf "${RESTORE}" 2>&1 | sed "/^$/d;s/^r/ \[failure\]\nr/" | tee -a "$LOG_ERRS" | grep -q ^'rm: ' ) && {	# copy the file from the source directory
			showMsg 'failure' "The restore point deletion failed (${RESTORE})." 'log'
			return 1
		}
		exitGracefully 0 'both' 6 'success'
	fi

	# if we've made it here we're doing an some type of unload so...
	UNLOAD="${UNLOAD}2"															# indicate we are in the second stage of the process

	if [ "$UNLOAD" != 'update2' ]; then
		[ ! "$FORCE" ] && showMsg 'action' "Removing packages that can't be unloaded..." 'both' 1 4

		I=1
		touch "${DIR_TEMP}/compare.${EXEID}"
		while ( ! diff "${DIR_TEMP}/unload.${EXEID}" "${DIR_TEMP}/compare.${EXEID}" >/dev/null ); do					# NOTE: this 'while' loop goes through the process below until no more packages can be removed from the list
			# finalize the packages to unload
			for FILE in $(cat "${DIR_TEMP}/unload.${EXEID}"); do									# for each package listed for removal (in the unload list from processDependencies() above)...
				[ "$FORCE" ] && continue											# if the action is being forced, then we need to remove everything
				( grep -qe ^"$FILE" "${DIR_TEMP}/unload.${EXEID}" ) || continue							# if we've removed files from the unload list in the below 'while [ "$DEPENDENCY" ]; do' section, then this skips their processing
																		# NOTE: we have to include the above line since the 'cat' call in the encapsulating 'for' loop will retain all the ORIGINAL values in the text file, not any of the removals from the 'while' below!
				TEMP="$(echo "$FILE" | sed 's/^+//')"										# remove the preceeding '+' (notating a dependency vs specified package)
				[ $DEBUG -gt 0 ] && echo -e "Body (final):\n\tFILE        |${TEMP}|" >>"$LOG_DBUG"				# NOTE: we need to remove any leading spacing (notating the FILE is a dependency instead of a specified package)

				for DEPFILE in $(grep -Hl "${TEMP}" "${DIR_LIST}/"*.${EXT_DEPS} 2>/dev/null | sed "s|${DIR_LIST}/||"); do	#   for each .deps file (in REPO_SOURCE) that contains the iterated to-be-unloaded FILE package...
					DEPBASE="$(echo "$DEPFILE" | sed "s/.${EXT_DEPS}$//")"							#   remove the file extension from the name of that found dependency package to get its basename

					# NOTE: the next line can become a problem if the DEPBASE is left on the list, but a package it relies on further down in the list ends up getting removed from
					#	the unload list - meaning the original DEPBASE now needs to be removed also. We would be removing a dependency for a package that was later removed from
					#	the list. This is what the outter 'while' loop attempts to resolve by looping until all the dependencies can safely be removed from the list.
					( grep -qe ^"+*$DEPBASE" "${DIR_TEMP}/unload.${EXEID}" ) && continue					#   if the iterated .deps file (via its basename), is also listed for removal (in the unload list), then it needs to be unloaded also so leave it in the list and go to the next DEPFILE; NOTE: the optional preceeding '+' notates a dependency vs specified package
					( head -n $I "${DIR_TEMP}/unload.${EXEID}" | grep -q ^"+*$DEPFILE" ) && continue			#   if the iterated to-be-unloaded package is a dependency for a package that's higher in the list (meaning it is definitely being unloaded), then leave it on the list

					# if we've made it here, then a package that is NOT being unloaded still needs the iterated to-be-unloaded package, so we can't unload it and need to remove it from the list

					[ $DEBUG -gt 0 ] && echo -e "\tOther installed packages depend on ${TEMP},\n\tprocessing its dependencies for removal from the unload list..." >>"$LOG_DBUG"

					processDependencies "${TEMP}" 'FALSE'									#   store all it's dependencies

					[ $DEBUG -gt 0 ] && echo -e "Body (final - returned):\n\tFILE        |${TEMP}|\n\tRemoving ${TEMP} and its dependencies from the unload list..." >>"$LOG_DBUG"
					while [ "$DEPENDENCY" ]; do										#   and delete them (and blank lines) from the removal list (the unload list)
						sed -i "s/^+*${DEPENDENCY}//;/^$/d" "${DIR_TEMP}/unload.${EXEID}"				#   NOTE: we check for preceeding space too if the DEPENDENCY is actually a dependency
						deleteDependency 'd'
					done

					break													# we only need to check that one other installed, unmarked package depends on the iterated package, so we can exit the inner 'for' loop
				done
				I=$(( I + 1 ))
			done

			unalias cp 2>/dev/null
			cp -f "${DIR_TEMP}/unload.${EXEID}" "${DIR_TEMP}/compare.${EXEID}" 2>>"$LOG_ERRS"					# now copy the current unload list to compare against (until the two lists are the same)
		done
	fi

	[ ! -e "${DIR_TEMP}/unload.${EXEID}" ] && {
		showMsg 'action' "There are no package(s) to be processed." 'both' 1 4
		exitGracefully 0 'both' 6 'success'
	}

	[ "$UNLOAD" = 'update2' ] && TEMP='update' || TEMP='unload'
	if ( [ $DEBUG -gt 1 ] || [ "$PROMPT" ] ); then
		showMsg 'action' "The following package(s) will be ${TEMP}ed:" 'both' 1 4
		showMsg 'package' "$(cat "${DIR_TEMP}/unload.${EXEID}" | sed 's/^+//g')" 'both' 1 2

		showMsg 'prompt' "   Do you want to proceed with the action? [Y/N] (N): " 'both' 0 1 1
		[ "$OUTPUT" = 'fifo' ] && read <"$FIFO_SERVER" || read
		( [ "$REPLY" = 'N' ] || [ "$REPLY" = 'n' ] || [ "$REPLY" = '' ] ) && exitGracefully 0 'both' 6 'success'
		echo >>"$LOG_ERRS"
	fi

	[ "$UNLOAD" = 'update2' ] && TEMP='Updat'
	[ "$UNLOAD" = 'unload2' ] && TEMP='Unload'
	[ "$UNLOAD" = 'unlist2' ] && TEMP='Unlist'
	showMsg 'action' "${TEMP}ing packages remaining in the list..." 'both' 1 4

	for DEPENDENCY in $(cat "${DIR_TEMP}/unload.${EXEID}"); do				# for each package remaining in the list for removal...
		splitName "$DEPENDENCY"

		unloadPackage "$FILENAME" || exitGracefully 3 'both' 6 'failure'		#   unload it
		[ "$UNLOAD" = 'update2' ] && {
			showMsg 'step' " [install]" 'both' 0

			# NOTE: REPO_SYSTEM holds the pwd when the script was executed to make sure that the updated package exists there
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    mv \"${REPO_SYSTEM}/${BASENAME}\"* \"$REPO_SOURCE\"" >>"$LOG_DBUG"
			[ ! "$DRYRUN" ] && { mv "${REPO_SYSTEM}/${BASENAME}"* "$REPO_SOURCE" 2>>"$LOG_ERRS" || exitGracefully 3 'both' 6 'failure'; } # move all the updated package files into REPO_SOURCE

			installPackage || exitGracefully 3 'both' 6 'failure'			# install THAT copy
		}
		showMsg 'file' " [done]" 'both' 1 5
	done
fi




# now update the system that all the packages contents have been installed
if [ "$INSTALL" ] || [ "$UNLOAD" ]; then							# since these are the only ACTIONs that would require the system to be updated...
	# if any processing so far has determined that a package(s) have kernel modules to process, then...					  NOTE: no need for 'sudo' when booting since the user is root at that time
	if [ "$MODULES" ]; then
		[ $DEBUG -gt 0 ] && echo -e '\tThere are kernel modules to (un)install...' >>"$LOG_DBUG"
		/sbin/depmod -a >>"$LOG_ERRS" 2>&1
		/sbin/udevadm trigger >>"$LOG_ERRS" 2>&1
	fi
	if [ "$LIBRARIES" ]; then
		[ $DEBUG -gt 0 ] && echo -e '\tThere are dynamic libraries to (un)install...' >>"$LOG_DBUG"
		/sbin/ldconfig >>"$LOG_ERRS" 2>&1
	fi
fi


# now call any marker/service scripts (if not unloading which is handled in unloadPackage())
if [ "$INSTALL" ]; then
	[ "$DIRECTORY" = '/' ] && DIRECTORY=''							# if DIRECTORY is just the root, then clear its value to prevent leading double slashes in the path

	if [ -s ${DIR_TEMP}/installs.list ]; then
		showMsg 'action' "Running deferred install scripts..." 'both' 1 4
		for FILE in $(cat ${DIR_TEMP}/installs.list); do
			showMsg 'file' "  ${DIRECTORY}${DIR_INST}/${FILE}:" 'both' 0 1
			[ ! "$DRYRUN" ] && "${DIRECTORY}${DIR_INST}/${FILE}" 2>&1 | tee -a "$LOG_ERRS"
		done
		rm -f ${DIR_TEMP}/installs.list 2>>"$LOG_ERRS"
	fi
	# NOTE: these are two separate 'if' statements on purpose!
	if [ -s ${DIR_TEMP}/services.list ]; then
		showMsg 'action' "Running deferred service scripts..." 'both' 1 4
		for FILE in $(cat ${DIR_TEMP}/services.list); do
			showMsg 'file' "  ${DIRECTORY}${DIR_INIT}/${FILE}:" 'both' 0 1
			[ ! "$DRYRUN" ] && "${DIRECTORY}${DIR_INIT}/${FILE}" start 2>&1 | tee -a "$LOG_ERRS"
		done
		rm -f ${DIR_TEMP}/services.list 2>>"$LOG_ERRS"
	fi
fi

exitGracefully 0 'both' 6 'success'


# LEFT OFF

#   Outstanding
#	dependency.i32.lib.soft[1.2.3-2.3.1]				package requires within this range of version numbers of this dependency
#	dependency.i32.lib.soft[>1.2.3] or [1.2.3+]			package requires a version greater than or equal to stated of this dependency
#	dependency.i32.lib.soft[<1.2.3] or [1.2.3-]			package requires a version less or equal to than stated of this dependency
#	dependency.i32.lib.soft[=1.2.3] or [1.2.3!]	(implemented)	package requires this exact version of this dependency and will fail if not currently installed; useful for upgrading web.de themes to make sure web.de itself is at a certain version for compatibility
#	dependency.i64.bin.soft|dependency2.i64.bin.soft|...		package requires any of these dependencies (e.g. thttpd,apache,paged,...)	NOTE: should be in order of preference by OEM; (e.g. TC - size to keep overall size of system down)
#	dependency.i64.bin.soft{file1,file2,file3,...}			package requires only certain files from the dependency

# ask where to install: system (/), everyone (/Users/Public/.{bin|sbin|lib|...}), personal (/Users/$USER/.{bin|sbin|lib|...})		NOTE: there are no sbin's any more; also /Users/Public is for system-wide usage WITHOUT having elevated installation credentials (compared to system installations to /)
# implement a personal list/repo where individual users can have their software loaded upon logging in (and unloaded upon logging out)

# file	description				these are files included in the root of the package			OR, just have the install script put a file somewhere indicating a device reboot (since that's the only meaningful follow-up; services already restart)
# -------------------				the files would be good to indicate beforehand packages that would require a reboot so the user can choose whether to install them or not
# .pre	checks that the account has permission to install the value
#	Example values: group	advanced	(to indicate the user needs to be a member of the 'advanced' group to install this package; can issue UI prompt for elevated account status)
#			location /
#
# .post	indicates any actions required post-install
#	Example values: device	reboot		(to indicate that a reboot is neccessary to complete install)
#			service	restart		(to indicate a service needs to restart)
#
# .reboot	indicates the package will require a reboot

