#!/bin/sh
# pax		a package management system that allows the (un)loading of
#		(pre-compiled) software packages for the (XiniX) OS
#
# created	2016/08/08 by Dave Henderson (support@cliquesoft.org)
# updated	2025/10/23 by Dave Henderson (support@cliquesoft.org)
#
# Unless a valid Cliquesoft Private License (CPLv1) has been purchased for your
# device, this software is licensed under the Cliquesoft Public License (CPLv2)
# as found on the Cliquesoft website at www.cliquesoft.org.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the appropriate Cliquesoft License for details.
#
# NOTES
# - The types of packages include:
#	app	application (installer)
# 	bin	binaries						these pertain to the OS
# 	dev	development
#	drv	drivers
# 	doc	documentation
#	gir	GObject
# 	lib	libraries
# 	loc	locales
#	msc	miscellaneous
#	src	source
#
# 	app	applets							these pertain to web.de
# 	icn	icons
# 	skn	skins
# 	thm	themes
#
# - The package extensions include:
#	code	package source code
#	cpio	ramdisk image
#	deps	dependencies list
#	hash	validation hash
#	info	package information
#	list	manifest list
#	make	compile script
#	mark	unload marker
#	newr	update available
#	repo	available in repo
#	soft	software files
#
# - The .deps files can use the following syntax:
#	dependency.i64.bin.soft						package requires this dependency (any version)
#	dependency.i32.lib.soft[1.2.3]					package requires the stated version of this dependency and will install it beside any other version; useful for software requiring different lib versions (e.g. sdl)
#	[dependency.r64.drv.soft|optional.i64.bin.soft]			package can optionally install this dependency if the device also has 'optional' installed
#
#   Outstanding (LEFT OFF)
#	dependency.i32.lib.soft[1.2.3-2.3.1]				package requires within this range of version numbers of this dependency
#	dependency.i32.lib.soft[>1.2.3] or [1.2.3+]			package requires a version greater than or equal to stated of this dependency
#	dependency.i32.lib.soft[<1.2.3] or [1.2.3-]			package requires a version less or equal to than stated of this dependency
#	dependency.i32.lib.soft[=1.2.3] or [1.2.3!]	(implemented)	package requires this exact version of this dependency and will fail if not currently installed; useful for upgrading web.de themes to make sure web.de itself is at a certain version for compatibility
#	dependency.i64.bin.soft|dependency2.i64.bin.soft|...		package requires any of these dependencies (e.g. thttpd,apache,paged,...)	NOTE: should be in order of preference by OEM; (e.g. TC - size to keep overall size of system down)
#	dependency.i64.bin.soft{file1,file2,file3,...}			package requires only certain files from the dependency




# REMOVED 2025/10/21 - the only function that was called was getBootcode(), which was added to this script to remove the dependency
## CHECK FOR DEPENDENCIES (no log writting here since no directory checks have been made)
#
#. /etc/software/SYSTEM/FUNCTIONS					# NOTE: this also obtains the variables set in /etc/{envars|enviro}
#
## WARNING: this MUST come after the sourced files above so shared variable values don't leak!!!
## NOTE: the RESTORE variable can contain two different values based if it is used as an ACTION or OPTION
#unset ALL BOOTING COPY DOWNLOAD EXTRA FORCE IGNORE INSTALL NOLIST MAKE MODE ONLY PREFIX PROXY PURGE QUIET RESTORE SILENT TREE UNLOAD VALIDATE VERSION


# MODULE VARIABLE DEFINITIONS

DEBUG=0												# NOTE: making this a '2' will enable prompts

DIR_CONF='/etc/pax'										# directory containing any alternate/personalized configuration

DIR_CLOG='/var/cache/Software/catalog'								# directory containing the total list of installed applications
DIR_INIT='/var/cache/Software/services'								# directory containing daemon/service scripts
DIR_INST='/var/cache/Software/scripts'								# directory containing other software scripts (taken from /etc/envars)
DIR_LOGS='/var/log'
DIR_LOOP='/tmp/pax/loop'									# directory that symlinked software needs to use as mountpoint
DIR_TEMP='/tmp/pax'

PAK_FILE='${RAWFILE}.${TYPE}.${CPU}'								# the format for the package filenames	NOTE: encase in single quotes so variables are NOT expanded yet
PAK_NAME=''											# the actual name of the package (e.g. nano, not nano.bin.i32); this is set automatically below based on passed script parameters

EXT_CODE='code'											# [tgz file] package source code
EXT_DEPS='deps'											# [text file] package dependency list
EXT_HASH='hash'											# [text file] package validation hash
EXT_INFO='info'											# [text file] package information
EXT_LIST='list'											# [text file] package manifest list
EXT_MAKE='make'											# [text file] package make commands
EXT_SOFT='soft'											# [mksquashfs file] packaged compiled software

LOG_DBUG="${DIR_LOGS}/pax.debug"								# the log file for debug output
LOG_ERRS="${DIR_LOGS}/pax.log"									# the log file for error output

REPO_PREFIX='/etc/software/SYSTEM/repo'
REPO_OPTION="${REPO_PREFIX}/optional"								# WARNING: this needs to reference 'optional' and REPO_SYSTEM needs to reference 'system'!!!
REPO_SYSTEM="${REPO_PREFIX}/system"								# if any dependency package(s) are not found in the (modified) REPO_OPTION, then check the 'base' location
REPO_RESTOR="/var/cache/Software/restore"
REPO_REMOTE='http://repo.cliquesoft.org/vanilla/1.0'						# the source to obtain remote packages from when installing/downloading -AND- the target directory when copying
REPO_SOURCE=''											# if the user passed a new source via -S
REPO_TARGET=''											# if the user passed a new target directory as the last passed parameter

# -------------------- DO **NOT** EDIT BELOW THIS LINE --------------------

# MOVED 2025/10/21 - the values can no longer be established here since they rely on functions that haven't been defined yet
#LIST="$( ( checkBootcode list2 && [ -e "${REPO_PREFIX}/$(getBootcode list2)" ] ) && getBootcode list2 || echo 'optional.list')"		# obtains and tests for the existence of the bootloader 'lst' bootcode value -OR- uses a default otherwise
#FLAG="${LIST%.*}.flag"										# the flag file that blacklists included packages
#MODE="$(TEMP="$(getBootcode mode)"; ( [ "$TEMP" = 'conservative' ] || readlink $REPO_PREFIX | grep -q DATA ) && echo 'link' && exit 0; echo 'copy')"	# the install mode: (sym)link, copy	NOTE: symlink by default if we are in a 'conservative' operation mode -OR- we are using DATA as the source of the repo
LIST=''												# stores a specified secondary boot list
FLAG=''												# store an accompanying blacklist flag file for packages that should NOT be installed from the secondary boot list (or their dependencies)
MODE=''												# the install mode: copy, (sym)link	NOTE: symlink by default if we are in a 'conservative' operation mode -OR- we are using DATA as the source of the repo

# UPDATED 2025/10/22 - merged -P with -U
#PURGE=0												# indicate no purging is happening by default
PURGE=''											# indicate no purging is happening by default	NOTE: keep this blank as default (indicated we are just unloading and not uninstalling)
INDEX=0												# since no arrays can be used in this shell, this keeps track of the index within the dependency stack	NOTE: 0=no deps
TOTAL=0												# keeps track of the $DEP 'array' size
EXEID="${DIR_TEMP}/$(mktemp -u XXXXXX)"								# stores a temp execution ID (for use with (un)installing)

CPU="$(uname -m 2>>"$LOG_ERRS" | sed -r 's/i386|i686/i32/;s/x86_64/i64/;s/armv7l/r32/')"	# this can be used so the .deps files can be universal (like KERNEL below) - bash.CPU.bin.soft
TYPE='bin'											# the package type: bin dev doc drv gir lib loc	  NOTE: we're specifying the default value here
TEMP=''												# used to store information temporarily
KERNEL="$(uname -r 2>>"$LOG_ERRS" | sed 's/-/_/g')"						# store the currently used kernel version (substituting '-' for '_')
#LATEST=							< LEFT OFF - this can be used so the latest version of a branch can be downloaded (e.g. pax -i apache -V 2.2.LATEST)

DEPENDENCY=''
LIBRARIES=''
MODULES=''
VERSION=''
VERFILE=''
RAWFILE=''
OPTFILE=''
DEPFILE=''
APPFILE=''											# e.g. 'bash.i32.bin.soft'
APPHEAD=''											# e.g. 'bash.i32.bin'	(header)
APPNAME=''											# e.g. 'bash'
APPARCH=''											# e.g. 'i32'
APPTYPE=''											# e.g. 'bin'
APPEXTN=''




# -------------------------------------------------------------------------




# DEFINE BUILT-IN FUNCTIONS FOR EXPORT




# DEFINE BUILT-IN FUNCTIONS FOR INTERNAL USE

# Usage syntax: exitGracefully [EXIT]
# Overview:	allows the script the terminate gracefully
# Parameters:
# EXIT		[number] [optional] the exit status of this script afterwards: 0 (default), 1
exitGracefully() {
	find "$DIR_TEMP" -size 0 -print0 | xargs -0 rm 2>/dev/null				# remove any blank cache file	https://stackoverflow.com/questions/3157343/how-to-delete-many-0-byte-files-in-linux
	rm -f "${DIR_CLOG}/"*.mark 2>/dev/null							# remove any .marker files
	( [ ! "$1" ] || [ $1 -eq 0 ] ) && exit 0
	( [ "$SILENT" ] || [ "$QUIET" ] ) || echo " [failure]"
	exit 1
}


# Usage syntax: checkBootcode CODE
# Overview:	checks if a passed boot code was specified
# Parameters:
# CODE		[string] the name of the boot code to check for
checkBootcode() {
	case "$(cat /proc/cmdline)" in
		*" $1"*) return 0 ;;
	esac
	return 1
}


# Usage syntax: getBootcode CODE
# Overview:	stores the value of a passed boot code in $VALUE, or blank otherwise
# Parameters:
# CODE		[string] the name of the boot code to return its value
getBootcode() {
	local CMDLINE="$(cat /proc/cmdline)"
	local VALUE="${CMDLINE##* $1=}"			# remove everything before the bootcode declaration (e.g. 'quiet waitusb=5 tce=...' > '5 tce=...')
	VALUE="${VALUE%%[   ]*}"			# remove everything afterwards to isolate just the bootcode value (e.g. '5 tce=...' > '5')
	echo "$VALUE"
	return 0
}


# Usage syntax: splitName NAME
# Overview:	seperates the passed name into its various parts
# Parameters:
# NAME		[string] the name of the software to split (e.g. bash.i64.dev.soft)
splitName() {
	RAWFILE="${1##*/}"									# remove any directory structure and store the raw value

	if ( echo "$RAWFILE" | grep -q ^'\[' ); then						# if an optional package (e.g. [xorg_3d.i32.bin.soft|xorg.bin]) was passed, then...
		APPFILE="$(echo "$RAWFILE" | sed 's/^\[//;s/\]$//;s/|.*//')"			#   store just the name (xorg_3d.i32.bin.soft)
		OPTFILE="$(echo "$RAWFILE" | sed 's/^\[//;s/\]$//;s/.*|//')"			#   store just the optional package (xorg.bin)
		VERSION=''									#   erase any existing value from this variable to prevent bugs
	elif ( echo "$RAWFILE" | grep -q '\]'$ ); then						# if a version number has been included (e.g. bash.bin[4.0.2]) in the name, then...
		APPFILE="${1%%[*}"								#   store just the name (bash.bin)
		OPTFILE=''									#   erase any existing value from this variable to prevent bugs
		VERSION="$(echo "$1" | sed 's/.*\[//;s/\]$//')"					#   store just the included version number (4.0.2)
	else
		APPFILE="$1"									#   store just the name (bash.bin)
		OPTFILE=''									#   erase any existing values from these variables to prevent bugs
		VERSION=''
	fi

	TEMP="${PAK_FILE#*\}}"									# isolate just the package name portion from the filename 'schema' - everything after the first '}' character
	eval TEMP="${TEMP}.${EXT_SOFT}"								# combine the 'schema' (less the package name) values and the file extension value (e.g. i32.bin.soft)
	PAK_NAME="$(echo $RAWFILE | sed "s/$TEMP//")"						# remove that combination from the passed package name (in case it was passed like bash.i32.bin.soft) to isolate just the package name (e.g. bash)
	eval PAK_FILE=${PAK_FILE}								# store the filename (less the extension) as the defined 'schema' (e.g. bash.i32.bin)
return 1
# REMOVED 2025/10/21 - to now be more versatile with package names
	[ "${APPFILE##*.}" != 'soft' ] && APPFILE="${APPFILE}.${CPU}.bin.soft"			# if the user only entered the name (e.g. pax -d bash), then we need to apply best-guesses to the other parts of the filename
	APPFILE="${APPFILE/CPU/${CPU}}"								# perform the CPU keyword substitution 			WARNING: these must be processed in the order shown
	APPFILE="${APPFILE/KERNEL/${KERNEL}}"							# perform the KERNEL keyword substitution
	APPHEAD="${APPFILE%.*}"									# e.g. 'bash.i32.bin'		header
	APPNAME="$(echo "$APPFILE" | head -c -14)"						# e.g. 'bash'			package name
	APPARCH="$(echo "$APPFILE" | tail -c 13 | head -c 3)"					# e.g. 'i32'			package CPU architecture
	APPTYPE="${APPHEAD##*.}"								# e.g. 'bin'			package type
	APPEXTN="${APPFILE##*.}"								# e.g. 'soft'			package extension
	[ "$VERSION" ] && VERFILE="${VERSION}.${APPARCH}.${APPTYPE}.${APPEXTN}" || VERFILE=''	# WARNING: this MUST come after the above assignments so the proper values are created
}


# Usage syntax: proxyAction
# Overview:	proxy's the action by creating a temporary shell script to execute on another device
# Notes:	https://unix.stackexchange.com/questions/22623/extract-middle-section-of-lines-of-a-text-file
#		https://unix.stackexchange.com/questions/2072/whats-the-best-way-to-take-a-segment-out-of-a-text-file
proxyAction() {
	( [ -e "${DIR_TEMP}/proxy.sh" ] || [ -e "${PROXY}/proxy.sh" ] ) && return 0		# if the script is already generated, we can skip re-creating it again

	echo '#!/bin/sh' > "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo '# Variable Declarations' >> "${DIR_TEMP}/proxy.sh"
	echo -e "COPY=${COPY}\nDOWNLOAD=${DOWNLOAD}${INSTALL}\nDEBUG=0\nEXTRA=${EXTRA}\nINDEX=0\nTOTAL=0\n" >> "${DIR_TEMP}/proxy.sh"
	echo -e "LOG_ERRS=\"\$(pwd)/proxy.log\"\nFLAG='proxy.flag'\nTEMP=''\n" >> "${DIR_TEMP}/proxy.sh"
	echo -e "REPO_PREFIX=\"\$(pwd)\"\nREPO_OPTION=\"\${REPO_PREFIX}/Software\"\nREPO_SYSTEM=\"\${REPO_PREFIX}/Software\"\nREPO_REMOTE='${REPO_REMOTE}'\nREPO_SOURCE='${REPO_SOURCE}'\nREPO_TARGET='${REPO_TARGET}'\n" >> "${DIR_TEMP}/proxy.sh"
	echo -e "CPU='${CPU}'\nKERNEL='${KERNEL}'\n" >> "${DIR_TEMP}/proxy.sh"
	echo -e "DEPENDENCY=''\nVERSION=''\nVERFILE=''\nRAWFILE=''\nOPTFILE=''\nDEPFILE=''\nAPPFILE=''\nAPPHEAD=''\nAPPNAME=''\nAPPARCH=''\nAPPTYPE=''\nAPPEXTN=''" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo '# Function Declarations' >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^exitGracefully()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"		# https://stackoverflow.com/questions/6916856/can-bash-show-a-functions-definition
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^splitName()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^addDependency()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^deleteDependency()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^processDependencies()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^copyPackage()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^downloadPackage()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo '# Directory Checks' >> "${DIR_TEMP}/proxy.sh"
	echo "if [ ! -d \"\$REPO_OPTION\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "	mkdir -p \"\$REPO_OPTION\" >>\"\$LOG_ERRS\" 2>&1 || { echo \"ERROR: The storage directory (REPO_OPTION) does not exist and could not be created.\" | tee -a \$LOG_ERRS; exit 1; }" >> "${DIR_TEMP}/proxy.sh"
	echo "fi" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo '# Start Execution' >> "${DIR_TEMP}/proxy.sh"
	echo "for RAWFILE in \$(cat proxy.list); do" >> "${DIR_TEMP}/proxy.sh"
	echo "	processDependencies \"\${RAWFILE}\"" >> "${DIR_TEMP}/proxy.sh"
	echo "	[ ! \"\$DEPENDENCY\" ] && continue" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo "	while [ \"\$DEPENDENCY\" ] && [ \$INDEX -gt 0 ]; do" >> "${DIR_TEMP}/proxy.sh"
	echo "		splitName \"\$DEPENDENCY\"" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo "		if [ ! \"\$REPO_SOURCE\" ] && [ -e \"./\${APPFILE}\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "			SOURCE='local'" >> "${DIR_TEMP}/proxy.sh"
	echo "		elif [ \"\$REPO_SOURCE\" ] && ( echo \"\$REPO_SOURCE\"|grep -q ^'http' || echo \"\$REPO_SOURCE\"|grep -q ^'ftp' ); then" >> "${DIR_TEMP}/proxy.sh"
	echo "			cd \"\$REPO_OPTION\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			DOWNLOAD=TRUE" >> "${DIR_TEMP}/proxy.sh"
	echo "		elif [ \"\$REPO_SOURCE\" ] && ( echo \"\$REPO_SOURCE\"|grep -q ^'/' || echo \"\$REPO_SOURCE\"|grep -q ^'./' ) && ( [ -e \"\${REPO_SOURCE}/\${APPFILE}\" ] || [ -f \"\${REPO_SOURCE}/\${VERFILE}\" ] ); then" >> "${DIR_TEMP}/proxy.sh"
	echo "			cd \"\$REPO_SOURCE\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			unset DOWNLOAD" >> "${DIR_TEMP}/proxy.sh"
	echo "		elif [ -e \"\${REPO_SYSTEM}/\${APPFILE}\" ] || [ -f \"\${REPO_SYSTEM}/\${VERFILE}\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "			cd \"\$REPO_SYSTEM\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			unset DOWNLOAD" >> "${DIR_TEMP}/proxy.sh"
	echo "		else" >> "${DIR_TEMP}/proxy.sh"
	echo "			cd \"\$REPO_OPTION\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			( [ -e \"\${REPO_OPTION}/\${APPFILE}\" ] || [ -f \"\${REPO_OPTION}/\${VERFILE}\" ] ) && unset DOWNLOAD || DOWNLOAD=TRUE" >> "${DIR_TEMP}/proxy.sh"
	echo "		fi" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo "		if [ \"\$DOWNLOAD\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "			( [ \"\$SILENT\" ] || [ \"\$QUIET\" ] ) || echo -n \"\${APPFILE}: [remote] [download]\"" >> "${DIR_TEMP}/proxy.sh"
	echo "			[ \"\$REPO_TARGET\" ] && cd \"\$REPO_TARGET\" >>\$LOG_ERRS 2>&1 || cd \"\$REPO_OPTION\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			downloadPackage || exitGracefully 1" >> "${DIR_TEMP}/proxy.sh"
	echo "		elif [ \"\$COPY\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "			( [ \"\$SILENT\" ] || [ \"\$QUIET\" ] ) || echo -n \"\${APPFILE}: [local] [copy]\"" >> "${DIR_TEMP}/proxy.sh"
	echo "			copyPackage || exitGracefully 1" >> "${DIR_TEMP}/proxy.sh"
	echo "		fi" >> "${DIR_TEMP}/proxy.sh"
	echo "		( [ \"\$SILENT\" ] || [ \"\$QUIET\" ] ) || echo \" [done]\"" >> "${DIR_TEMP}/proxy.sh"
	echo "		deleteDependency TRUE" >> "${DIR_TEMP}/proxy.sh"
	echo "	done">> "${DIR_TEMP}/proxy.sh"
	echo "done">> "${DIR_TEMP}/proxy.sh"

	chmod 755 "${DIR_TEMP}/proxy.sh"
}


# Usage syntax: addDependency FILENAME
# Overview:	adds the passed package name onto the top of the stack of dependencies
# Parameters:
# FILENAME	[string] the package name that needs to be added to the stack
addDependency() {
	INDEX=$(( INDEX + 1 ))
	TOTAL=$(( TOTAL + 1 ))
	eval "DEP${INDEX}=$1"									# NOTE: since busybox shell (ash) can't handle arrays (ugh!), we have to use this work around...
	eval "DEPENDENCY=\$DEP${INDEX}"

	[ $DEBUG -gt 0 ] && echo -e "addDependency:\n\tINDEX      :${INDEX}:\n\tDEPENDENCY :${DEPENDENCY}:" >> "$LOG_DBUG"
}


# Usage syntax: deleteDependency [DECREASE]
# Overview:	deletes the top-most (last added) package from the stack of dependencies
# Parameters:
# DECREASE	[boolean] if the INDEX variable needs to be decreased by 1
deleteDependency() {
	[ $DEBUG -gt 0 ] && echo -e "deleteDependency (old):\n\tINDEX      :${INDEX}:\n\tDEPENDENCY :${DEPENDENCY}:" >> "$LOG_DBUG"

	eval "unset DEP${INDEX}"
	[ "$1" ] && INDEX=$(( INDEX - 1 ))							# if we need to decrease the INDEX value, then do so!
	[ "$INDEX" -eq 0 ] && { unset DEPENDENCY; return 0; }					# if there isn't anything in the stack, delete the variable and exit
	[ "$1" ] && eval "DEPENDENCY=\$DEP${INDEX}"

	[ $DEBUG -gt 0 ] && echo -e "deleteDependency (new):\n\tINDEX      :${INDEX}:\n\tDEPENDENCY :${DEPENDENCY}:" >> "$LOG_DBUG"
}


# Usage syntax: processDependencies APPFILE [INDENT]
# Overview:	adds all the dependencies for the passed package onto the stack of dependencies to be installed
# Notes:	pwd is mostly irrelevent to this function as it will dynamically change internally
# Parameters:
# APPFILE	[string] the package name that is being installed
# INDENT	[string] [optional] passed tabs (e.g. '\t\t') to indent the output (for the -t switch)
processDependencies() {
	local SOURCE=''
	local TARGET=''
	local RELEASE										# used to indicate that the iterated dependency is released to be unloaded
	local DIR
	local DEPFILE
	local DEPNAME
	local DEPTYPE
	local INDENT="$2"

	splitName "$1"

	[ "$REPO_TARGET" ] && TARGET="$REPO_TARGET" || TARGET="$REPO_OPTION"			# if a different target was specified, then store that as the target, otherwise use the default value
	DIR="${APPNAME/_${KERNEL}}"								# set the default value while removing any KERNEL value from the (directory) name
	[ "$APPTYPE" = 'app' ] && DIR="web.de/_apps/${APPNAME}"				# if we're dealing with a web.de applet, set DIR to the package name for proper repo URI navigation
	[ "$APPTYPE" = 'icn' ] && DIR="web.de/_icons/${APPNAME}"				# or an icon set
	[ "$APPTYPE" = 'skn' ] && DIR="web.de/_skins/${APPNAME}"				# or a skin
	[ "$APPTYPE" = 'thm' ] && DIR="web.de/_themes/${APPNAME}"				# or a theme

	# get us into the correct directory to process the request
	if [ ! "$REPO_SOURCE" ] && [ -e "./${APPFILE}" ]; then								# if no source was provided via '-S' and the pwd has the file (e.g. from a restore point), then...
		SOURCE='local '
	elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'http' || echo "$REPO_SOURCE"|grep -q ^'ftp' ); then	# if a different SOURCE was provided -AND- it is remote, then...
		cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1									# NOTE: we cd into this directory just as a precaution
		SOURCE='remote'
	elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'/' || echo "$REPO_SOURCE"|grep -q ^'./' ) && [ -e "${REPO_SOURCE}/${APPFILE}" ]; then	# if a different SOURCE was provided -AND- it is a directory -AND- the iterated package exists in the REPO directory, then...
		cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1
		SOURCE='local '
	elif [ -e "${REPO_SYSTEM}/${APPFILE}" ]; then									# otherwise check that the file exists in the REPO_SYSTEM...
		cd "$REPO_SYSTEM" >>"$LOG_ERRS" 2>&1
		SOURCE='local '
	else														# and lastly change to the default REPO_OPTION as a last resort to find/store the software
		cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1
		[ -e "${REPO_OPTION}/${APPFILE}" ] && SOURCE='local ' || SOURCE='remote'
	fi

	[ $DEBUG -gt 0 ] && { echo -en "processDependencies:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:\n\tOPTFILE :${OPTFILE}:\n\tSOURCE  :${SOURCE}:\n\tTARGET  :${TARGET}:\n\tpwd     " >> "$LOG_DBUG"; pwd >> "$LOG_DBUG" 2>>"$LOG_ERRS"; }

	# perform a few basic checks...
# UNTESTED
	if [ ! "$REPO_TARGET" ] && ( grep -qw "$RAWFILE" "${REPO_PREFIX}/${FLAG}" 2>/dev/null ); then			# if we're using an 'internal repo' (optional or system) -AND- the package IS listed as being flagged to not load, then...
		[ $DEBUG -gt 0 ] && echo -e "\tPackage flagged from loading..." >> "$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[ FLAG ] ${APPNAME}.${APPTYPE}"
		return 1
	fi

	[ "$OPTFILE" ] && [ ! "$ALL" ] && [ ! -e "${DIR_CLOG}/${OPTFILE}" ] && {					# if we've encountered a conditional package -AND- we are not using the -A option -AND- it's dependency is not installed, then we can safely skip it!
		[ $DEBUG -gt 0 ] && echo -e "\tPackage conditional absent..." >> "$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[absent] ${APPNAME}.${APPTYPE}"
		return 0
	}
	[ "$COPY" ] && [ ! "$FORCE" ] && [ -e "${TARGET}/${APPFILE}" ] && {
		[ $DEBUG -gt 0 ] && echo -e "\tPackage already exists..." >> "$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[exists] ${APPNAME}"
		return 0
	}
	[ "$DOWNLOAD" ] && [ ! "$FORCE" ] && [ -e "${APPFILE}" ] && {
		[ $DEBUG -gt 0 ] && echo -e "\tPackage already downloaded..." >> "$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[exists] ${APPNAME}.${APPTYPE}"
		return 0
	}
# UNTESTED
	[ "$INSTALL" ] && [ ! "$FORCE" ] && [ ! "$RESTORE" ] && [ -e "${DIR_CLOG}/${APPFILE}" ] && {			# if we're installing -AND- not updating (by forcing or creating a restore point) -AND- the software is already installed, then...
		[ $DEBUG -gt 0 ] && echo -e "\tPackage already installed..." >> "$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[exists] ${APPNAME}.${APPTYPE}"
		return 0
	}
	[ "$RESTORE" ] && [ ! "$FORCE" ] && [ -e "${DIR_CLOG}/${APPFILE}" ] && {					# if the iterated dependency is already installed, then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tPackage currently installed..." >> "$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[exists] ${APPNAME}.${APPTYPE}"
		return 0
	}
	[ "$RESTORE" ] && [ ! -e "${APPFILE}" ] && {									# if the dependency is not in the restore point directory (pwd), then it must be already in 'optional' as a dep for another software
		[ $DEBUG -gt 0 ] && echo -e "\tPackage is not in restore point..." >> "$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[absent] ${APPNAME}.${APPTYPE}"
		return 0
	}
# UPDATED 2025/10/22 - merged -P with -U
#	[ "$UNLOAD" ] && [ ! -e "${DIR_CLOG}/${APPFILE}" ] && [ "$PURGE" -eq '0' ] && {					# if the iterated dependency is already unloaded -AND- we aren't uninstalling it, then go to the next one!
	[ "$UNLOAD" ] && [ ! -e "${DIR_CLOG}/${APPFILE}" ] && [ "$PURGE" = '' ] && {					# if the iterated dependency is already unloaded -AND- we aren't uninstalling it, then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tPackage already unloaded..." >> "$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[absent] ${APPNAME}.${APPTYPE}"
		return 0
	}
	[ "$UNLOAD" ] && [ "$SOURCE" = 'remote' ] && {									# if the iterated dependency is considered 'remote' (can't be found due to needing a proper -S value) -AND- we are unloading/uninstalling it, then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tPackage is being ignored (missing, maybe use -S)..." >> "$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[absent] ${APPNAME}.${APPTYPE}"
		return 0
	}
	[ "$UNLOAD" ] && ( echo ",$IGNORE" | grep -q ",$APPHEAD" ) && {							# if the iterated dependency is ignored -AND- we are unloading/uninstalling it, then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tPackage is being ignored..." >> "$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[ignore] ${APPNAME}.${APPTYPE}"
		return 0
	}
	[ "$UNLOAD" ] && ( [ -L "${DIR_CLOG}/${APPHEAD}.soft" ] || [ ! -s "${DIR_CLOG}/${APPHEAD}.soft" ] ) && {	# if the iterated dependency is on DATA (via symlink) or BOOT (via 0 byte file), then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tPackage is being ignored (BOOT)..." >> "$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[ BOOT ] ${APPNAME}.${APPTYPE}"
		return 0
	}
	if [ ! "$TREE" ] && [ ! "$VALIDATE" ]; then
		for DEPFILE in $(seq 1 $INDEX); do						# check if the dependencies has already been added to the list to be processed, so...
			eval TEMP="\$DEP$DEPFILE"						#   since busybox 'sh' does not support arrays, we have to use this method to check each stored dependency
			if [ "$TEMP" = "$RAWFILE" ]; then					#   if the iterated dependency is already in the list (including any specific version number), then...
				[ $DEBUG -gt 0 ] && echo -e "\tPackage already marked for processing..." >> "$LOG_DBUG"
				( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[marked] ${APPNAME}.${APPTYPE}"
				return 0
			fi
		done
	fi

	# --- IF WE HAVE MADE IT HERE, THEN DO SOME WORK ---

	if [ "$UNLOAD" ] && [ ! "$FORCE" ]; then						# if we're unloading the package, then...
		RELEASE=1									#   (re)set the value
		for DEPFILE in $(ls -1 "$DIR_CLOG" 2>/dev/null | grep 'soft'$); do		#   for each currently installed package we need to see if any depend on the package to be unloaded, so...
# UPDATED 2018/11/29
#			DEPNAME="$(echo "$DEPFILE" | head -c -5)"				#   since the files in DIR_INST are just NAME.TYPE, we need to split to form a whole filename
#			DEPTYPE="${DEPFILE##*.}"
			DEPNAME="$(echo "$DEPFILE" | head -c -14)"				#   since the files in DIR_CLOG are NAME.ARCH.TYPE.EXTN, we need to split to form a whole filename
			DEPTYPE="$(echo "$DEPFILE" | tail -c 9 | head -c 3)"

			[ -e "${DIR_CLOG}/${DEPNAME}.${CPU}.${DEPTYPE}.mark" ] && continue	# if the iterated dependency is already marked to be unloaded, then go to the next one
			[ -e "${REPO_OPTION}/${DEPNAME}.${CPU}.${DEPTYPE}.deps" ] || continue	# if no .deps file exists for the iterated installed package, then continue since it does not depend on the package we are trying to unload

			# if there is an EXEID -AND- the requested package is a dependency for the iterated installed software -AND- that iterated installed software is not in the EXEID file that can be uninstalled, then..
			[ "$EXEID" ] && ( grep -q ^"$RAWFILE" "${REPO_OPTION}/${DEPNAME}.${CPU}.${DEPTYPE}.deps" ) && ( ! grep -q ^"${DEPNAME}.${CPU}.${DEPTYPE}.soft" "$EXEID" >/dev/null 2>&1 ) && {
				[ $DEBUG -gt 0 ] && echo -e "\tOther software depends on this dependency..." >> "$LOG_DBUG"
				( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[depend] [${DEPNAME}.${DEPTYPE}] ${APPNAME}.${APPTYPE}"
				RELEASE=0							#   indicate that the dependency can not be removed
				break								#   now break from the 'for' loop to conserve resources
			}
		done
		[ "$RELEASE" = '0' ] && return 0						#   if the dependency has NOT been released to unload, then don't!
	fi
	[ "$ONLY" ] && {									# if we are only affecting the package and not any dependencies, then...
		addDependency "${RAWFILE}"							#   add the passed package to the stack to be processed outside of this function
		return 0									#   now exit this function!
	}

	# obtain or copy the software .deps file
	if [ ! "$UNLOAD" ] && [ ! "$TREE" ] && [ ! "$VALIDATE" ] && [ "$SOURCE" = 'remote' ]; then		# if copying, downloading, or installing from an external source, then...	NOTE: this can NOT be '[ "$DOWNLOAD" ]' since more than one ACTION can utilize remote sources
		cd "$TARGET" >>"$LOG_ERRS" 2>&1							# change into the desired TARGET directory before executing the download
		[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.deps\"" >> "$LOG_DBUG"
		wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.deps" >>"$LOG_ERRS" 2>&1				#   get any .deps file for the dependency itself
	elif [ "$COPY" ] && [ -e "./${APPHEAD}.deps" ]; then					# NOTE: only the COPY will apply to this section
		[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.deps\" \"${TARGET}\"" >> "$LOG_DBUG"
		[ -e "./${APPHEAD}.deps" ] && cp -f "./${APPHEAD}.deps" "${TARGET}" >>"$LOG_ERRS" 2>&1
	fi

	# add the passed dependency to the stack
	if [ "$TREE" ]; then
		echo "${INDENT}${APPNAME}.${APPTYPE}"
	elif [ "$VALIDATE" ]; then
		[ "$SOURCE" = 'remote' ] && echo "[ missing ] ${APPNAME}.${APPTYPE}"
		[ -e "${DIR_CLOG}/${APPFILE}" ] && echo "[installed] ${APPNAME}.${APPTYPE}"
	elif [ "$UNLOAD" ]; then
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[marked] ${APPNAME}.${APPTYPE}"
	else
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[${SOURCE}] ${APPNAME}.${APPTYPE}"
	fi
	addDependency "${RAWFILE}"								# at least add the passed package to the stack to be processed outside of this function
	[ ! -f "${APPHEAD}.deps" ] && return 0							# if no dependency file exists for the passed package, then no need to process anything else in this function!	NOTE: we must put this here instead of the top since we need to (at least) process the first passed package!
	[ "$UNLOAD" ] && touch "${DIR_CLOG}/${APPHEAD}.mark"

	# process all the dependencies of the passed software
	for DEPFILE in $(cat "${APPHEAD}.deps" 2>/dev/null); do					# if the passed dependency also has dependencies, then...
		processDependencies "$DEPFILE" "$INDENT  " || return 1				# WARNING: this line needs to execute no matter the outcome of the 'wget' call above (so the addDependency() call can be made if needed) -AND- it needs to be the unaltered DEPFILE variable with any contained version number!!!
	done
	return 0
}


# Usage syntax: copyPackage
# Overview:	copies the .soft and .hash files from a local directory to another local directory
# Notes:	the directory containing the file(s)-to-copy should already be entered BEFORE calling this function!
#		no need to copy the .deps file since that was handled via processDependencies().
copyPackage() {
	local TARGET=''
	[ "$REPO_TARGET" ] && TARGET="$REPO_TARGET" || TARGET="$REPO_OPTION"			# if a different target was specified, then store that as the target, otherwise use the default value

	[ $DEBUG -gt 0 ] && { echo -en "copyPackage:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tTARGET  :${TARGET}:\n\tpwd     " >> "$LOG_DBUG"; pwd >> "$LOG_DBUG" 2>>"$LOG_ERRS"; }

	[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.soft\" \"$TARGET\"" >> "$LOG_DBUG"
	cp -f "./${APPHEAD}.soft" "$TARGET" >>"$LOG_ERRS" 2>&1 || {				# copy the .soft file from the source directory
		[ "$SILENT" ] || echo "ERROR: package copy failed (${APPHEAD}.soft)." >>"$LOG_ERRS"
		return 1
	}
	[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.hash\" \"$TARGET\"" >> "$LOG_DBUG"
	cp -f "./${APPHEAD}.hash" "$TARGET" >>"$LOG_ERRS" 2>&1 || {				# copy the corresponding hash file
		[ "$SILENT" ] || echo "ERROR: package hash copy failed (${APPHEAD}.hash)." >>"$LOG_ERRS"
		return 1
	}

	if [ "$EXTRA" ]; then
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'info' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.info\" \"$TARGET\"" >> "$LOG_DBUG"
			[ -e "./${APPHEAD}.info" ] && cp -f "./${APPHEAD}.info" "$TARGET" >>"$LOG_ERRS" 2>&1	# copy the corresponding info file
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'list' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.list\" \"$TARGET\"" >> "$LOG_DBUG"
			[ -e "./${APPHEAD}.list" ] && cp -f "./${APPHEAD}.list" "$TARGET" >>"$LOG_ERRS" 2>&1	# copy the corresponding list file
		fi
	fi

	return 0
}


# Usage syntax: downloadPackage
# Overview:	downloads the .soft and .hash files from the repo and compares the package checksum to validate the download
# Notes:	the directory to store the obtained file(s) should already be entered BEFORE calling this function!
#		no need to copy the .deps file since that was handled via processDependencies().
downloadPackage() {
	local DIR="${APPNAME/_${KERNEL}}"							# set the default value while removing any KERNEL value from the (directory) name
	[ "$APPTYPE" = 'app' ] && DIR="web.de/_apps/${APPNAME}"				# if we're dealing with a web.de applet, set DIR to the package name for proper repo URI navigation
	[ "$APPTYPE" = 'icn' ] && DIR="web.de/_icons/${APPNAME}"				# or an icon set
	[ "$APPTYPE" = 'skn' ] && DIR="web.de/_skins/${APPNAME}"				# or a skin
	[ "$APPTYPE" = 'thm' ] && DIR="web.de/_themes/${APPNAME}"				# or a theme

	[ $DEBUG -gt 0 ] && { echo -en "downloadPackage:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:\n\tDIR     :${DIR}:\n\tpwd     " >> "$LOG_DBUG"; pwd >> "$LOG_DBUG" 2>>"$LOG_ERRS"; }

	[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.soft\"" >> "$LOG_DBUG"
	wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.soft" >>"$LOG_ERRS" 2>&1			# download the .soft file from the repo
	( [ ! -e "${APPHEAD}.soft" ] || [ ! -s "${APPHEAD}.soft" ] ) && {			# if the file wasn't downloaded, or it's a zero byte file, then...	NOTE: this uses the 'pwd' as the download directory via 'wget'
		[ "$SILENT" ] || echo "ERROR: package download failed (${APPHEAD}.soft)." >>"$LOG_ERRS"
		return 1
	}
	# if we are NOT installing a specific version of the software, then...
	[ $DEBUG -gt 0 ] && [ ! "$VERSION" ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.hash\"" >> "$LOG_DBUG"
	[ ! "$VERSION" ] && wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.hash" >>"$LOG_ERRS" 2>&1		# download the corresponding hash file
	# otherwise we are, so...
	[ $DEBUG -gt 0 ] && [ "$VERSION" ] && echo -e "\tCalling: wget -cq -O - \"${REPO_REMOTE}/${DIR}/${APPHEAD}.hash\" | sed \"s/${VERSION}/${APPNAME}/\" >\"${APPHEAD}.hash\"" >> "$LOG_DBUG"
	[ "$VERSION" ] && wget -cq -O - "${REPO_REMOTE}/${DIR}/${APPHEAD}.hash" 2>>"$LOG_ERRS" | sed "s/${VERSION}/${APPNAME}/" >"${APPHEAD}.hash"		# download the corresponding hash file changing the name to match the version number
	( [ ! -e "${APPHEAD}.hash" ] || [ ! -s "${APPHEAD}.hash" ] ) && {			# if the file wasn't downloaded, or it's a zero byte file, then...
		[ "$SILENT" ] || echo "ERROR: package hash download failed (${APPHEAD}.hash)." >>"$LOG_ERRS"
		return 1
	}

	if [ "$EXTRA" ]; then
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'info' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.info\"" >> "$LOG_DBUG"
			wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.info" >>"$LOG_ERRS" 2>&1	# download the corresponding info file
			( [ ! -e "${APPHEAD}.info" ] || [ ! -s "${APPHEAD}.info" ] ) && {	# if the file wasn't downloaded, or it's a zero byte file, then...
				( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "WARNING: package info does not exist or download failed (${APPHEAD}.info)." >>"$LOG_ERRS"
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'list' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.list\"" >> "$LOG_DBUG"
			wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.list" >>"$LOG_ERRS" 2>&1	# download the corresponding list file
			( [ ! -e "${APPHEAD}.list" ] || [ ! -s "${APPHEAD}.list" ] ) && {	# if the file wasn't downloaded, or it's a zero byte file, then...
				( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "WARNING: package list does not exist or download failed (${APPHEAD}.list)." >>"$LOG_ERRS"
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
		fi
	fi

	return 0
}


# Usage syntax: installPackage
# Overview:	performs the actual work of installing the contents of the package to the system via copy or symlink
# Notes:	pwd is irrelevent to this function	< UPDATED - this is no longer true as of 2018/11/27
installPackage() {
	local SUCCESS=0										# indicates if the copy-to-RAM was successful (if that is desired)
	local MARKER=''										# used to convert the install marker (/usr/local/tce.installed) to the XiniX naming convention
	local SCRIPT=''										# used to convert the service script (/usr/local/etc/init.d) to the XiniX naming convention
	local SOURCE=''
	local TARGET=''
	local OUTPUT=0
	local PERM=0

	[ $DEBUG -gt 0 ] && { echo -en "installPackage:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:\n\tpwd     " >> "$LOG_DBUG"; pwd >> "$LOG_DBUG" 2>>"$LOG_ERRS"; }

	md5sum -c "${APPHEAD}.hash" >/dev/null 2>>"$LOG_ERRS" || {				# validate the package checksum before we install anything!!!
		[ "$SILENT" ] || echo "ERROR: package failed hash checksum (${APPFILE})!" >>"$LOG_ERRS"
		rm -f "${APPHEAD}".* >>"$LOG_ERRS" 2>&1						# remove the files if they fail (since something is wrong with the package)
		return 1
	}

# UNTESTED
# UPDATED 2025/10/08
#	if [ -e "${DIR_CLOG}/${APPFILE}" ] && [ "$RESTORE" ]; then				# if we are updating the installed package with a restore point, then...
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [restore] [creating]"
#		uninstallPackage || return 1
#	if
	if [ -e "${DIR_CLOG}/${APPFILE}" ]; then						# if we are updating the installed package, then...
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [unloading]"
		unloadPackage || return 1							#   unload the package first no matter what
		[ "$RESTORE" ] && {
			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [archiving]"
			uninstallPackage || return 1						#   if we're creating a restore point, then we need to get rid of the package too
		}
	fi

	# since we have to do this step no matter what, lets setup and mount the package now
	[ ! -d "${DIR_LOOP}/${APPNAME}.${APPTYPE}" ] && /bin/mkdir -p "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1	# make the mounting directory if it doesn't exist
	if ( ! /bin/mount 2>>"$LOG_ERRS" | grep -q "/${APPNAME}.${APPTYPE} type squashfs" ); then					# if the package is NOT already mounted and symlinked, then...
		sudo /bin/mount -t squashfs -o loop,ro,bs=4096 "$APPFILE" "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 || return 1
	fi
	find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -type d -name modules 2>>"$LOG_ERRS" | grep -q . && MODULES=TRUE			# if the package has a [/lib/]'modules' directory, then we need to indicate we need to load those modules later
	find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -type d -name lib 2>>"$LOG_ERRS" | grep -q . && LIBRARIES=TRUE			# if the package has a [/../]'lib' directory, then we need to indicate we need to load them later
# UPDATED 2018/07/14 - since TC packages do NOT adhere to this, we need a more robust solution
#	[ "$APPTYPE" = 'lib' ] && LIBRARIES=TRUE										# if the package has dynamic libraries, then indicate we need to add those to the cache file later

# TEMP CHANGE - this is for TC Compatibility - use config files to differenciate between distros
#MARKER="$(ls -1 "${DIR_LOOP}/${APPNAME}.${APPTYPE}/usr/local/tce.installed" 2>/dev/null)"
#SCRIPT="$(ls -1 "${DIR_LOOP}/${APPNAME}.${APPTYPE}/usr/local/etc/init.d" 2>/dev/null)"
	MARKER="$(ls -1 "${DIR_LOOP}/${APPNAME}.${APPTYPE}${DIR_INST}" 2>/dev/null)"						# NOTE: since XiniX uses different package names than TC, this renames the 'installed marker' to be appropriate; this can be removed once we start adjusting the contents of each package
	SCRIPT="$(ls -1 "${DIR_LOOP}/${APPNAME}.${APPTYPE}${DIR_INIT}" 2>/dev/null)"						# same, but with the service script

	# if we only need to copy specified files out of the package, then lets obtain that list
	if [ "$FILELIST" ]; then
		find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" ! -type d -name $(echo "$FILELIST" | sed 's/,/ -o -name /g') >"${DIR_TEMP}/filelist.txt" 2>>"$LOG_ERRS"
	fi

	# if '-M copy' was passed to this script -OR- the copy *everything* to RAM file exists -OR- the copy all system directories (REPO_OPTION and REPO_SYSTEM) contents to RAM file exists -and- we're using one of those directories, then...
	if [ "$MODE" = 'copy' ] || [ -e "${REPO_PREFIX}/copy_all.flag" ] || ( [ -e "${REPO_PREFIX}/copy_sys.flag" ] && [ ! "$REPO_TARGET" ] ); then
		[ $DEBUG -gt 0 ] && echo -e "\tInstall by copying..." >> "$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [copy]"
		[ "$VALIDATE" ] && { ( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [overwrite]"; }

		# NOTE: the below 'if' prevents the GNU tar from being a dependency during the boot process (but later for the 2nd stage loading)
		if [ ! "$BOOTING" ]; then							# if we are NOT booting, then GNU tar should be available so use it!
			( [ "$FORCE" ] || [ "$VALIDATE" ] ) && TEMP='-U --overwrite' || TEMP=''

			# NOTE: we use tar instead of cp to implement ownership in the copy process; the '-h' was removed on the extraction because it interferred with overwriting (even though -U was being issued too)
			if [ ! "$FILELIST" ]; then						# if we're copying all files out of the package, then...
				tar -C "${DIR_LOOP}/${APPNAME}.${APPTYPE}" --group=$GROUP . -cf - 2>>"$LOG_ERRS" | tar -C "${PREFIX}/" $TEMP -pxf - 2>>"$LOG_ERRS"
			else									# otherwise we only need to copy certain ones, so...
				tar -C "${DIR_LOOP}/${APPNAME}.${APPTYPE}" --group=$GROUP -T "${DIR_TEMP}/filelist.txt" -cf - 2>>"$LOG_ERRS" | tar -C "${PREFIX}/" $TEMP -pxf - 2>>"$LOG_ERRS"
			fi
		else										# otherwise we are booting and only have access to BB tar and can't execute the above lines, so use copy with the 'core' packages
			cp -dpR "${DIR_LOOP}/${APPNAME}.${APPTYPE}" "${PREFIX}/" 2>>"$LOG_ERRS"
		fi
		if [ $? -ne 0 ]; then
			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "WARNING: The (copy) install failed for ${APPFILE}!" >>"$LOG_ERRS"		# now we will fall back to the symlinking below this segment
			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [error] [attempting]"
		else
# REMOVED 2019/11/9 - we now have the compatibility package created
# LEFT OFF - TEMP CHANGE - this is for TC Compatibility and can remove this 'if' block once we create the tc_compatability package		maybe institute a -c(ompatibility) switch to 'pax' temporarily so it can work with TC packages
#if [ -d '/usr/local/tce.installed' ]; then						# LEFT OFF - do the same for SCRIPTS
#	mv /usr/local/tce.installed/* "$DIR_INST" 2>>"$LOG_ERRS"
#	rm -Rf /usr/local/tce.installed 2>>"$LOG_ERRS"
#	ln -s "$DIR_INST" /usr/local/tce.installed 2>>"$LOG_ERRS"
#fi
#if [ -d '/usr/local/etc/init.d' ]; then
#	mv /usr/local/etc/init.d/* "$DIR_INIT" 2>>"$LOG_ERRS"
#	rm -Rf /usr/local/etc/init.d 2>>"$LOG_ERRS"
#	ln -s "$DIR_INIT" /usr/local/etc/init.d 2>>"$LOG_ERRS"
#fi
			[ "$MARKER" = '' ] && MARKER="$APPNAME"								# if no default marker was included in the package, then default to its name
			[ $DEBUG -gt 0 ] && echo -e "\tMARKER :${MARKER}:\n\tSCRIPT :${SCRIPT}:" >> "$LOG_DBUG"

			# now update the naming conventions of the marker/script
			mv "${DIR_INST}/${MARKER}" "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>/dev/null
			[ "$SCRIPT" != '' ] && mv "${DIR_INIT}/${SCRIPT}" "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>/dev/null
			sudo /bin/umount -d "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 && rmdir "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1				# now that we have successfully copied the package contents to RAM, lets unmount and remove the mount point
			SUCCESS=1												# this indicates we do NOT need to symlink below (but we do need to do the other things down there...)
		fi
	fi

	# if we don't have SUCCESS at this point, then we need to symlink the package contents into the OS (either on purpose or as a fail-safe to the segment above)
	# WARNING: this MUST be two separate 'if' statements so if the one above fails, this one can still be entered!
	if [ $SUCCESS -eq 0 ]; then
		[ $DEBUG -gt 0 ] && echo -e '\tInstall using symlinks...' >> "$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [link]"

		( [ "$FORCE" ] || [ "$VALIDATE" ] ) && TEMP='f' || TEMP=''

		# WARNING: multiple problems occurred trying to use 'cp' (with these params: -aisL, -LRis, -HRis) but the task failed for one reason or another; the below was used instead
# UPDATED 2025/10/23 - this can now symlink specific files specified via -N
#		for SOURCE in $(find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -name '*'); do
		# if a filelist.txt file does NOT exist, then we need to symlink all files in the package, otherwise -N was passed so only certain ones need to be symlinked
		# NOTE: the sub-shell was constructed using to different conditions so the failure of a prior execution did not erroneously trigger an '||' execution
		for SOURCE in $([ ! -e "${DIR_TEMP}/filelist.txt" ] && find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -name '*'; [ -e "${DIR_TEMP}/filelist.txt" ] &&cat "${DIR_TEMP}/filelist.txt"); do
			TARGET="$(echo $SOURCE | sed "s:^${DIR_LOOP}/${APPNAME}.${APPTYPE}::")"		# (re)set the value
			[ ! "$TARGET" ] && continue
			if [ ! -d "$SOURCE" ]; then							# for each file...
				if [ ! "$VALIDATE" ]; then						#   if this is a typical package install, then...
					[ -e "$TARGET" ] && [ ! "$FORCE" ] && continue			#     if the file doesn't exist -AND- we aren't forcing the install, then go to the next file
				else									#   otherwise, we are validating so...
					[ -e "$TARGET" ] && [ "$(readlink $TARGET)" = "$SOURCE" ] && [ "$(stat -c %G $TARGET 2>/dev/null)" = "$GROUP" ] && [ "$(stat -c %a $TARGET 2>/dev/null)" = '777' ] && continue	# if it exists and points to the correct source file -AND- the ownership and permissions are correct, then go to the next one	WARNING: do NOT implement PREFIX here!!!
					( [ "$SILENT" ] || [ "$QUIET" ] ) || {				#   if we made it here then there was a problem, so...
						[ $OUTPUT -eq 0 ] && { echo " [detected]"; OUTPUT=1; }
						echo -e "   Misconfigured: $TARGET"
					}
				fi
				ln -s$TEMP "$SOURCE" "${PREFIX}${TARGET}" >>"$LOG_ERRS" 2>&1 || return 1	#   if the file does NOT exist, then symlink
				continue								#   skip further processing
			fi

			# if we've made it here, then we're dealing with a directory, so...
			if [ ! "$VALIDATE" ]; then
				[ -e "$TARGET" ] && continue						# if the directory already exists, skip further processing
			else
				[ -e "$TARGET" ] && [ "$(stat -c %G $TARGET 2>/dev/null)" = "$GROUP" ] && [ "$(stat -c %a $TARGET 2>/dev/null)" = "$(stat -c %a $SOURCE 2>/dev/null)" ] && continue
				( [ "$SILENT" ] || [ "$QUIET" ] ) || {
					[ $OUTPUT -eq 0 ] && { echo " [detected]"; OUTPUT=1; }
						echo -e "   Misconfigured: $TARGET"
				}
			fi
			PERM=$(stat -c %a "$SOURCE" 2>/dev/null || echo 755)				# get the permissions of the original directory from the squashfs file
			[ ! -e "${PREFIX}$TARGET" ] && { mkdir -p "${PREFIX}${TARGET}" >>"$LOG_ERRS" 2>&1 || return 1; }		# create the directory in the OS	NOTE: we had to add the '-e' check since VALIDATE can go here even if the directory exists (owner or perm can be wrong)
			chown -h :$GROUP "${PREFIX}${TARGET}" >>"$LOG_ERRS" 2>&1				# apply the appropriate group and permissions
			chmod $PERM "${PREFIX}${TARGET}" >>"$LOG_ERRS" 2>&1
		done

		[ "$MARKER" != '' ] && {											# if a marker is included in the package, then...
			rm "${DIR_INST}/${MARKER}" >>"$LOG_ERRS" 2>&1								#   remove the symlink created above
# TEMP CHANGE - this is for TC Compatibility - use config files to differenciate between distros
#ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}/usr/local/tce.installed/${MARKER}" "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1
			ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}/${DIR_INST}/${MARKER}" "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1	#   re-symlink using the XiniX naming convention
		}
		[ "$SCRIPT" != '' ] && {											# same with the service script
			rm "${DIR_INIT}/${SCRIPT}" >>"$LOG_ERRS" 2>&1
# TEMP CHANGE - this is for TC Compatibility - use config files to differenciate between distros
#ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}/usr/local/etc/init.d/${SCRIPT}" "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>&1
			ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}${DIR_INIT}/${SCRIPT}" "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>&1
		}
	fi

	# remove any -N filelist files
	[ -e "${DIR_TEMP}/filelist.txt" ] && rm -f "${DIR_TEMP}/filelist.txt" 2>>"$LOG_ERRS"

	# remove the 0-byte marker/scripts (since we now have the catalog directory)
	[ ! -s "${DIR_INIT}/${APPNAME}.${APPTYPE}" ] && rm "${DIR_INIT}/${APPNAME}.${APPTYPE}" 2>/dev/null
	[ ! -s "${DIR_INST}/${APPNAME}.${APPTYPE}" ] && rm "${DIR_INST}/${APPNAME}.${APPTYPE}" 2>/dev/null

	# now add to the 'catalog' of installed packages
	ln -sf "$(pwd)/${APPFILE}" "${DIR_CLOG}/${APPFILE}" 2>>"$LOG_ERRS"
	ln -sf "$(pwd)/${APPHEAD}.hash" "${DIR_CLOG}/${APPHEAD}.hash" 2>>"$LOG_ERRS"
	ln -sf "$(pwd)/${APPHEAD}.deps" "${DIR_CLOG}/${APPHEAD}.deps" 2>>"$LOG_ERRS"

	# update the appropriate list contents
	( ! grep -q "$APPFILE" "${DIR_TEMP}/"* 2>>"$LOG_ERRS" ) && echo "$APPFILE" >> "$EXEID"		# if the package isn't already part of an existing list, then add the package to the cache file for future uninstalling information
# UPDATED 2025/10/23 - the -L option is now a negation
#	[ ! "$VALIDATE" ] && [ "$INDEX" -eq 1 ] && [ "$NOLIST" ] && ( ! grep -q $RAWFILE "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS" ) && echo "$RAWFILE" >> "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS"	# if we are updating the system from (one of the) requested packages and not one of its dependencies (via INDEX==1) -AND- we're installing -AND- we're not only loading (no adjustment to LIST) -AND- the package isn't already in the LIST, then add the package to the LIST file
	[ ! "$VALIDATE" ] && [ "$INDEX" -eq 1 ] && [ ! "$NOLIST" ] && ( ! grep -q $RAWFILE "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS" ) && echo "$RAWFILE" >> "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS"	# if we are updating the system from (one of the) requested packages and not one of its dependencies (via INDEX==1) -AND- we're installing -AND- we're not only loading (no adjustment to LIST) -AND- the package isn't already in the LIST, then add the package to the LIST file

	# defer the execution of any related marker/service scripts from the package(s) until everything is installed - if we are not validating package data!
	[ ! "$VALIDATE" ] && [ -x "${DIR_INST}/${APPNAME}.${APPTYPE}" ] && ( ! grep -q "${DIR_INST}/${APPNAME}.${APPTYPE}" ${DIR_TEMP}/installs.list 2>/dev/null ) && echo "${DIR_INST}/${APPNAME}.${APPTYPE}" >> ${DIR_TEMP}/installs.list 2>>"$LOG_ERRS"		# if the package has an 'initialize' script post-install, then...
	[ ! "$VALIDATE" ] && [ -e "${DIR_INIT}/${APPNAME}" ] && ( ! grep -q "${DIR_INIT}/${APPNAME}" ${DIR_TEMP}/services.list 2>/dev/null ) && echo "${DIR_INIT}/${APPNAME}" >> ${DIR_TEMP}/services.list 2>>"$LOG_ERRS"		# if the package has a services start/stop script, then...
	return 0
}


# Usage syntax: unloadPackage
# Overview:	performs the actual work of unloading the contents of the package from the system no matter if they were copied or symlinked - with the option of a complete uninstallation
# Notes:	pwd is irrelevent to this function
#		if [ "$RAWFILE" != "$APPFILE" ] then a specific version was passed
#		http://forum.tinycorelinux.net/index.php/topic,5012.msg26650.html#msg26650
unloadPackage() {
	local PARAMS=''
	local FILE=''

	[ $DEBUG -gt 0 ] && echo -e "unloadPackage:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:" >> "$LOG_DBUG"

# UPDATED 2025/10/22 - merged -P with -U
#	[ $PURGE -gt 0 ] && [ ! -e "${DIR_CLOG}/${APPFILE}" ] && {				# if the package has been marked for uninstallation -AND- it currently is NOT installed, then...
	[ "$PURGE" != '' ] && [ ! -e "${DIR_CLOG}/${APPFILE}" ] && {				# if the package has been marked for uninstallation -AND- it currently is NOT installed, then...
		uninstallPackage || return 1							#   uninstall the package files
		return 0									#   no need to process anything further!
	}
# UPDATED 2025/10/22 - merged -P with -U
#	[ $PURGE -eq 1 ] && PARAMS='! -path "*/etc/*"'						# if we have been instructed to NOT delete any 'etc' files, then add these parameters to the 'find' calls below   http://www.cyberciti.biz/faq/find-command-exclude-ignore-files/
# UPDATED 2025/10/2 - merged with -u
#	[ "$PURGE" = 'app' ] && PARAMS='! -path "*/etc/*"'					# if we have been instructed to NOT delete any 'etc' files, then add these parameters to the 'find' calls below   http://www.cyberciti.biz/faq/find-command-exclude-ignore-files/
	[ "$PURGE" = 'remove' ] && PARAMS='! -path "*/etc/*"'					# if we have been instructed to NOT delete any 'etc' files, then add these parameters to the 'find' calls below   http://www.cyberciti.biz/faq/find-command-exclude-ignore-files/

	if [ -e "${DIR_INIT}/${APPNAME}" ]; then						# if the package has a service start/stop script, then indicate we need to execute it before continuing
		[ $DEBUG -gt 0 ] && echo -e "\tPackage has service script...\n\tCalling: \"${DIR_INIT}/${APPNAME}\" stop" >> "$LOG_DBUG"
		"${DIR_INIT}/${APPNAME}" stop >>"$LOG_ERRS" 2>&1 || return 1
	fi

	if ( /bin/mount 2>>"$LOG_ERRS" | grep -q "/${APPNAME}.${APPTYPE} type squashfs" ); then	# if the package has been mounted and symlinked, then...
		[ $DEBUG -gt 0 ] && echo -e "\tPackage is symlinked...\n\tCalling: sudo /bin/umount \"${DIR_LOOP}/${APPNAME}.${APPTYPE}\"" >> "$LOG_DBUG"
		sudo /bin/umount "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 || return 1				#   umount the squashfs file to make sure no contents are being used by other software (thanks Marco Caminati)

		[ $DEBUG -gt 0 ] && echo -e "\tCalling: sudo /bin/mount \"./$APPFILE\" \"${DIR_LOOP}/${APPNAME}.${APPTYPE}\" -t squashfs -o loop,ro,bs=4096" >> "$LOG_DBUG"
		sudo /bin/mount "./$APPFILE" "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -t squashfs -o loop,ro,bs=4096 >>"$LOG_ERRS" 2>&1 || return 1			# remount it again for further processing
	else											# otherwise it was a copy-to-RAM, so...
		[ ! -e "${DIR_LOOP}/${APPNAME}.${APPTYPE}" ] && { mkdir -p "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 || return 1; }			# if the mount point doesn't exist, then create it!

		[ $DEBUG -gt 0 ] && echo -e "\tPackage is in the RAM...\n\tCalling: sudo /bin/mount \"./$APPFILE\" \"${DIR_LOOP}/${APPNAME}.${APPTYPE}\" -t squashfs -o loop,ro,bs=4096" >> "$LOG_DBUG"
		sudo /bin/mount "./$APPFILE" "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -t squashfs -o loop,ro,bs=4096 >>"$LOG_ERRS" 2>&1 || return 1			# now mount it for processing

		for FILE in $(find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" ! -type d 2>>"$LOG_ERRS" | sed "s:${DIR_LOOP}/${APPNAME}.${APPTYPE}::"); do		# scan to make sure that no software in the package is being used
			fuser "$FILE" >>"$LOG_ERRS" 2>&1 && return 1				#   if one of the files in the package is currently in use, then exit this function	https://liquidat.wordpress.com/2015/08/26/short-tip-show-processes-accessing-a-file-fuser-lsof/   http://unix.stackexchange.com/questions/60492/whats-the-difference-between-lsof-and-fuser-uvm
		done
	fi

	[ $DEBUG -gt 0 ] && echo -e "\tChecking for modules..." >> "$LOG_DBUG"
	find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -type d -name modules 2>>"$LOG_ERRS" | grep -q . && MODULES=TRUE			# if the package has a [/lib/]'modules' directory, then we need to indicate we need to unload those modules later
	find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -type d -name lib 2>>"$LOG_ERRS" | grep -q . && LIBRARIES=TRUE			# if the package has a [/../]'lib' directory, then we need to indicate we need to load them later
# UPDATED 2018/07/14 - since TC packages do NOT adhere to this, we need a more robust solution
#	[ "$APPTYPE" = 'lib' ] && LIBRARIES=TRUE										# if the package has dynamic libraries, then indicate we need to remove those from the cache file later

	[ $DEBUG -gt 0 ] && echo -e "\tRemoving package contents from filesystem..." >> "$LOG_DBUG"
	for FILE in $(eval find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" $PARAMS 2>>"$LOG_ERRS" | sed "s:${DIR_LOOP}/${APPNAME}.${APPTYPE}::" | sort -r); do		# if we've made it here, delete all the files/dirs contained in the package from the OS
		if [ ! -d "$FILE" ]; then rm -f "$FILE" >>"$LOG_ERRS" 2>&1 || return 1						#   if the iterated FILE is anything but a directory (e.g. device file, symlink, text file, ...), then delete it!
		elif [ ! "$(ls -A "$FILE" 2>/dev/null)" ]; then rmdir "$FILE" >>"$LOG_ERRS" 2>&1; fi				#   otherwise it is a directory, so check if it's empty and delete it if so! NOTE: we do NOT error out here if we can't delete it!
	done

	[ -e "${DIR_INIT}/${APPNAME}" ] && rm -f "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>&1					# delete any service script (if it hasn't already above; in the event we have a script with a different name than the package [e.g. a specific version number])
	[ -e "${DIR_INST}/${APPNAME}.${APPTYPE}" ] && rm -f "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1		# delete the tce.installed marker (if it hasn't already above; in the event we have a marker with a different name than the package [e.g. a specific version number])
	sudo /bin/umount -d "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 || return 1					# finally umount the package
	rmdir "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1								# delete the packages mount point

# UPDATED 2025/10/22 - merged -P with -U
#	[ "$PURGE" -gt '0' ] && {
	[ "$PURGE" != '' ] && {
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [uninstall]"
		uninstallPackage || return 1											# if the package has been marked for uninstallation, then...
	}
# LEFT OFF - when installing, and a file exists (e.g. grep symlink to busybox), then rename to FILE.-PACK.TYPE (or 'SYS' if not part of package); when the PACK.TYPE is uninstalled and one of those files exists, restore it
#		is this necessary if we are creating restore points?

	[ -e "${DIR_CLOG}/${APPFILE}" ] && rm -f "${DIR_CLOG}/${APPHEAD}."* >>"$LOG_ERRS" 2>&1					# delete the 'catalog' item
	[ "$EXEID" ] && sed -i "/${RAWFILE}/d" "${EXEID%/*}/"*									# remove the package from all the cache files (since it was just unloaded!)	  NOTE: this was if a dep is in another list, but it doesn't have any deps and can be unloaded too
# UPDATED 2025/10/22 - merged -P with -U
#	[ "$INDEX" -eq 1 ] && [ "$PURGE" -gt '0' ] && sed -i "/${RAWFILE}/d" "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS"		# if we are updating the system from (one of the) requested packages and not one of its dependencies (via INDEX==1) -AND- we're unloading -AND- we're are actually purging (uninstalling), then remove the package from the onboot.lst file
	[ "$INDEX" -eq 1 ] && [ "$PURGE" != '' ] && sed -i "/${RAWFILE}/d" "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS"		# if we are updating the system from (one of the) requested packages and not one of its dependencies (via INDEX==1) -AND- we're unloading -AND- we're are actually purging (uninstalling), then remove the package from the onboot.lst file
	return 0
}


# Usage syntax: uninstallPackage
# Overview:	performs the work of the actual removal of the package files (not contents - see unloadPackage()), optionally to a restore point
# Notes:	this should be called after the package has been unloaded first!!!
# 		the directory containing the file to uninstall should already be entered BEFORE calling this function!
uninstallPackage() {
	[ $DEBUG -gt 0 ] && echo -e "uninstallPackage:" >> "$LOG_DBUG"
	if [ ! "$RESTORE" ]; then								# if we do NOT need a restore point, then...
		[ $DEBUG -gt 0 ] && echo -e "\tSkip creating a restore point...\n\trm -f ${APPHEAD}.*" >>$LOG_DBUG
		rm -f "${APPHEAD}".* >>"$LOG_ERRS" 2>&1 || return 1				# just delete the packages' files (e.g. .deps, .hash, .soft, ...) and exit
		return 0
	fi

	# if we've made it here then we need to create a restore point
	[ $DEBUG -gt 0 ] && echo -e "\tCreating a restore point..." >>$LOG_DBUG
	if [ ! -e "${REPO_RESTOR}" ] && [ -e "${DIR_MOUNT}/DATA/Links" ]; then			# if the root-level restore directory doesn't exist (e.g. /var/restore/2017-01-01 > /var/restore) -AND- there's a DATA, then...
		if [ ! -e "${DIR_MOUNT}/DATA/Links${REPO_RESTOR}" ]; then
			mkdir -p "${DIR_MOUNT}/DATA/Links${REPO_RESTOR}" >>"$LOG_ERRS" 2>&1 || {					#   create the restore directory on the DATA partition so that it actually gets preserved between reboots of the device
				echo "ERROR: the restore directory could not be created." >>"$LOG_ERRS"				# NOTE: we only write this to the log
				return 1
			}
		fi
		ln -sf "${DIR_MOUNT}/DATA/Links${REPO_RESTOR}" "${REPO_RESTOR}" >>"$LOG_ERRS" 2>&1 || {				#   now symlink to it so we can reference its contents
			echo "ERROR: The symlink to the restore directory could not be created." >>"$LOG_ERRS"			# NOTE: we only write this to the log
			return 1
		}
	fi

	# now create a unique name for the restore point: ACTION PACKAGE_NAMES/DIR_NAME (e.g. Updating sdl)
	TEMP="$(date +%F)/"
	[ "$INSTALL" ] && ( [ "$FORCE" ] || [ "$RESTORE" ] ) && TEMP="${TEMP}Updating ${APPNAME}.${APPTYPE}"			# add a description of this process to the restore point
# UPDATED 2025/10/22 - merged -P with -U
#	[ "$UNLOAD" ] && [ "$PURGE" -gt '0' ] && TEMP="${TEMP}Uninstalling ${APPNAME}.${APPTYPE}"
	[ "$UNLOAD" ] && [ "$PURGE" != '' ] && TEMP="${TEMP}Uninstalling ${APPNAME}.${APPTYPE}"

	# NOTE: the below line will create the entire REPO_RESTOR directory structure if there is no DATA, or just the date directory in the event there is one
	[ ! -e "${REPO_RESTOR}/${TEMP}" ] && { mkdir -p "${REPO_RESTOR}/${TEMP}" >>"$LOG_ERRS" 2>&1 || return 1; }		# if the restore point directory doesn't exist, then create it!

	readlink "$APPFILE" >/dev/null 2>&1 && {												# if a particular prior version of the package that was installed (designated via a symlink), then...
		[ $DEBUG -gt 0 ] && echo -e "\tPrior version...\n\tmv -f \"$(readlink ${APPFILE} | head -c -6)\".* \"${REPO_RESTOR}/${TEMP}\"" >> "$LOG_DBUG"
		mv -f "$(readlink "${APPFILE}" 2>>"$LOG_ERRS" | head -c -6)".* "${REPO_RESTOR}/${TEMP}" >>"$LOG_ERRS" 2>&1 || return 1		# move the actual files referenced by the symlinks to the restore point (which would be the numerical named files)
	}
	[ $DEBUG -gt 0 ] && echo -e "\tmv -f ${APPHEAD}.* \"${REPO_RESTOR}/${TEMP}\"" >> "$LOG_DBUG"
	mv -f "${APPHEAD}".* "${REPO_RESTOR}/${TEMP}" >>"$LOG_ERRS" 2>&1 || return 1		# now move the iterated dependency into the restore point	NOTE: it will be symlinks if VERSION has a value
	return 0
}


# Usage syntax: validatePackage
# Overview:	validates the package is 'correct', including all the dependencies are installed, all data files/dirs
#		from packages are installed, validate contents md5sum checks, ownership and permissions are correct
# Notes:	the directory containing the file to validate should already be entered BEFORE calling this function!
validatePackage() {
	( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${APPNAME}: [data]"
	( ! /bin/mount 2>>"$LOG_ERRS" | grep -q "/${APPNAME}.${APPTYPE} type squashfs" ) && MODE='copy' || MODE='link'	# if the package is not symlink, then indicate we need to copy it!
	installPackage || exitGracefully 1
	( [ "$SILENT" ] || [ "$QUIET" ] ) || echo " [done]"
	return 0
}




# SET INITIAL VARIABLE VALUES									  NOTE: we have to set these here since they rely on functions above

LIST="$( ( checkBootcode list2 && [ -e "${REPO_PREFIX}/$(getBootcode list2)" ] ) && getBootcode list2 || echo 'optional.list')"					# stores a specified secondary boot list (if it exists) -OR- uses the default 'optional.list' otherwise
FLAG="${LIST%.*}.flag"																		# store an accompanying blacklist flag file for packages that should NOT be installed from the secondary boot list (or their dependencies)
MODE="$(TEMP="$(getBootcode mode)"; ( [ "$TEMP" = 'conservative' ] || readlink $REPO_PREFIX | grep -q DATA ) && echo 'link' && exit 0; echo 'copy')"		# store the install mode: copy, (sym)link	NOTE: symlink by default if we are in a 'conservative' operation mode -OR- we are using DATA as the source of the repo




# LOAD VARIABLE PERSONALIZATION

[ -e "${DIR_CONF}/config" ] && . "${DIR_CONF}/config"						# overwrite any of the variables set above by reading in a global config file
[ -e "${HOME}/.${DIR_CONF:1}/config" ] && . "${HOME}/.${DIR_CONF:1}/config"			# same using a personalized config file - using XSB
[ -e "${HOME}/.${DIR_CONF##*/}/config" ] && . "${HOME}/.${DIR_CONF##*/}/config"			# same using a personalized config file - using LSB




# SCRIPT PARAMETER PROCESSING

if [ "$1" = '--help' ]; then									# displays ACTION and OPTION help for this module
	echo
	echo " This script provides package management for a Linux distro that currently does"
	echo " not have this functionality, or is interested in switching from its existing"
	echo " implementation. The packages created and used by this system can be copied out"
	echo " or mounted and linked-to using the read-only and compact squashfs file system."
	echo
	echo "  Usage: ${0##*/} ACTION [OPTIONS] PACKAGE(S) [DIRECTORY]"
	echo
	echo '  ACTIONS:'
# LEFT OFF - implement the below; so for example say we are using the frame buffer and upgrade to Xorg, the drivers package for the device will have the Xorg driver as an optional dependency that would now be installed with this action
#	echo '	-a   adds optional dependencies for installed software'
#	echo '	-b   '
	echo '	-c   copy local packages to another directory'				# old '-t' > new '-c'
	echo '	-d   download package(s) only'
	echo '	-e   extract package(s) contents'
	echo '	-f   find which local package(s) a file belongs to'
#	echo '	-g   '
#	echo '	-h   '
	echo '	-i   install package(s)'
#	echo '	-j   '
# LEFT OFF - check for updates to installed packages (compare the version numbers in the local .list files vs ones dl'ed from repo server); use cron to do this regularly
#	echo '	-k   check for updates to installed packages'
#			check		simply checks for updates and notifies
#			download	checks and downloads updates
#			install		checks, downloads, and installs updates
# VER2 - also so packages that are downloaded, but not installed (e.g. from using the -L option so a user can delete them if desired)
	echo '	-l   list all currently installed packages'
	echo '	-m   make a new package (requires DIRECTORY)'					# this makes a new .soft package tarball based on the passed directory; 	NOTE: you can just have the .make file call builder to do all the heavy lifting
#	echo '	-n   '
#	echo '	-o   '
#	echo '	-p   '
#	echo '	-q   '
	echo '	-r   restore package(s) from a restore point'					# NOTE: this does not perform any uninstallation of newer running version or installation of the restored version, just restores the software (and deps) to the 'optional' directory (as if the package had just be downloaded)
# LEFT OFF - implement the below; it's like apt-search; this needs to work with both directory structure and URL submissions; make it so you can search for packages (names) or files (within a package, like the -f action but for all packages in the repo)
#		maybe create a php file that can be used in TC repo to allow this
#	echo '	-s   search the repo to find matches of passed term(s)'
#		non-db queries will need to download all the manifest files and grep them to find the file
#		db queries will need to utilize another variable REPO_QUERY specifying the URI of the script to submit the search to
	echo '	-t   show the dependency trees of installed package(s)'
	echo '	-u   uninstall package(s): unload, remove, purge'			# NOTE: use with -U or -P to actually uninstall the package (note this in the NOTES section below)
	echo "	-v   validate package(s): data, deps"					# makes sure all data files/dirs from packages are installed, all the dependencies are installed, validate contents md5sum checks, ownership and permissions are correct; data=files,dirs,hash,owner,perms
#	echo '	-w   '
#	echo '	-x   '
#	echo '	-y   '
#	echo '	-z   '
	echo '	--help      shows this screen'
	echo '	--version   displays the software version'
	echo
	echo '  OPTIONS:'
# LEFT OFF - implement
#	echo '	-A   approval code/key from the server when making purchases'			# so after the software is purchased, the code/key can be passed as authentication to download the software package(s)
	echo '	-B   indicates we are currently booting the system'			# NOTE: this currently does nothing!!!		NOTE 2025/10/06 - use this to indicate everything gets installed to root, not /Users/Public or a home directory
	echo '	-C   specifies an alternative CPU architecture: i32, i64, r32, r64'		# this allows for alternative CPU software downloads		r01 (raspi 0 and 1), r23 (raspi 2 and 3)
# UPDATED 2025/10/22
#	echo '	-D   sets the directory prefix when installing/unloading packages'		# this can be used to install to / (OS - admin permissions), /Users/.Public (everyone), $HOME (personal) while retaining the bin, sbin, lib, etc structure
	echo '	-D   sets the directory prefix when (un)installing packages'			# this can be used to install to / (OS - admin permissions), /Users/.Public (everyone), $HOME (personal) while retaining the bin, sbin, lib, etc structure
	echo '	-E   obtains any extra package files: all, info, list'				# not installed by default to keep size down
	echo '	-F   force the ACTION to take place'						# NOTE: this ignores the package installed status on the existing system so if we need to download packages to another device (e.g. installing XiniX to other media) we can do so
#	echo '	-G   '
#	echo '	-H   '
	echo '	-I   list of dependencies to ignore during unload/uninstall'			# for example, web.de can be listed for theme uninstalls
	echo '	-J   just process the listed packages, not any dependencies'
	echo '	-K   specifies an alternative kernel name (4.1.6_xinix)'			# this allows for alternative kernel software downloads
# UPDATED 2025/10/23 - make this a negation instead of an inclusion, meaning we add to the list by default, but using the -L prevents this from happening
#	echo '	-L   adds the software to the (optional.)list when installing'			# this only is useful when installing
	echo '	-L   prevent package addition to (optional.)list when installing'			# this only is useful when installing
	echo '	-M   defines the package install mode: copy, link (default)'		# old '-R' > new '-M copy'		NOTE: if the OS is run from RAM, then the 'copy' value will copy into RAM, if it is on a disk, then it copies to the disk
	echo '	-N   do NOT install all files in the package, just those specified'		# allows users to install desired file(s) from a package so all the contents don't get installed (to keep the system as small as possible); keeps attack vector to a minimum
# LEFT OFF - implement the 'html' and 'xml' values
	echo '	-O   defines the way output is displayed: none, text (default)'		# old '-Q' > new '-O none'		NOTE: this defines the way the output is shown
# UPDATED 2025/10/22 - merged -P with -U
#	echo '	-P   purges all files of the uninstalled packages including configs'		# data ALWAYS is retained though! (e.g. mysql databases)
#	echo '	-P   '
	echo '	-Q   quiets the output to only show errors'				# old '-q' > new '-Q'
	echo '	-R   create a restore point when uninstalling'				# old '-N' > new 'absence of value'; if you want to create a restore point, you must now specify the flag!
	echo '	-S   changes the source repo/directory to obtain software from'			# mainly used when creating installation media to pull the files from an existing BOOT instead of an online repo
	echo '	-T   specifies the package type: bin, dev, doc, drv, gir, lib, loc'
# UPDATED 2025/10/22 - merged -P with -U
#	echo '	-U   uninstalls all files of the package excluding configs'		# old '-p' > new '-U'
# UPDATED 2025/10/23 - merged with -u
#	echo '	-U   uninstalls specified package files: all, app (leaves configs)'	# old '-p' > new '-U'		# data ALWAYS is retained though! (e.g. mysql databases)
#	echo '	-U   '
	echo '	-V   the specific version of a package to install'
	echo '	-W   installs the whole .deps list of software, including optional'	# old '-A' > new '-W'			this is so that if a user is installing a drivers set, any optional software is also installed (e.g. [xf86_video_intel|xorg])
	echo '	-X   obtain packages via proxy using another device'				# Can be used when one location has little or no Internet access. For example, @home has bad internet connection, but work is good, can dl @work for @home.
#	echo '	-Y   '
#	echo '	-Z   '
	echo
	echo '  NOTES:'
	echo "	The '-i' ACTION first checks locally, then uses the repo."
	echo "	The '-m' ACTION can be used with pre-compiled software, or if a .make"
	echo "	     file is present, it will execute it to compile everything."
	echo "	     NOTES:"
	echo "	     - place the .make file one directory level down from the source code"
# UPDATED 2025/10/23
#	echo "	     - the source code directory will also be used with packaging, so make"
#	echo "         sure to swap out its contents for the compiled software"
	echo "	     - if using a .make file, install the compiled software in a 'package'"
	echo "	       directory alongside the .make file and source code"
	echo "	The '-r' ACTION does not perform an uninstallation of currently running"
	echo "	     versions, nor installation of the restored version itself, but"
	echo "	     simply restores the package files to the 'optional' directory to"
	echo "	     allow re-installation when you see fit to do so."
	echo "	The '-u' ACTION will always leave user data in place (docs, pics, etc)."
	echo "	The '-I' OPTION value must be comma separated."
	echo "	The '-L', '-M', and '-V' OPTIONS can only be used with the '-i' ACTION."
	echo "	The '-N' OPTION takes a comma separated list of filenames."
	echo "	The '-S' OPTION can take a directory or URL as its value."
# UPDATED 2025/10/22 - merged -P with -U
#	echo "	The '-P' and '-U' OPTIONS can only be used with the '-u' ACTION and"
	echo "	The '-X' OPTION can only be used with the '-c' and '-d' ACTIONS."
	echo "	When using the '-V' OPTION, you can only list one package at a time."
	echo "	     NAME.all.src.make file exists, it will use that to compile."
	echo "	The PACKAGE(S) value can be:"
	echo "	     - a file containing a list (one package per line)"
	echo "	     - directory containing the package(s)"
	echo "	     - or a space separated list of package names"
	echo "	The DIRECTORY as the last parameter must be:"
	echo "	     - a full path: /tmp/pax/"
	echo "	     - or a relative path: ./pax"
	echo "	     - or have a trailing slash: pax/"
	echo
	echo '  EXAMPLES:'
	echo '	Install a package:'
	echo "	     ${0##*/} -i nano[.i32.bin.soft] [/path/to/local/file]"
	echo '	Install packages from a file listing:'
	echo "	     ${0##*/} -i /path/to/package.list"
	echo '	Install a specific version:'
	echo "	     ${0##*/} -i -V 1.2.3 nano[.i32.bin.soft] [/path/to/local/file]"
	echo '	Make a package for distribution:'
	echo "	     ${0##*/} -m nano /path/to/{package|source}"				# if there is a .make file, then it will compile from source code too
	echo '	Only download a package from the repo:'
	echo "	     ${0##*/} -d nano[.i32.bin.soft]"
	echo '	Extract package contents:'
	echo "	     ${0##*/} -e nano[.i32.bin.soft] [/path/to/extract]"
	echo '	Update a package with optional restore point:'
	echo "	     ${0##*/} -i [-R] nano[.i32.bin.soft]"
	echo '	Unload a package:'
	echo "	     ${0##*/} -u unload nano[.i32.bin.soft]"
	echo '	Uninstall a package, leaving configs:'
	echo "	     ${0##*/} -u remove nano[.i32.bin.soft]"
	echo '	Uninstall a package, including configs too:'
	echo "	     ${0##*/} -u purge nano[.i32.bin.soft]"
	echo
	exit 0
elif [ "$1" = '--version' ]; then
	head -10 $(which pax) | grep ^'# updated' | sed "s/.*\\t//;s/ .*//;s:/:.:g"
	exit 0
else
	while getopts BcC:dD:eE:f:FiI:JK:lLmM:N:OQr:RS:tT:u:v:VW:X: OPTION; do			# NOTE: the 'V:' indicates that the '-V' parameter requires a value!
		case ${OPTION} in
			B) BOOTING=TRUE ;;
			c) COPY=TRUE ;;
			C) ( echo ${OPTARG} | grep -q -e ^'i32'$ -e ^'i64'$ -e ^'r32'$ ) || {
				[ "$SILENT" ] || echo "ERROR: you must supply a CPU architecture to the -C option." | tee -a "$LOG_ERRS"
				exit 1
			   }
			   CPU="$OPTARG" ;;
			d) DOWNLOAD=TRUE ;;
			D) ( echo ${OPTARG} | grep -q ^'/' ) || {
				[ "$SILENT" ] || echo "ERROR: you must supply an absolute path to the -D option." | tee -a "$LOG_ERRS"
				exit 1
			   }
			   PREFIX="$OPTARG" ;;
			e) EXTRACT=TRUE ;;
			E) if [ "$OPTARG" != 'all' ] && [ "$OPTARG" != 'info' ] && [ "$OPTARG" != 'list' ]; then
				[ "$SILENT" ] || echo "ERROR: you must supply a valid file to the -E option." | tee -a "$LOG_ERRS"
				exit 1
			   fi
			   EXTRA="$OPTARG" ;;
			f) FIND=TRUE ;;
			F) FORCE=TRUE ;;
			i) INSTALL=TRUE ;;
			I) ( echo ${OPTARG:0:1} | grep -q ^[0-9a-zA-Z] ) || {
				[ "$SILENT" ] || echo "ERROR: you must supply a comma separated list to the -I option." | tee -a "$LOG_ERRS"
				exit 1
			   }
			   IGNORE="$OPTARG" ;;
			J) ONLY=TRUE ;;
			K) ( echo ${OPTARG:0:1} | grep -q ^[0-9] ) || {
				[ "$SILENT" ] || echo "ERROR: you must supply a kernel name to the -K option." | tee -a "$LOG_ERRS"
				exit 1
			   }
			   KERNEL="$OPTARG" ;;
			l) # [Colors]
			   NORMAL="\e[0m"
			   BLINK="\e[5m"
			   INVERSE="\e[7m"
			   HIDE="\e[8m"
			   UL="\e[4m"

			   BLACK="\e[0;30m"
			   GARNET="\e[0;31m"
			   GREEN="\e[0;32m"
			   BROWN="\e[0;33m"
			   NAVY="\e[0;34m"
			   MAGENTA="\e[1;35m"
			   TEAL="\e[0;36m"
			   DARKGREY="\e[1;30m"
			   GREY="\e[0;37m"
			   RED="\e[1;31m"
			   LIME="\e[1;32m"
			   YELLOW="\e[1;33m"
			   BLUE="\e[1;34m"
			   PURPLE="\e[0;35m"
			   CYAN="\e[1;36m"
			   WHITE="\e[1;37m"

			   printf "${WHITE}%-30s %-4s %-32s %-11s\n" "Name" "Type" "              Hash" "  Version"
			   printf "%30s %4s %32s %11s\n" "------------------------------" "----" "--------------------------------" "-----------"

# UPDATED 2025/10/22 - no longer using APP* variables
#			   for FILE in $(ls -1 "$DIR_CLOG" 2>/dev/null | grep 'soft'$); do		# NOTE: using 'grep' prevents directory from being part of FILE
#				splitName "$FILE"
#
#				printf "${NORMAL}%-30s %-49s\n" "$APPNAME" "$([ -e ${DIR_CLOG}/${APPHEAD}.info ] && cat ${DIR_CLOG}/${APPHEAD}.info | grep ^'Description:' | sed 's/Description:[ \t]*//')"
#				printf "%-30s ${BLUE}%-4s ${DARKGREY}%-32s ${BLUE}%-11s${NORMAL}\n" ' ' "$APPTYPE" "$([ -e ${DIR_CLOG}/${APPHEAD}.hash ] && sed 's/ .*//' ${DIR_CLOG}/${APPHEAD}.hash)" "$([ -e ${DIR_CLOG}/${APPHEAD}.info ] && cat ${DIR_CLOG}/${APPHEAD}.info | grep ^'Version:' | sed 's/Version:[ \t]*//')"
			   for FILE in $(ls -1 "$DIR_CLOG" 2>/dev/null | grep ${EXT_SOFT}$); do		# NOTE: using 'grep' prevents directory from being part of FILE
				case $FILE in
					*-lib*) TYPE='lib' ;;
					*-dev*) TYPE='dev' ;;
					*-doc*) TYPE='doc' ;;
					*-gir*) TYPE='gir' ;;
					*) TYPE='bin' ;;
				esac
				printf "${NORMAL}%-30s %-49s\n" "$FILE" "$([ -e ${DIR_CLOG}/${PAK_FILE}.${EXT_INFO} ] && cat ${DIR_CLOG}/${PAK_FILE}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//')"
				printf "%-30s ${BLUE}%-4s ${DARKGREY}%-32s ${BLUE}%-11s${NORMAL}\n" ' ' "$TYPE" "$([ -e ${DIR_CLOG}/${PAK_FILE}.${EXT_HASH} ] && sed 's/ .*//' ${DIR_CLOG}/${PAK_FILE}.${EXT_HASH})" "$([ -e ${DIR_CLOG}/${PAK_FILE}.${EXT_INFO} ] && cat ${DIR_CLOG}/${PAK_FILE}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//')"
			   done
			   echo -e "${NORMAL}"
			   exit 0
			   ;;
			L) NOLIST=TRUE ;;
			m) MAKE=TRUE ;;
			M) if [ "$OPTARG" != 'copy' ] && [ "$OPTARG" != 'link' ]; then
				[ "$SILENT" ] || echo "ERROR: you must supply a proper mode type to the -M option." | tee -a "$LOG_ERRS"
				exit 1
			   fi
			   MODE="$OPTARG" ;;
			N) FILELIST="$OPTARG" ;;
			O) if [ "$OPTARG" != 'none' ] && [ "$OPTARG" != 'text' ]; then
				[ "$SILENT" ] || echo "ERROR: you must supply a proper value to the -O option." | tee -a "$LOG_ERRS"
				exit 1
			   fi
			   [ "$OPTARG" = 'none' ] && SILENT=TRUE ;;
# MERGED 2025/10/22 - this was merged with -U
#			P) PURGE=2 ;;
			Q) QUIET=TRUE ;;
			r) ( echo ${OPTARG:0:1} | grep -q ^[0-9] ) || {
				[ "$SILENT" ] || echo "ERROR: you must supply a restore date to the -r action." | tee -a "$LOG_ERRS"
				exit 1
			   }
			   RESTORE="$OPTARG" ;;
			R) RESTORE=TRUE ;;
			S) if ( echo $OPTARG | grep -q ^'http' ) || ( echo $OPTARG | grep -q ^'ftp' ) || ( echo $OPTARG | grep -q ^'/' ) || ( echo $OPTARG | grep -q ^'./' ); then
				[ "$SILENT" ] || echo "ERROR: you must supply a directory or http/ftp URI to the -S option." | tee -a "$LOG_ERRS"
				exit 1
			   fi
			   REPO_SOURCE="$OPTARG" ;;
			t) echo "Dependency trees for package(s)..."
			   TREE=TRUE ;;
			T) if [ "$OPTARG" != 'bin' ] && [ "$OPTARG" != 'dev' ] && [ "$OPTARG" != 'doc' ] && [ "$OPTARG" != 'drv' ] && [ "$OPTARG" != 'gir' ] && [ "$OPTARG" != 'lib' ] && [ "$OPTARG" != 'loc' ]; then
				[ "$SILENT" ] || echo "ERROR: the specified value to the -T option is invalid." | tee -a "$LOG_ERRS"
				exit 1
			   fi
			   TYPE="$OPTARG" ;;
# UPDATED 2025/10/23 - merged with -U
#			u) UNLOAD=TRUE ;;
			u) if [ "$OPTARG" != 'unload' ] && [ "$OPTARG" != 'remove' ] && [ "$OPTARG" != 'purge' ]; then
				[ "$SILENT" ] || echo "ERROR: the specified value to the -u action is invalid." | tee -a "$LOG_ERRS"
				exit 1
			   fi
			   UNLOAD=TRUE
			   [ "$OPTARG" != 'unload' ] && PURGE="$OPTARG" ;;		# specify the purge type if we're not just unloading the software
# UPDATED 2025/10/23 - merged with -u
#			U) if [ "$OPTARG" != 'app' ] && [ "$OPTARG" != 'all' ]; then
#				[ "$SILENT" ] || echo "ERROR: the specified value to the -U switch is invalid." | tee -a "$LOG_ERRS"
#				exit 1
#			   fi
#			   PURGE="$OPTARG" ;;
# UPDATED 2025/10/22
#			   PURGE=1 ;;
			v) if [ "$OPTARG" != 'data' ] && [ "$OPTARG" != 'deps' ]; then
				[ "$SILENT" ] || echo "ERROR: you must supply a proper mode type to the -v action." | tee -a "$LOG_ERRS"
				exit 1
			   fi
			   VALIDATE="$OPTARG" ;;
			V) ( echo ${OPTARG:0:1} | grep -q ^[0-9] ) || {
				[ "$SILENT" ] || echo "ERROR: you must supply a version number to the -V option." | tee -a "$LOG_ERRS"
				exit 1
			   }
			   VERSION="$OPTARG" ;;
			W) ALL=TRUE ;;
			X) ( echo ${OPTARG} | grep -q ^'/' ) || {
				[ "$SILENT" ] || echo "ERROR: you must supply a device mount point to the -X option." | tee -a "$LOG_ERRS"
				exit 1
			   }
			   proxyAction
			   PROXY="$OPTARG" ;;
			*) exit 1 ;;								# NOTE: since 'getopts' presents it own error, we don't need to do so here
		esac
	done
fi




# MANDATORY CHECKS BEFORE **ANY** PROCESSING

if [ "$FIND" ]; then										# if we are trying to find a file in a package, then...
	shift $(expr $OPTIND - 2)								#   remove the script name ($0) and the action (-f) and store all the filenames passed
	eval TEMP=\${$#}

elif [ ! "$FIND" ]; then									# we're not finding a file (since none of these checks are relevent for that action), then...
	shift $(expr $OPTIND - 1)								# now that the ACTIONS and OPTIONS have been processed, lets process the package name(s)
	eval TEMP=\${$#}									# store the current last passed value to later check if a directory was passed as the last value	http://stackoverflow.com/questions/1853946/getting-the-last-argument-passed-to-a-shell-script

	# WARNING: this MUST come before the directory processing!!!
	if [ "$TEMP" = "$0" ]; then								# if a blank or null value was given for the package name (since the 'shift' command will go back to $0), then...
		echo "ERROR: you must provide a file or package name before processing can begin." | tee -a "$LOG_ERRS"; 
		exit 1
	elif [ -f "$1" ] && [ ! "$(echo $1 | grep -e ${EXT_SOFT}$)" ]; then			# check if the PACKAGE(S) value was actually passed as a text file -AND- is NOT a package name (ending with the EXT_SOFT extension)	NOTE: can't check for mime type since busybox doesn't have a 'file' applet
		[ "$1" = "$TEMP" ] && TEMP=''							#   if the PACKAGE(S) value is the last passed value, then erase the TEMP value to avoid directory processing below
		TEMPLIST="$(cat "$1" | tr '\n' ' ')"						#   store all the packages to load within the list
		[ "$TEMPLIST" = '' ] && exit 0							#   if there are NOT any files in the list, there's nothing to process so exit
		set -- $TEMPLIST								#   reset all the $1, $2, $3, etc values (and $@ that is used in the main 'for' loop below)
		unset TEMPLIST
	fi

	if [ "$MAKE" ] && ( ( echo "$1" | grep -q ^'/' ) || ( echo "$1" | grep -q ^'./' ) ); then
		[ "$SILENT" ] || echo "ERROR: you must supply a package name with the -m action." | tee -a "$LOG_ERRS"
		exit 1
	fi

	if [ ! -d "$TEMP" ] && ( echo $TEMP | grep -q '/' ); then				# if a directory was actually passed (via the presence of '/' characters), but doesn't exist then...
		[ "$SILENT" ] || echo "ERROR: the passed file or directory does not exist (${TEMP})." | tee -a "$LOG_ERRS"	#   NOTE: this is shown to the screen and logged on purpose!
		exit 1
	elif [ -d "$TEMP" ] && ( echo $TEMP | grep -q '/' ); then				# otherwise, overwrite the default TCEDIR value (if a directory was passed, indicated via the presense of '/')
		if [ "$1" = "$TEMP" ]; then							# if the last passed value (the DIRECTORY) is also the PACKAGE(S) value, then a directory needs to be processed as the 'list'...
			TEMPLIST="$(ls -1 "${1}/"*.soft 2>/dev/null | tr '\n' ' ')"		#   store all the .soft packages to load within the directory
			[ "$TEMPLIST" = '' ] && exit 0						#   if there are NOT any files in the directory, there's nothing to process so exit
			set -- "$TEMPLIST"							#   reset all the $1, $2, $3, etc values (and $@ that is used in the main 'for' loop below)
			if [ "$TEMP" != "$REPO_OPTION" ] && [ "$TEMP" != "$REPO_SYSTEM" ]; then	#   if neither of the two defaults repo locations were passed (e.g. not booting) as the location, then...
				REPO_SOURCE="$TEMP"						#   automatically update this value since it is the source location where the desired files are stored
				[ "$(echo $REPO_SOURCE|tail -c 2)" = '/' ] && TEMP="$(echo $REPO_SOURCE|head -c -2)"		# if the user included a trailing '/' on the passed directory, then remove it to prevent parsing below
			fi
# REMOVED 2025/10/23 - unsure what this is being used for; it causes problems with -m
#		else										# otherwise a new value for DIRECTORY was given, so...
#echo bottomer
#			TEMPLIST=''
#			for PARAM in ${@}; do							#   process each remaining parameter
#				[ "$PARAM" = "$TEMP" ] && break				#   if we have reached the last parameter, break out of the 'for' loop
#				TEMPLIST="$TEMPLIST $PARAM"					#   append each parameter to the list
#			done
#			unset PARAM
#			set -- "$TEMPLIST"							#   now reset the $@ array to exclude the last directory
#
#			REPO_TARGET="$TEMP"							#   update the target value since that is where the user wants the packages stored
#			[ "$(echo $REPO_TARGET|tail -c 2)" = '/' ] && TEMP="$(echo $REPO_TARGET|head -c -2)"
		fi
		unset TEMPLIST

# REMOVED 2025/10/23 - this appears to NOT be used (probably was for previous -m implementation since it stores the last part of the passed directory)		 do we need to store the value in TEMP, since it gets immediately erased afterwards?
#		TEMP="${TEMP##*/}"								# remove everything but the last directory to rename
	fi
fi

TEMP=''												# make sure this value is not contaminating anything

# check the variable values
# UPDATED 2025/10/22 - the -f action does NOT supply a package name
#[ ! "$1" ] && { [ "$SILENT" ] || echo "ERROR: you must provide a PACKAGE name." | tee -a "$LOG_ERRS"; exit 1; }
[ ! "$1" ] && [ ! "$FIND" ] && { [ "$SILENT" ] || echo "ERROR: you must provide a PACKAGE name." | tee -a "$LOG_ERRS"; exit 1; }
[ ! "$2" ] && [ "$MAKE" ] && { [ "$SILENT" ] || echo "ERROR: you must provide a directory to package." | tee -a "$LOG_ERRS"; exit 1; }
[ ! "$COPY" ] && [ ! "$DOWNLOAD" ] && [ ! "$EXTRACT" ] && [ ! "$FIND" ] && [ ! "$INSTALL" ] && [ ! "$MAKE" ] && [ ! "$RESTORE" ] && [ ! "$TREE" ] && [ ! "$UNLOAD" ] && [ ! "$VALIDATE" ] && { [ "$SILENT" ] || echo "ERROR: you must provide an ACTION." | tee -a "$LOG_ERRS"; exit 1; }
[ ! -d "$REPO_PREFIX" ] && [ "$MAKE" ] && { [ "$SILENT" ] || echo "ERROR: the directory storing the package contents does NOT exist." | tee -a "$LOG_ERRS"; exit 1; }
[ ! -d "$REPO_PREFIX" ] && [ ! "$MAKE" ] && { [ "$SILENT" ] || echo "ERROR: the package storage root directory does NOT exist." | tee -a "$LOG_ERRS"; exit 1; }
[ ! -d "$REPO_OPTION" ] && [ ! "$MAKE" ] && ( mkdir -p "$REPO_OPTION" || { [ "$SILENT" ] || echo "ERROR: the package storage directory could NOT be created." | tee -a "$LOG_ERRS"; exit 1; } )
[ "$MAKE" ] && [ "$(echo $REPO_PREFIX | head -c 1)" != '/' ] && { [ "$SILENT" ] || echo "ERROR: you must include the full path (not relative) when creating a package." | tee -a "$LOG_ERRS"; exit 1; }
[ "$RESTORE" ] && [ ! -e "${REPO_RESTOR}/${RESTORE}" ] && { [ "$SILENT" ] || echo "ERROR: the passed path is not a valid restore point." | tee -a "$LOG_ERRS"; exit 1; }

# check the directories
if [ ! -d "${DIR_CLOG}" ]; then
	mkdir -p "${DIR_CLOG}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The init script directory (DIR_CLOG) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
fi
touch "${DIR_CLOG}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The init script directory (DIR_CLOG) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
rm "${DIR_CLOG}/writable" >>"$LOG_ERRS" 2>&1

if [ ! -d "${DIR_INIT}" ]; then
	mkdir -p "${DIR_INIT}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The init script directory (DIR_INIT) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
fi
touch "${DIR_INIT}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The init script directory (DIR_INIT) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
rm "${DIR_INIT}/writable" >>"$LOG_ERRS" 2>&1

if [ ! -d "${DIR_INST}" ]; then
	mkdir -p "${DIR_INST}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The installed cache directory (DIR_INST) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
fi
touch "${DIR_INST}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The installed cache directory (DIR_INST) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
rm "${DIR_INST}/writable" >>"$LOG_ERRS" 2>&1

if [ ! -d "${DIR_LOGS}" ]; then
	mkdir -p "${DIR_LOGS}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The logs directory (DIR_LOGS) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
fi
touch "${DIR_LOGS}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The logs directory (DIR_LOGS) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
rm "${DIR_LOGS}/writable" >>"$LOG_ERRS" 2>&1

if [ ! -d "${DIR_LOOP}" ]; then
	mkdir -p "${DIR_LOOP}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The mounting directory (DIR_LOOP) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
fi
touch "${DIR_LOOP}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The mounting directory (DIR_LOOP) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
rm "${DIR_LOOP}/writable" >>"$LOG_ERRS" 2>&1

if [ ! -d "${DIR_TEMP}" ]; then
	mkdir -p "${DIR_TEMP}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The temp directory (DIR_TEMP) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
fi
touch "${DIR_TEMP}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The temp directory (DIR_TEMP) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
rm "${DIR_TEMP}/writable" >>"$LOG_ERRS" 2>&1




# PERFORM SOME ACTUAL WORK

if [ "$UNLOAD" ]; then										# if we are unloading software, then...
	TEMP=$OPTIND										#   store the current OPTIND value to restore it in just a second
	for APPFILE in $@; do touch ${DIR_CLOG}/${APPFILE}.mark; done				#   mark all the files we want to unload
	OPTIND=$TEMP										#   restore the original value of OPTIND
fi

for RAWFILE in $@; do
	( [ "$RAWFILE" = "$REPO_OPTION" ] || [ "$RAWFILE" = "${REPO_OPTION}/" ] ) && continue	# if we've made it to a passed directory (with and without trailing '/'), then skip processing it

	INDEX=0											# reset these values each iteration
	TOTAL=0

	splitName "$RAWFILE"									# NOTE: the RAWFILE value will be overwritten by the splitName() call
#	PAK_NAME=$RAWFILE
#	eval PAK_FILE=${PAK_FILE}
#echo "|${RAWFILE}|${PAK_FILE}|"

# UPDATED 2025/10/22 - no longer using APP* variables
#	[ $DEBUG -gt 0 ] && echo -e "body:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:" >> "$LOG_DBUG"
	[ $DEBUG -gt 0 ] && echo -e "body:\n\tPAK_FILE :${PAK_FILE}:\n\tPAK_NAME :${PAK_NAME}:\n\tEXT_SOFT :${EXT_SOFT}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:" >> "$LOG_DBUG"

	if [ "$EXTRACT" ]; then									# if we are extracting a packages contents, then...
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "Extracting the '${PAK_NAME}' package:"
		[ ! "$REPO_TARGET" ] && REPO_TARGET='./'					# if no directory was passed, then set the current directory as the target
		unsquashfs -f -d "$REPO_TARGET" ${PAK_FILE}.${EXT_SOFT} 1>/dev/null 2>>"$LOG_ERRS" || exitGracefully 1
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo " [done]"
		continue
	elif [ "$FIND" ]; then									# if we are finding a file in an installed package, then...
		cd "${REPO_SYSTEM}" >/dev/null 2>>"$LOG_ERRS"					#   change into the first repo location to check for the files
		for FILE in $(ls -1 *.${EXT_SOFT}); do
			[ $(stat -c %s $FILE) -eq 0 ] && continue				#   skip all 0 byte files (since they can just be placeholders); this really shouldn't come into play in this location, but better safe than sorry
			unsquashfs -ll $FILE | tail -n +5 | grep -v ^d | sed 's:.*/::' | grep -q "$RAWFILE" && {
				echo $FILE
				unsquashfs -ll $FILE | tail -n +5 | grep -v ^d | sed 's/.*squashfs-root/   /' | grep "$RAWFILE"
			}
		done

		if [ "$REPO_OPTION" != "$REPO_SYSTEM" ]; then					#   if there are separate repo's for packages (e.g. XiniX and not TC), then...
			cd "${REPO_OPTION}" >/dev/null 2>>"$LOG_ERRS"				#	change into the optional repo location to further check for the files
			for FILE in $(ls -1 *.${EXT_SOFT}); do
				[ $(stat -c %s $FILE) -eq 0 ] && continue			#	skip all 0 byte files (since they can just be placeholders)
				unsquashfs -ll $FILE | tail -n +5 | grep -v ^d | sed 's:.*/::' | grep -q "$RAWFILE" && {
					echo $FILE
					unsquashfs -ll $FILE | tail -n +5 | grep -v ^d | sed 's/.*squashfs-root/   /' | grep "$RAWFILE"
				}
			done
		fi
		continue
	elif [ "$MAKE" ]; then									# if we are creating a package for distribution, then...
		cd "${2}/.." >/dev/null 2>>"$LOG_ERRS"						# change into one level up from the passed directory (e.g. /tmp/staging[/bin,/etc,/usr,...] > /tmp) so the generated files get placed correctly

# UPDATED 2025/10/22 - no longer using APP* variables
#		if [ -e "${APPNAME}.all.src.make" ] && [ -x "${APPNAME}.all.src.make" ]; then	# if a compile script exists, then lets run that first!
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Making the '${APPNAME}' package..."
#			./${APPNAME}.all.src.make >${APPNAME}.all.src.make.log 2>&1 || {
		if [ -e "${PAK_FILE}.${EXT_MAKE}" ] && [ -x "${PAK_FILE}.${EXT_MAKE}" ]; then	# if a compile script exists, then lets run that first!
			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Making the '${PAK_NAME}' package..."
			./${PAK_FILE}.${EXT_MAKE} >${PAK_FILE}.${EXT_MAKE}.log 2>&1 || {
				[ "$SILENT" ] || echo "ERROR: a compile error occurred - see the log for details."
				exitGracefully 1
			}
		fi
		[ -d "package" ] && TEMP='package' || TEMP="${2##*/}"				# if the compiled software call above created a 'package' directory then use it to create the packages below, otherwise use the directory that was passed

# UPDATED 2025/10/22 - no longer using APP* variables
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Creating the '${APPNAME}' package..."
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Creating the '${PAK_NAME}' package..."
# UPDATED 2025/10/23 - corrected the location to be the passed directory, and moved it to the top of this block
#		cd "${REPO_PREFIX}" >/dev/null 2>>"$LOG_ERRS"					# change into the previous directory (REPO_PREFIX) so the generated files get placed correctly (e.g. /tmp/staging > /tmp)
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[1/4] Erasing any prior files"
# UPDATED 2025/10/22 - no longer using APP* variables
#		rm -f ${APPHEAD}.* >/dev/null 2>>"$LOG_ERRS"
		rm -f ${PAK_FILE}.* >/dev/null 2>>"$LOG_ERRS"
# UPDATED 2025/10/22 - no longer using APP* variables
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[2/4] Creating the .soft file"
#		mksquashfs "${REPO_OPTION##*/}" "$APPFILE" >>"$LOG_ERRS" 2>&1
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[2/4] Creating the .${EXT_SOFT} file"
# UPDATED 2025/10/23 - corrected the location to be the passed directory
#		mksquashfs "${REPO_OPTION##*/}" "${PAK_FILE}.${EXT_SOFT}" >>"$LOG_ERRS" 2>&1
		mksquashfs "${TEMP}" "${PAK_FILE}.${EXT_SOFT}" >>"$LOG_ERRS" 2>&1
# UPDATED 2025/10/22 - no longer using APP* variables
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[3/4] Creating the .hash file"
#		md5sum "$APPFILE" > "${APPHEAD}.hash" 2>>"$LOG_ERRS"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[3/4] Creating the .${EXT_HASH} file"
		md5sum "${PAK_FILE}.${EXT_SOFT}" > "${PAK_FILE}.${EXT_HASH}" 2>>"$LOG_ERRS"
# UPDATED 2025/10/22 - no longer using APP* variables
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[4/4] Creating the .list file"
#		find "${REPO_OPTION##*/}" -not -type d 2>>"$LOG_ERRS" | sed "s/${REPO_OPTION##*/}//" > "${APPHEAD}.list" 2>>"$LOG_ERRS"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[4/4] Creating the .${EXT_LIST} file"
# UPDATED 2025/10/23 - corrected the location to be the passed directory
#		find "${REPO_OPTION##*/}" -not -type d 2>>"$LOG_ERRS" | sed "s/${REPO_OPTION##*/}//" > "${PAK_FILE}.${EXT_LIST}" 2>>"$LOG_ERRS"
		find "${TEMP}" -not -type d 2>>"$LOG_ERRS" | sed "s|${TEMP}||" > "${PAK_FILE}.${EXT_LIST}" 2>>"$LOG_ERRS"
		echo -e "\nThe package has been created!"
# UPDATED 2025/10/22 - no longer using APP* variables
#		echo -e "Don't forget to create/update the .deps and .info files!\n"
		echo -e "Don't forget to create/update the .${EXT_HASH} and .${EXT_INFO} files!\n"
		exit 0										# prevent the code below from executing since we're done with this ACTION
	elif [ "$PROXY" ]; then
		echo "$RAWFILE" >> "${DIR_TEMP}/proxy.list"
		continue
	else	# NOTE: everything below this point in this segment is simply to build the dependency list, the actual work is done in the following 'while' loop
		[ "$RESTORE" ] && cd "${REPO_RESTOR}/${RESTORE}"				# change into the restore points directory to get all the requested software and any of its dependencies
# UPDATED 2025/10/22 - using PAK_NAME
#		[ "$UNLOAD" ] && EXEID="$(grep -lH "$RAWFILE" "${DIR_TEMP}/"*)"			# store the cache file containing the software to be uninstalled
		[ "$UNLOAD" ] && EXEID="$(grep -lH "$PAK_NAME" "${DIR_TEMP}/"*)"		# store the cache file containing the software to be uninstalled
		[ "$TREE" ] && {
			echo -e "\n[ DEPENDENTS ]"
# UPDATED 2025/10/22 - no longer using APP* variables
#			echo "${APPNAME}.${APPTYPE}"
			echo "${PAK_NAME}"
# VER2 - update this once we have our own repo
#			echo "${PAK_NAME}[${TYPE}]"
# UPDATED 2025/10/22 - no longer using APP* variables
#			for DEPFILE in $(ls -1 $DIR_CLOG | grep 'deps'$); do			# find any form of the iterated package (e.g. bash.i64.bin.soft, bash.bin, etc) in any installed software .deps file
#				grep -q "${APPNAME}.${APPARCH}.${APPTYPE}.${APPEXTN}" "${DIR_CLOG}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
#				grep -q "${APPNAME}.${APPTYPE}" "${DIR_CLOG}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
#				grep -q "${RAWFILE}" "${DIR_CLOG}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
			for DEPFILE in $(ls -1 $DIR_CLOG | grep ${EXT_HASH}$); do		# find any form of the iterated package (bash.i64.bin.soft, bash[bin], bash) in any installed software .deps file
				grep -q "${PAK_FILE}.${EXT_SOFT}" "${DIR_CLOG}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
# VER2 - update this once we have our own repo
#				grep -q "${APPNAME}.${APPTYPE}" "${DIR_CLOG}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
				grep -q "${PAK_NAME}" "${DIR_CLOG}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
			done
			echo -e "\n[DEPENDENCIES]"
		}
# UPDATED 2025/10/22 - using PAK_NAME
#		processDependencies "${RAWFILE}"
		processDependencies "${PAK_NAME}"
		[ ! "$DEPENDENCY" ] && continue							# if the iterated package has already been installed (via a prior package), then no need to waste resources below...
		[ "$TREE" ] && continue								# if we are simply displaying a dependency tree, then go to the next package in the list
		[ "$VALIDATE" = 'deps' ] && continue						# if we are validating a packages dependencies, then go to the next package
		[ "$VALIDATE" = 'data' ] && { ( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -e "\nValidating the package data..."; }
		[ "$UNLOAD" ] && {								# if we are unloading, then...
			INDEX=1									#   change the INDEX value since we need to reverse the order to process the dependencies
			eval "DEPENDENCY=\$DEP${INDEX}"						#   reset the variable value to the new 'pointer' value of the 'array'
		}
	fi

	[ $DEBUG -gt 1 ] && {
		echo -en "   Do you want to proceed with the action? [Y/N] (N): "
		read
		( [ "$REPLY" = 'Y' ] || [ "$REPLY" = 'y' ] ) || exitGracefully 0
	}

	# now process the dependencies obtained from the above segment!
	while [ "$DEPENDENCY" ] && [ $INDEX -gt 0 ]; do						# while we have a dependency to process via the DEPENDENCY value set by processDependencies() and INDEX adjusted within this loop itself
# UPDATED 2025/10/22 - no longer using APP* variables
#		splitName "$DEPENDENCY"

		# find and change into, the directory containing the package to be processed	  NOTE: the downloadPackage() will make further directory adjustments below
# UPDATED 2025/10/22 - no longer using APP* variables
#		if [ ! "$REPO_SOURCE" ] && [ -e "./${APPFILE}" ]; then								# if no source was provided via '-S' and the pwd has the file (e.g. from a restore point), then...
		if [ ! "$REPO_SOURCE" ] && [ -e "./${PAK_FILE}.${EXT_SOFT}" ]; then						# if no source was provided via '-S' and the pwd has the file (e.g. from a restore point), then...
			SOURCE='local'
		elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'http' || echo "$REPO_SOURCE"|grep -q ^'ftp' ); then	# if a different SOURCE was provided -AND- it is remote, then...
			cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1									# NOTE: we cd into this directory just as a precaution
			DOWNLOAD=TRUE
# UPDATED 2025/10/22 - no longer using APP* variables
#		elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'/' || echo "$REPO_SOURCE"|grep -q ^'./' ) && ( [ -e "${REPO_SOURCE}/${APPFILE}" ] || [ -f "${REPO_SOURCE}/${VERFILE}" ] ); then	# if a different SOURCE was provided -AND- it is a directory -AND- the iterated package exists in the REPO directory, then...	NOTE: the use of -f is required in case VERFILE is blank
		elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'/' || echo "$REPO_SOURCE"|grep -q ^'./' ) && ( [ -e "${REPO_SOURCE}/${PAK_FILE}.${EXT_SOFT}" ] || [ -f "${REPO_SOURCE}/${VERFILE}" ] ); then	# if a different SOURCE was provided -AND- it is a directory -AND- the iterated package exists in the REPO directory, then...	NOTE: the use of -f is required in case VERFILE is blank
			cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1
			unset DOWNLOAD
# UPDATED 2025/10/22 - no longer using APP* variables
#		elif [ -e "${REPO_SYSTEM}/${APPFILE}" ] || [ -f "${REPO_SYSTEM}/${VERFILE}" ]; then				# otherwise check that the file exists in the REPO_SYSTEM...
		elif [ -e "${REPO_SYSTEM}/${PAK_FILE}.${EXT_SOFT}" ] || [ -f "${REPO_SYSTEM}/${VERFILE}" ]; then		# otherwise check that the file exists in the REPO_SYSTEM...
			cd "$REPO_SYSTEM" >>"$LOG_ERRS" 2>&1
			unset DOWNLOAD
		else														# and lastly change to the default REPO_OPTION as a last resort to find the software
			cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1
# UPDATED 2025/10/22 - no longer using APP* variables
#			( [ -e "${REPO_OPTION}/${APPFILE}" ] || [ -f "${REPO_OPTION}/${VERFILE}" ] ) && unset DOWNLOAD || DOWNLOAD=TRUE
			( [ -e "${REPO_OPTION}/${PAK_FILE}.${EXT_SOFT}" ] || [ -f "${REPO_OPTION}/${VERFILE}" ] ) && unset DOWNLOAD || DOWNLOAD=TRUE
		fi

# UPDATED 2025/10/22 - no longer using APP* variables
#		[ $DEBUG -gt 0 ] && { echo -en "  body:\n\tINDEX      :${INDEX}:\n\tDEPENDENCY :${DEPENDENCY}:\n\tAPPFILE    :$APPFILE:\n\tAPPHEAD    :$APPHEAD:\n\tAPPNAME    :$APPNAME:\n\tAPPARCH    :$APPARCH:\n\tAPPTYPE    :$APPTYPE:\n\tAPPEXTN    :$APPEXTN:\n\tVERSION :${VERSION}:\n\tVERFILE    :$VERFILE:\n\tDOWNLOAD  :$DOWNLOAD:\n\tpwd        " >> "$LOG_DBUG"; pwd >> "$LOG_DBUG" 2>>"$LOG_ERRS"; }
		[ $DEBUG -gt 0 ] && { echo -en "  body:\n\tINDEX      :${INDEX}:\n\tDEPENDENCY :${DEPENDENCY}:\n\tPAK_FILE    :${PAK_FILE}:\n\tEXT_SOFT    :${EXT_SOFT}:\n\tVERSION :${VERSION}:\n\tVERFILE    :$VERFILE:\n\tDOWNLOAD  :$DOWNLOAD:\n\tpwd        " >> "$LOG_DBUG"; pwd >> "$LOG_DBUG" 2>>"$LOG_ERRS"; }

		# NOTE: this is a separate 'if' on purpose!	NOTE: these only need to execute if we are NOT validating packages
		if [ ! "$DOWNLOAD" ] && [ ! "$VALIDATE" ]; then
# UPDATED 2025/10/22 - no longer using APP* variables
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${APPFILE}: [local]"
			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${PAK_FILE}.${EXT_SOFT}: [local]"
		elif [ "$DOWNLOAD" ] && [ ! "$VALIDATE" ]; then
# UPDATED 2025/10/22 - no longer using APP* variables
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${APPFILE}: [remote]"
			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${PAK_FILE}.${EXT_SOFT}: [remote]"
			[ "$REPO_TARGET" ] && cd "$REPO_TARGET" >>"$LOG_ERRS" 2>&1 || cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1		# if a different target was specified, then cd into it now, otherwise use the default location!
			downloadPackage || exitGracefully 1
		fi

		# NOTE: this is a separate 'if' on purpose!
		if [ "$COPY" ]; then								# if we're copying package(s), then...
			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [copy]"
			copyPackage || exitGracefully 1
		elif [ "$INSTALL" ]; then							# if we're installing package(s), then...
# REMOVED 2025/10/21 - unsure what this was doing
#			if [ -e "${DIR_CLOG}/${APPFILE}" ]; then						# if we are updating the installed package, then...
# UPDATED 2025/10/08
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [install]"
			( [ "$SILENT" ] || [ "$QUIET" ] ) || {
# UPDATED 2025/10/22 - no longer using APP* variables
#				[ ! -e "${DIR_CLOG}/${APPFILE}" ] && echo -n " [install]"
#				[ -e "${DIR_CLOG}/${APPFILE}" ] && echo -n " [update]"
				[ ! -e "${DIR_CLOG}/${PAK_FILE}.${EXT_SOFT}" ] && echo -n " [install]"
				[ -e "${DIR_CLOG}/${PAK_FILE}.${EXT_SOFT}" ] && echo -n " [update]"
			}
			installPackage || exitGracefully 1
		elif [ "$RESTORE" ]; then							# if we're restoring package(s), then...
			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [restore]"
# UPDATED 2025/10/22 - no longer using APP* variables
#			[ -e "${DIR_CLOG}/${APPFILE}" ] && { unloadPackage || exitGracefully 1; }				# if an undesired version/non-working package is currently installed, remove it now
			[ -e "${DIR_CLOG}/${PAK_FILE}.${EXT_SOFT}" ] && { unloadPackage || exitGracefully 1; }			# if an undesired version/non-working package is currently installed, remove it now
			copyPackage || exitGracefully 1										# copy the restore point packages back into the system
			installPackage || exitGracefully 1									# install that version
		elif [ "$UNLOAD" ]; then							# if we're unloading package(s), then...
			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [unload]"
			unloadPackage || exitGracefully 1
		elif [ "$VALIDATE" ]; then							# if we're validating package(s), then...
			validatePackage || exitGracefully 1
			deleteDependency TRUE
			continue
		fi
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo " [done]"

		deleteDependency								# delete the dependency before assigning the next one below
		[ "$UNLOAD" ] && INDEX=$(( INDEX + 1 ))						# if we are unloading, then we need to reverse the order to process the dependencies
		[ ! "$UNLOAD" ] && INDEX=$(( INDEX - 1 ))					# move the 'pointer' within the $DEP 'array' (instead of calling deleteDependency() since we need those values below)
		eval "DEPENDENCY=\$DEP${INDEX}"							# reset the variable value to the new 'pointer' value of the 'array'
	done
done




# EXECUTE FINAL PROCESSING

# now move the proxy files to the external storage device
if [ "$PROXY" ]; then
	( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "Creating the proxy information: "

	if [ ! -d "${PROXY}/pax" ]; then
		mkdir -p "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The proxy directory does not exist and could not be created." >>"$LOG_ERRS"; exitGracefully 1; }
	fi

# UPDATED 2025/10/23 - since the script contains the actions to take (e.g. download or copy), the script must be copied everytime; this is also helpful if its contents get updated in a future version to not have stale versions of it
#	if [ -e "${DIR_TEMP}/proxy.sh" ]; then							# if the script isn't already on the storage device, then copy it!
		mv "${DIR_TEMP}/proxy.sh" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The device mount point is not writable or invalid." >>"$LOG_ERRS"; exitGracefully 1; }
#	fi
	if [ ! -e "${PROXY}/pax/proxy.list" ]; then						# if the list isn't, then copy it!
		mv "${DIR_TEMP}/proxy.list" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The device mount point is not writable or invalid." >>"$LOG_ERRS"; exitGracefully 1; }
	else											# otherwise, there is so lets add to it!
		cat "${DIR_TEMP}/proxy.list" >> "${PROXY}/pax/proxy.list" 2>>"$LOG_ERRS" || { echo "ERROR: The device mount point is not writable or invalid." >>"$LOG_ERRS"; exitGracefully 1; }
		rm "${DIR_TEMP}/pax/proxy.list" >>"$LOG_ERRS" 2>&1
	fi

	echo " [done]"
	echo
	echo "On another device execute the 'pax/proxy.sh' script that was just created on the"
	echo "removable media to obtain the desired package(s).  Return to this device and use"
	echo "pax to install the files placed on the removable media into this OS."
	echo
	exitGracefully 0
fi

# now update the system that all the packages contents have been installed
if [ "$INSTALL" ] || [ "$RESTORE" ] || [ "$UNLOAD" ]; then					# since these are the only ACTIONs that would require the system to be updated...
	# if any processing so far has determined that a package(s) have kernel modules to process, then...			  NOTE: no need for 'sudo' when booting since the user is root at that time
	if [ "$MODULES" ]; then
		[ $DEBUG -gt 0 ] && echo -e '\tThere are kernel modules to (un)install...' >> "$LOG_DBUG"
		/sbin/depmod -a >>"$LOG_ERRS" 2>&1
		/sbin/udevadm trigger >>"$LOG_ERRS" 2>&1
	fi
	if [ "$LIBRARIES" ]; then
		[ $DEBUG -gt 0 ] && echo -e '\tThere are dynamic libraries to (un)install...' >> "$LOG_DBUG"
		/sbin/ldconfig >>"$LOG_ERRS" 2>&1
	fi
fi

# now call any marker/service scripts (if not unloading which is handled in unloadPackage())
if [ "$INSTALL" ] || [ "$RESTORE" ]; then
	if [ -s ${DIR_TEMP}/installs.list ]; then
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Running deferred install scripts..." | tee -a "$LOG_ERRS"
# UPDATED 2025/10/22 - no longer using APP* variables
#		for APPFILE in $(cat ${DIR_TEMP}/installs.list); do
#			echo "$APPFILE" | tee -a "$LOG_ERRS"
#			"$APPFILE" 2>&1 | tee -a "$LOG_ERRS"
		for FILE in $(cat ${DIR_TEMP}/installs.list); do
			echo "$FILE" | tee -a "$LOG_ERRS"
			"$FILE" 2>&1 | tee -a "$LOG_ERRS"
		done
		rm -f ${DIR_TEMP}/installs.list 2>>"$LOG_ERRS"
	fi
	if [ -s ${DIR_TEMP}/services.list ]; then
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Running deferred service scripts..." | tee -a "$LOG_ERRS"
# UPDATED 2025/10/22 - no longer using APP* variables
#		for APPFILE in $(cat ${DIR_TEMP}/services.list); do
#			echo "$APPFILE" | tee -a "$LOG_ERRS"
#			"$APPFILE" start 2>&1 | tee -a "$LOG_ERRS"
		for FILE in $(cat ${DIR_TEMP}/services.list); do
			echo "$FILE" | tee -a "$LOG_ERRS"
			"$FILE" start 2>&1 | tee -a "$LOG_ERRS"
		done
		rm -f ${DIR_TEMP}/services.list 2>>"$LOG_ERRS"
	fi
fi

exitGracefully 0


#LEFT OFF
# 'sudo pax -v data compiletc' does not work

# ask where to install: system (/), everyone (/Users/Public/.{bin|sbin|lib|...}), personal (/Users/$USER/.{bin|sbin|lib|...})		NOTE: there are no sbin's any more; also /Users/Public is for system-wide usage WITHOUT having elevated installation credentials (compared to system installations to /)
#	how do we address where to install during boot?		maybe utilize .list files for this?

# file	description
# -------------------
# pre	checks that the account has permission to install the value
#	Example values: group	advanced	(to indicate the user needs to be a member of the 'advanced' group to install this package; can issue UI prompt for elevated account status)
#			location /
#
# post	indicates any actions required post-install
#	Example values: device	reboot		(to indicate that a reboot is neccessary to complete install)
#			service	restart		(to indicate a service needs to restart)

