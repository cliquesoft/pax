#!/bin/sh
# pax		a package management system that allows the (un)loading of
#		(pre-compiled) software packages for the (XiniX) OS
#
# created	2016/08/08 by Dave Henderson (support@cliquesoft.org)
# updated	2025/11/12 by Dave Henderson (support@cliquesoft.org)
#
# Unless a valid Cliquesoft Private License (CPLv1) has been purchased for your
# device, this software is licensed under the Cliquesoft Public License (CPLv2)
# as found on the Cliquesoft website at www.cliquesoft.org.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the appropriate Cliquesoft License for details.
#
# NOTES
# - The types of packages include:
#	app	application (installer)
# 	bin	binaries						these pertain to the OS
# 	dev	development
# 	doc	documentation
#	drv	drivers
#	gir	GObject
# 	lib	libraries
# 	loc	locales
#	msc	miscellaneous
#	src	source
#
# 	app	applets							these pertain to web.de				< REMOVED - this needs to be handled by web.de itself
# 	icn	icons
# 	skn	skins
# 	thm	themes
#
# - The package extensions include:
#	code	package source code
#	cpio	ramdisk image
#	deps	dependencies list
#	hash	validation hash
#	info	package information
#	list	manifest list
#	make	compile script
#	mark	unload marker
#	newr	update available
#	repo	available in repo
#	soft	software files
#
# - The .deps files can use the following syntax:
#	dependency.i64.bin.soft						package requires this dependency (any version)
#	dependency.i32.lib.soft[1.2.3]					package requires the stated version of this dependency and will install it beside any other version; useful for software requiring different lib versions (e.g. sdl)
#	[dependency.r64.drv.soft|optional.i64.bin.soft]			package can optionally install this dependency if the device also has 'optional' installed




# REMOVED 2025/10/21 - the only function that was called was getBootcode(), which was added to this script to remove the dependency
## CHECK FOR DEPENDENCIES (no log writting here since no directory checks have been made)
#
#. /etc/software/SYSTEM/FUNCTIONS					# NOTE: this also obtains the variables set in /etc/{envars|enviro}
#
## WARNING: this MUST come after the sourced files above so shared variable values don't leak!!!
## NOTE: the RESTORE variable can contain two different values based if it is used as an ACTION or OPTION
#unset ALL BOOTING COPY DOWNLOAD EXTRA FORCE IGNORE INSTALL NOLIST MAKE MODE ONLY PREFIX PROXY PURGE QUIET RESTORE SILENT TREE UNLOAD VALIDATE VERSION


# MODULE VARIABLE DEFINITIONS

DEBUG=0												# NOTE: making this a '2' will enable prompts

DIR_CONF='/etc/pax'										# directory containing any alternate/personalized configuration

DIR_LIST='/var/cache/Software/catalog'								# directory containing the total list of installed applications
DIR_INIT='/var/cache/Software/services'								# directory containing daemon/service scripts
DIR_INST='/var/cache/Software/scripts'								# directory containing other software scripts (taken from /etc/envars)
DIR_LIVE='/Users/Public'									# directory to install by default after bootup
DIR_LOGS='/var/log'
DIR_LOOP='/tmp/pax/loop'									# directory that symlinked software needs to use as mountpoint
DIR_TEMP='/tmp/pax'

EXT_CODE='code'											# [tgz file] package source code
EXT_DEPS='deps'											# [text file] package dependency list
EXT_HASH='hash'											# [text file] package validation hash
EXT_INFO='info'											# [text file] package information
EXT_LIST='list'											# [text file] package manifest list
EXT_MAKE='make'											# [text file] package make commands
EXT_MARK='mark'											# [text file] package marker files
EXT_SOFT='soft'											# [mksquashfs file] packaged compiled software

LOG_DBUG="${DIR_LOGS}/pax.debug"								# the log file for debug output
LOG_ERRS="${DIR_LOGS}/pax.log"									# the log file for error output

FILE_SCHEMA='${PACKAGE}.${TYPE}.${CPU}'								# the format for the package filenames		NOTE: encase in single quotes so variables are NOT expanded yet
LOOP_SCHEMA='${PACKAGE}.${TYPE}'								# the format for the package mount point	NOTE: same as above
REPO_SCHEMA='http://repo.cliquesoft.org/vanilla/1.0/${PACKAGE/_${KERNEL}}'			# the format for remote packages		NOTE: save as above

REPO_PREFIX='/etc/software/SYSTEM/repo'
REPO_OPTION="${REPO_PREFIX}/optional"								# WARNING: this needs to reference 'optional' and REPO_SYSTEM needs to reference 'system'!!!
REPO_SYSTEM="${REPO_PREFIX}/system"								# if any dependency package(s) are not found in the (modified) REPO_OPTION, then check the 'base' location
REPO_RESTOR="/var/cache/Software/restore"
# REMOVE 2025/11/05 - replaced with REPO_SCHEMA
#REPO_REMOTE='http://repo.cliquesoft.org/vanilla/1.0/${PACKAGE/_${KERNEL}}'			# the source to obtain remote packages from when installing/downloading -AND- the target directory when copying

# -------------------- DO **NOT** EDIT BELOW THIS LINE --------------------

INDEX=0												# since no arrays can be used in this shell, this keeps track of the index within the dependency stack	NOTE: 0=no deps
TOTAL=0												# keeps track of the $DEP 'array' size
# UPDATED 2025/11/10
#EXEID="${DIR_TEMP}/$(mktemp -u XXXXXX)"								# stores a temp execution ID (for use with (un)installing)
EXEID="$(mktemp -u XXXXXX)"									# stores a temp execution ID (for use with (un)installing)
TEMP=''												# used to store information temporarily

LIBRARIES=''											# boolean indicating libraries are contained in the package and need to be loaded after installation
MODULES=''											# boolean indicating kernel modules are contained in the package and need to be loaded after installation

# LEFT OFF - replace CPU with ARCH_SCHEMA so that the variable can be used with naming conventions for both XiniX and TC
CPU="$(uname -m 2>>"$LOG_ERRS" | sed -r 's/i386|i686/i32/;s/x86_64/i64/;s/armv7l/r32/')"	# this can be used so the .deps files can be universal (like KERNEL below) - bash.CPU.bin.soft
TYPE='bin'											# the package type: bin dev doc drv gir lib loc	  NOTE: we're specifying the default value here
KERNEL="$(uname -r 2>>"$LOG_ERRS" | sed 's/-/_/g')"						# store the currently used kernel version (substituting '-' for '_')
#LATEST=							< LEFT OFF - this can be used so the latest version of a branch can be downloaded (e.g. pax -i apache -V 2.2.LATEST)

# MOVED 2025/10/21 - the values can no longer be established here since they rely on functions that haven't been defined yet
#LIST="$( ( checkBootcode list2 && [ -e "${REPO_PREFIX}/$(getBootcode list2)" ] ) && getBootcode list2 || echo 'optional.list')"		# obtains and tests for the existence of the bootloader 'lst' bootcode value -OR- uses a default otherwise
#FLAG="${LIST%.*}.flag"										# the flag file that blacklists included packages
#MODE="$(TEMP="$(getBootcode mode)"; ( [ "$TEMP" = 'conservative' ] || readlink $REPO_PREFIX | grep -q DATA ) && echo 'link' && exit 0; echo 'copy')"	# the install mode: (sym)link, copy	NOTE: symlink by default if we are in a 'conservative' operation mode -OR- we are using DATA as the source of the repo
LIST=''												# stores a specified secondary boot list
FLAG=''												# store an accompanying blacklist flag file for packages that should NOT be installed from the secondary boot list (or their dependencies)
MODE=''												# the install mode: copy, (sym)link	NOTE: symlink by default if we are in a 'conservative' operation mode -OR- we are using DATA as the source of the repo

OUTPUT='text'											# the output format to display: none, text, xml
XML=''												# used to store XML until there's a final success/failure
XML_TAGS=''											# stores the tags that are currently opened (e.g. containing children)

# UPDATED 2025/10/22 - merged -P with -U
#PURGE=0											# indicate no purging is happening by default
PURGE=''											# indicate no purging is happening by default	NOTE: keep this blank as default (indicated we are just unloading and not uninstalling)

PREFIX=''											# where the software should be installed: root=/ (firmware), everyone=/Users/Public, user-specific=$HOME, custom=specified
DEPENDENCY=''											# the current iterated dependency to work with
PACKAGE=''											# the isolated name of the package (e.g. nano.bin.i32.soft > nano); value set automatically below
BASENAME=''											# the filename without the extension (e.g. nano.bin.i32); value set automatically below
FILENAME=''											# the full filename of the package (e.g. nano.bin.i32.soft); value set automatically below
FILETYPE=''											# the file type that is being processed (this is used by processDependencies())
DIRECTORY=''											# defaults to REPO_OPTION if not passed as DIRECTORY parameter
REPO_SOURCE=''			# update to REPO or SOURCE					# if the user passed a new source via -S; defaults to REPO_REMOTE if not passed

VERSION=''
VERBASE=''
VERFILE=''
RAWFILE=''			# rename to PARAMETER
OPTFILE=''
				# the below can all be erased
REPO_TARGET=''			# merge to DIRECTORY						# if the user passed a new target directory as the last passed parameter
DEPFILE=''
APPFILE=''											# e.g. 'bash.i32.bin.soft'
APPHEAD=''											# e.g. 'bash.i32.bin'	(header)
APPNAME=''											# e.g. 'bash'
APPARCH=''											# e.g. 'i32'
APPTYPE=''											# e.g. 'bin'
APPEXTN=''




# -------------------------------------------------------------------------




# DEFINE BUILT-IN FUNCTIONS FOR EXPORT




# DEFINE BUILT-IN FUNCTIONS FOR INTERNAL USE

# Usage syntax: exitGracefully [EXIT] [TARGET] [TAGS] [TAG]
# Overview:	allows the script the terminate gracefully
# Parameters:
# EXIT		[number] [optional] the exit status of this script afterwards
#			0 = success (default)
#	3		1 = failure without printing anything
#	2		2 = failure printing a generic message
#	1		3 = failure with printing ' [failure]'
#			4 = failure printing ' [failure]' and generic message
#			    NOTES:
#			    - the TAG should be passed to close XML
#			    - the TAGS value does not get passed through
# TARGET	[string] [optional] the TARGET value to send to showMsg
# TAGS		[number] [optional] the TAGS value to send to showMsg
# TAG		[string] [optional] the TAG value to send to showMsg
exitGracefully() {
	find "$DIR_TEMP" -size 0 -print0 | xargs -0 rm 2>/dev/null				# remove any blank cache file	https://stackoverflow.com/questions/3157343/how-to-delete-many-0-byte-files-in-linux
	rm -f "${DIR_LIST}/"*.${EXT_MARK} 2>/dev/null						# remove any .marker files
	[ $DEBUG -eq 0 ] && rm -f "${DIR_TEMP}/installs.${EXEID}" 2>/dev/null					# remove any installation temp files
	[ $DEBUG -eq 0 ] && rm -f "${DIR_TEMP}/services.${EXEID}" 2>/dev/null
	[ $DEBUG -eq 0 ] && rm -f "${DIR_TEMP}/filelist.${EXEID}" 2>/dev/null
	[ "$MODE" = 'copy' ] && [ $1 -gt 0 ] && sudo /bin/umount "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1	# if we're copying and an error was encountered, then umount the package

	( [ ! "$1" ] || [ $1 -eq 0 ] ) && exit 0

	[ $1 -gt 2 ] && {
#echo "top |$3|"
		[ ! "$4" ] && showMsg 'failure' ' [failure]' "$2" 1 "$3"
		[ "$4" ] && showMsg "$4" ' [failure]' "$2" 1 5
	}
	( [ $1 -eq 2 ] || [ $1 -eq 4 ] ) && {
#echo btm
# UPDATED 2025/11/07 - this should only be displayed to the screen, as an error message will be sent to the log
		[ ! "$4" ] && showMsg 'failure' 'An error occurred while processing your request.' "$2" 1 "$3"
		[ "$4" ] && showMsg 'failure' 'An error occurred while processing your request.' "$2" 1 6
#		[ ! "$4" ] && showMsg 'failure' 'An error occurred while processing your request.' 'screen' 1 "$3"
#		[ "$4" ] && showMsg 'failure' 'An error occurred while processing your request.' 'screen' 1 1
	}
	exit $1
}


# Usage syntax: showMsg TAG MESSAGE [TARGET] [CR] [TAGS] [TRIM]
# Overview:	sends message to the target in the desired format
# Parameters:
# TAG		[string] the XML tag surrounding the message
#		[ NOTE ]
#			 - this value can be 'success' or 'failure' to a quick '<s><msg>MESSAGE</msg></s>' (or corresponding fail)
#			 - you can append a '|success' or '|failure' for a final message to denote the overall action status			< delete
#			 - the * represents whatever you pass as the value becomes the XML tag (e.g. 'step' becomes <step>...</step>)
#			 - the * has no effect for plain text
#			 - a blank value is also permitted, which doesn't print any tags with XML, and no prefix for plain text			< delete
#			 - a value of 'HEADER' will also print the XML header and not include the message in XML tags				< delete
# MESSAGE	[string] the message to display/store
# TARGET	[string] [optional] the target output: both (default), log, screen
#		[ NOTE ]
#			- if DEBUG>0 then 'log' will output to that log also
# CR		[boolean][optional] if the prompt needs to add a character return at the end [0=no, 1=yes (default)]
# TAGS		[number] [optional] defines XML tag encapsulation (default=1)
#		[ NOTE ]
#			 0 = none
#	1		 1 = on (one set of tags)	line 1		to	<TAG>line 1
#							line 2			      line 2</TAG>
#	3		 2 = on (tags for each line)	line 1		to	<TAG>line 1</TAG>
#							line 2			<TAG>line 2</TAG>
#	2		 3 = on (parent open) 		title		to	<TAG>title
#	5		 4 = on (parent alt open)	title		to	<TAG tag='title'>
#	4		 5 = on (parent close)		title		to	</TAG>		NOTE: this is ignored when OUTPUT='text'
#			 6 = on (closes all open)
# TRIM		[boolean][optional] if the output needs to be trimmed of spaces, tabs, newlines at the beginning and end (default=off)
showMsg() {
	local LINE=''
	local ITEM=''
	local PREFIX=''
	local SUFFIX=''
	local TAG="$1"
	local MSG="$2"
	local TARGET='both'
	local CR=''
	local TAGS=1
	local TRIM=0
	local TEMP=''
#echo "TAG  |$TAG|"
	# DEFINE DEFAULT VALUES
	[ "$3" ] && [ "$3" != '' ] && TARGET="$3"						# NOTE: we had to include the "!= ''" condition for exitGracefully (since it can pass a blank value)
	[ "$4" ] && [ $4 -eq 0 ] && CR="n"
	[ "$5" ] && TAGS=$5
	[ "$6" ] && TRIM=$6
#echo "CR   |$CR|"
#echo "TAGS |$TAGS|"
	# MAKE VARIABLE CHANGES
	[ "$TAG" = 'failure' ] && TEMP='ERROR: '						# this needs to execute regardless of OUTPUT value since this is for the logs
	[ "$TAG" = 'warning' ] && TEMP='ALERT: '						# this needs to execute regardless of OUTPUT value since this is for the logs

	# OUTPUT TO LOG
	[ "$TARGET" != 'screen' ] && {
		echo -e${CR} "${TEMP}${2}" >>"$LOG_ERRS"					# writes to log if value is: both, log		NOTE: we use $2 instead of $MSG to prevent '<br />' contamination
		[ $DEBUG -gt 0 ] && [ "$TARGET" = 'log' ] && echo -e${CR} "${TEMP}${2}" >>"$LOG_DBUG"
	}
	( [ "$SILENT" ] || [ "$QUIET" ] ) && return 1						# if we need to be quiet or silent, then no visual, but write to log if desired
	[ "$TARGET" = 'log' ] && return 1							# if we're only logging messages, then we can exit

	# ADJUST MESSAGE AND OUTPUT TO SCREEN
	if [ "$OUTPUT" = 'fifo' ]; then
# UPDATED 2025/10/30
#		[ $TAGS -gt 4 ] && return 1
		[ $TAGS -eq 6 ] && return 1

		[ "$TAG" = 'failure' ] && [ "$MSG" != ' [failure]' ] && PREFIX='ERROR: '	# NOTE: the MSG comparison is so that if exitGracefully() was called, then we don't need the prefix
		IFS=$'\n'
		for LINE in $(echo -e "${PREFIX}${MSG}${SUFFIX}"); do				# convert a multi-line MESSAGE (e.g. 'LINE1\nLINE2') into separate 'echo' calls
			echo "$LINE" | sed 's/^\s*//;s/\s*$//' >"${DIR_TEMP}/output"		# also strip pre/post spacing (spaces, tabs) since FIFO's can't handle any of this
		done
	elif [ "$OUTPUT" = 'text' ]; then
# UPDATED 2025/10/30
#		[ $TAGS -gt 4 ] && return 1
		[ $TAGS -eq 6 ] && return 1

		[ "$TAG" = 'failure' ] && [ "$MSG" != ' [failure]' ] && PREFIX='ERROR: '	# NOTE: the MSG comparison is so that if exitGracefully() was called, then we don't need the prefix
		echo -e${CR} "${PREFIX}${MSG}${SUFFIX}"
	elif [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ]; then
		# PROCESS OPENED TAGS
		# if the tag is present after the first one in the list, then we need to close all the tags before it
		if ( echo "$XML_TAGS" | grep -qE " $TAG " ); then
#echo inside
			for ITEM in $(echo "$XML_TAGS"); do
				TEMP="$(echo "$XML_TAGS" | sed -E 's/ $//;s/[a-z]+/\\t/g;s/ //g')" # create the proper preceeding tabs
				XML_TAGS="$(echo "$XML_TAGS" | sed "s/^${ITEM} //")"		# remove the iterated TAG from the list
				PREFIX="${PREFIX}${TEMP}</${ITEM}>\n"				# update the PREFIX to include each closing TAG
				[ "$ITEM" = "$TAG" ] && break					# exit the 'for' as soon as we process the matching TAG
			done
		fi
		# WARNING: these are two separate 'if' statements on purpose!
		# if we're opening a new tag -AND- the tag is NOT already in the opened list, then add it to the beginning of the list
		if ( [ $TAGS -eq 3 ] || [ $TAGS -eq 4 ] ) && [ "$(echo "$XML_TAGS" | cut -f 1 -d ' ')" != "$TAG" ]; then
#echo "top |$TAG|"
			XML_TAGS="$TAG $XML_TAGS"
		# if we're opening a new tag -AND- the tag IS the first one in the opened list, then close the prior one first
		elif ( [ $TAGS -eq 3 ] || [ $TAGS -eq 4 ] ) && [ "$(echo "$XML_TAGS" | cut -f 1 -d ' ')" = "$TAG" ]; then
			TEMP="$(echo "$XML_TAGS" | sed -E 's/ $//;s/[a-z]+/\\t/g;s/ //g')"
			PREFIX="${PREFIX}${TEMP}</${TAG}>\n"
		# if we're closing an open tag -AND- the tag IS the first one in the list, then delete it from the list
		elif [ $TAGS -eq 5 ] && [ "$(echo "$XML_TAGS" | cut -f 1 -d ' ')" = "$TAG" ]; then
#echo mid
			XML_TAGS="$(echo "$XML_TAGS" | sed "s/^${TAG} //")"
		fi
#echo "prefix |$PREFIX|"
#echo "XML_TAGS |$XML_TAGS|"
#echo "TEMP |$TEMP|"
		# PROCESS TAG AND INDENTATION							  NOTE: this MUST come below the 'PROCESS OPENED TAGS' section
		TEMP="$(echo "$XML_TAGS" | sed -E 's/ $//;s/[a-z]+/\\t/g;s/ //g')"
# UPDATED 2025/11/06
#		[ "$XML_TAGS" ] && [ $TAGS -lt 3 ] && TEMP="\t${TEMP}"
		[ "$XML_TAGS" ] && [ $TAGS -lt 3 ] && TEMP="\t${TEMP}"
		case "$TAGS" in
			0)	PREFIX=''							# if no tags are to be displayed (e.g. the MESSAGE contains them)
				SUFFIX=''
				;;
			1|2)	PREFIX="${PREFIX}${TEMP}<${TAG}>"				# if both opening and closing tags need to be displayed
				SUFFIX="</${TAG}>"
				;;
			3)	[ ! "$CR" ] && PREFIX="${PREFIX}${TEMP}<${TAG}>\n${TEMP}\t"	# if only the opening tag needs to be displayed
				[ "$CR" ] && PREFIX="${PREFIX}${TEMP}<${TAG}>"			#   WARNING: the CR detection here is backwards since a value of 'n' means NOT to CR!
				SUFFIX=''
				;;
			4)	PREFIX="${PREFIX}${TEMP}<${TAG} tag=\"$(echo -e "$2" | sed 's|^\s*||;s|\s*$||;/^$/d')\">"	# if only the alt opening tag needs to be displayed
				SUFFIX=''
				MSG=''								#   erase this value since it's already been added to the output
				;;
			5)	PREFIX=''							# if only the closing tag needs to be displayed; this is typically used to close an open tag on the same line (e.g. "<action>Doing some action: [done]</action>")
				SUFFIX="</${TAG}>"
				;;
			6)	PREFIX=''							# if all the closing tags need to be displayed
				for ITEM in $(echo "$XML_TAGS"); do
					SUFFIX="${SUFFIX}${TEMP}</${ITEM}>\n"
					XML_TAGS="$(echo "$XML_TAGS" | sed "s/^${ITEM} //")"
					TEMP="$(echo "$XML_TAGS" | sed -E 's/ $//;s/[a-z]+/\\t/g;s/ //g')"
				done
				[ "$OUTPUT" = 'xml' ] && XML="${XML}${SUFFIX}"
# MOVED 2025/10/30 - moved below
#				[ "$OUTPUT" = 'xmLive' ] && SUFFIX="${SUFFIX}</xml>"
				[ "$OUTPUT" = 'xmLive' ] && SUFFIX="$(echo "${SUFFIX}" | sed 's/\\n$//')"			# cleans up trailing blank line in output
				;;
		esac
#echo "P/S |$PREFIX|$SUFFIX|"
		# APPLY TRIM AND TAG ENCAPSULATE
		if [ $TRIM -eq 0 ]; then							# if we're leaving the output untrimmed, then...
#echo not-trimming
			[ $TAGS -lt 2 ] && MSG="$(echo "$MSG" | sed ':a;N;$!ba;s|\n|<br />|g')"	# replace any CR's with <br />'s		https://stackoverflow.com/questions/1251999/how-can-i-replace-each-newline-n-with-a-space-using-sed
			[ $TAGS -eq 2 ] && MSG="$(echo "$MSG" | sed ":a;N;\$!ba;s|\n|${SUFFIX}\n${PREFIX}|g")"	# replace any CR's with XML tags (plus indentation)
		else										# otherwise, do the same as above, but apply trimming
#echo trimming
			[ $TAGS -lt 2 ] && {
				MSG="$(echo "$MSG" | sed 's|^\s*||;s|\s*$||')"			# trim pre/post spacing
				MSG="$(echo -e "$MSG" | sed '/^$/d')"				# removes any blank lines
				MSG="$(echo -e "$MSG" | sed ':a;N;$!ba;s|\n\s*|<br />|g')"	# convert CR's to <br />'s
			}
			[ $TAGS -eq 2 ] && {
				MSG="$(echo "$MSG" | sed "s|^\s*||;s|\s*$||")"
				MSG="$(echo -e "$MSG" | sed '/^$/d')"
				MSG="$(echo -e "$MSG" | sed ":a;N;\$!ba;s|\n\s*|${SUFFIX}\n${PREFIX}|g")"
			}
			[ $TAGS -gt 2 ] && MSG="$(echo "$MSG" | sed 's|^\s*||;s|\s*$||')"
		fi
#echo afterwards

		# PROCESS XML
		[ "$OUTPUT" = 'xmLive' ] && {
			[ "$TAG" = 'failure' ] && [ $TAGS -eq 6 ] && PREFIX='<failure>' && SUFFIX="</failure>\n${SUFFIX}"	# for exitGracefully calls that need to close open tags while still showing <failure>
			[ "$TAG" = 'failure' ] && [ "$XML_TAGS" = '' ] && PREFIX="\t${PREFIX}"	# for inline failure calls
			[ "$TAG" = 'success' ] && [ "$XML_TAGS" = '' ] && PREFIX="${PREFIX}"	# for inline failure calls
			[ "${PREFIX}${MSG}${SUFFIX}" != '' ] && echo -e${CR} "${PREFIX}${MSG}${SUFFIX}"				# to prevent blank lines from showing in output
			( [ "$TAG" = 'success' ] || [ "$TAG" = 'failure' ] || [ $TAGS -eq 6 ] ) && echo '</xml>'
		}
		if [ "$OUTPUT" = 'xml' ]; then
			if [ "$TAG" = 'success' ]; then
				( echo "$XML" | grep -q '\\n' ) && echo -e "<s>\n    <xml>\n${XML}    </xml>\n</s>" || echo -e "<s>${XML}</s>"
			elif [ "$TAG" = 'failure' ]; then
				echo -e "<f><msg>${MSG}</msg></f>"
			else
				( ( [ $TAGS -eq 3 ] || [ $TAGS -eq 0 ] ) && [ "$CR" ] ) && CR='' || CR='\n'
#echo "cr |$CR|$MSG|"
				XML="${XML}${PREFIX}${MSG}${SUFFIX}${CR}"
#echo -e "XML:\n$XML"
			fi
		fi
	fi
}


# Usage syntax: checkBootcode CODE
# Overview:	checks if a passed boot code was specified
# Parameters:
# CODE		[string] the name of the boot code to check for
checkBootcode() {
	case "$(cat /proc/cmdline)" in
		*" $1"*) return 0 ;;
	esac
	return 1
}


# Usage syntax: getBootcode CODE
# Overview:	stores the value of a passed boot code in $VALUE, or blank otherwise
# Parameters:
# CODE		[string] the name of the boot code to return its value
getBootcode() {
	local CMDLINE="$(cat /proc/cmdline)"
	local VALUE="${CMDLINE##* $1=}"			# remove everything before the bootcode declaration (e.g. 'quiet waitusb=5 tce=...' > '5 tce=...')
	VALUE="${VALUE%%[   ]*}"			# remove everything afterwards to isolate just the bootcode value (e.g. '5 tce=...' > '5')
	echo "$VALUE"
	return 0
}


# Usage syntax: splitName NAME EXTENSION
# Overview:	seperates/creates the passed name into its various parts
# Parameters:
# NAME		[string] the name of the package to parse (e.g. bash.i64.dev.soft)
# EXTENSION	[string] [optional] the file extension to process (EXT_SOFT is default)
splitName() {
	local PARAMETER="${1##*/}"								# remove any directory structure and store the raw parameter value
	local EXT="${EXT_SOFT}"
	local TEMP=''

	[ ! "$PARAMETER" ] && {
		showMsg 'failure' "No package names could be found." 'screen' 1 1
		return 1
	}
	[ "$2" ] && EXT="$2"

	# WARNING: this 'if' must be in the order it is to process correctly
	if ( echo "$PARAMETER" | grep -q ^'\[' ); then						# if an optional package (e.g. [xorg_3d.i32.bin.soft|xorg.bin]) was passed, then...
		VERSION=''									#   erase any existing value from this variable to prevent bugs
		OPTFILE="$(echo "$PARAMETER" | sed 's/^\[//;s/\]$//;s/.*|//')"			#   remove the brackets and store just the optional package (xorg.bin)
		PARAMETER="$(echo "$PARAMETER" | sed 's/^\[//;s/\]$//;s/|.*//')"		#   remove the brackets and store just the dependency name (xorg_3d.i32.bin.soft)
	elif ( echo "$PARAMETER" | grep -q '\]'$ ); then					# if a version number has been included (e.g. bash.bin[4.0.2]) in the name, then...
		VERSION="$(echo "$PARAMETER" | sed 's/.*\[//;s/\]$//')"				#   store just the included version number (4.0.2)
		OPTFILE=''									#   erase any existing value from this variable to prevent bugs
		PARAMETER="${PARAMETER%%[*}"							#   remove the version number and store just the name (bash.bin)
	else											# otherwise just a package name was passed, so erase any existing values to prevent bugs
		VERSION=''
		OPTFILE=''
	fi

#echo "raw  |$PARAMETER|"
	if ( echo "$PARAMETER" | grep -q "$EXT"$ ); then					# if the whole filename was passed, then...
		TEMP="${FILE_SCHEMA#*\}}"							#   remove just the package name portion from the package filename 'schema' - everything before the first '}' character
#echo "temp |$TEMP|"
		TEMP="$(echo "$TEMP" | sed 's/\./\\\\\./g;s/${TYPE}/.../')"			#   escape any periods in the schema and replace TYPE with three dots (to match any TYPE - bin,dev,doc,...)
# UPDATED 2025/10/31 - so that the VERFILE assignment below works correctly
#		eval TEMP="${TEMP}\\\\.${EXT_SOFT}"						#   eval the variable to get any variable substitution done (except TYPE which was replaced by three dots) and add the extension
		eval TEMP="${TEMP}"								#   eval the variable to get any variable substitution done (except TYPE which was replaced by three dots)
#echo "temp2 |$TEMP|"
# UPDATED 2025/10/31 - so that the VERFILE assignment below works correctly
#		PACKAGE="$(echo $PARAMETER | sed "s/${TEMP}$//")"				#   remove the TEMP string that was just created to isolate just the package name
		PACKAGE="$(echo $PARAMETER | sed "s/${TEMP}\.${EXT}$//")"			#   remove the TEMP string that was just created to isolate just the package name
# MERGED 2025/11/05
#		BASENAME="$(echo $PARAMETER | sed "s/.${EXT_SOFT}$//")"				#   remove the file extension from the name
#		BASENAME="$(echo $BASENAME | sed "s/KERNEL/${KERNEL}/")"			#   lastly, perform the KERNEL keyword substitution
		BASENAME="$(echo $PARAMETER | sed "s/.${EXT}$//;s/KERNEL/${KERNEL}/")"		#   remove the file extension from the name and perform the KERNEL keyword substitution
		FILENAME="$PARAMETER"

# UPDATED 2025/11/05
#		# this is for the VERFILE assignment below
#		TEMP="$(echo $FILENAME | sed "s/^${PACKAGE}//")"				#   remove the PACKAGE name from the FILENAME and store it
	else											# otherwise just the package name was, so...
# REMOVED 2025/10/31 - this is supposed to be for just the package names being passed so no altering should be necessary
#		TEMP="${FILE_SCHEMA#*\}}"							#   remove just the package name portion from the package filename 'schema' - everything before the first '}' character
#		eval TEMP="${TEMP}.${EXT_SOFT}"							#   combine the 'schema' (less the package name) values and the file extension value (e.g. i32.bin.soft)
#echo "temp |$TEMP|"
#echo $PARAMETER | sed "s/${TEMP}//"
#		PACKAGE="$(echo $PARAMETER | sed "s/${TEMP}//")"				#   remove that combination from the passed package name (in case it was passed like bash.i32.bin.soft) to isolate just the package name (e.g. bash)
# UPDATED 2025/10/31 - FILENAME would not have a value yet
#		FILENAME="$(echo $FILENAME | sed "s/KERNEL/${KERNEL}/")"			#   perform the KERNEL keyword substitution
		PACKAGE="$(echo $PARAMETER | sed "s/KERNEL/${KERNEL}/")"			#   perform the KERNEL keyword substitution against the passed package name
		eval BASENAME="${FILE_SCHEMA}"							#   eval the variable to get any variable substitution done
		FILENAME="${BASENAME}.${EXT}"

# UPDATED 2025/11/05
#		# this is for the VERFILE assignment below
#		TEMP="${FILE_SCHEMA#*\}}"							#   remove just the package name portion from the package filename 'schema' - everything before the first '}' character
#		eval TEMP="${TEMP}.${EXT_SOFT}"							#   combine the package filename 'schema' (less the package name) and the file extension value (e.g. i32.bin.soft)
	fi
	FILETYPE="$(echo "$FILENAME" | grep -oE '[\._\-](bin|dev|doc|drv|gir|lib|loc)' | sed -E 's/^[\._\-]//')"			# search for any variation of known type abbreviations and remove the preceeding separation character
	[ "$FILETYPE" = '' ] && FILETYPE="$TYPE"					#   if the line above did not return any value, then default to whatever is specified as TYPE

	[ "$VERSION" ] && VERBASE="${VERSION}$(echo $BASENAME | sed "s/^${PACKAGE}//")" || VERBASE=''				# replace the package name with the version number (e.g. 2025.04.10.i32.bin.soft)	WARNING: this MUST come after the above assignments so the proper values are created
# UPDATED 2025/11/05
#	[ "$VERSION" ] && VERFILE="${VERSION}${TEMP}" || VERFILE=''				# replace the package name with the version number (e.g. 2025.04.10.i32.bin.soft)	WARNING: this MUST come after the above assignments so the proper values are created
	[ "$VERSION" ] && VERFILE="${VERBASE}.${EXT}" || VERFILE=''				# replace the package name with the version number (e.g. 2025.04.10.i32.bin.soft)	WARNING: this MUST come after the above assignments so the proper values are created

#echo "name |$PACKAGE|"
#echo "base |$BASENAME|"
#echo "file |$FILENAME|"
#echo "type |$FILETYPE|"
#echo "optf |$OPTFILE|"
#echo "ver  |$VERSION|"
#echo "verb |$VERBASE|"
#echo "verf |$VERFILE|"

return 1
# REMOVED 2025/10/21 - to now be more versatile with package names
	local RAWFILE="${1##*/}"								# remove any directory structure and store the raw parameter value

	if ( echo "$RAWFILE" | grep -q ^'\[' ); then						# if an optional package (e.g. [xorg_3d.i32.bin.soft|xorg.bin]) was passed, then...
		APPFILE="$(echo "$RAWFILE" | sed 's/^\[//;s/\]$//;s/|.*//')"			#   store just the name (xorg_3d.i32.bin.soft)
		OPTFILE="$(echo "$RAWFILE" | sed 's/^\[//;s/\]$//;s/.*|//')"			#   store just the optional package (xorg.bin)
		VERSION=''									#   erase any existing value from this variable to prevent bugs
	elif ( echo "$RAWFILE" | grep -q '\]'$ ); then						# if a version number has been included (e.g. bash.bin[4.0.2]) in the name, then...
		APPFILE="${1%%[*}"								#   store just the name (bash.bin)
		OPTFILE=''									#   erase any existing value from this variable to prevent bugs
		VERSION="$(echo "$1" | sed 's/.*\[//;s/\]$//')"					#   store just the included version number (4.0.2)
	else
		APPFILE="$1"									#   store just the name (bash.bin)
		OPTFILE=''									#   erase any existing values from these variables to prevent bugs
		VERSION=''
	fi

	[ "${APPFILE##*.}" != 'soft' ] && APPFILE="${APPFILE}.${CPU}.bin.soft"			# if the user only entered the name (e.g. pax -d bash), then we need to apply best-guesses to the other parts of the filename
	APPFILE="${APPFILE/CPU/${CPU}}"								# perform the CPU keyword substitution 			WARNING: these must be processed in the order shown
	APPFILE="${APPFILE/KERNEL/${KERNEL}}"							# perform the KERNEL keyword substitution
	APPHEAD="${APPFILE%.*}"									# e.g. 'bash.i32.bin'		header
	APPNAME="$(echo "$APPFILE" | head -c -14)"						# e.g. 'bash'			package name
	APPARCH="$(echo "$APPFILE" | tail -c 13 | head -c 3)"					# e.g. 'i32'			package CPU architecture
	APPTYPE="${APPHEAD##*.}"								# e.g. 'bin'			package type
	APPEXTN="${APPFILE##*.}"								# e.g. 'soft'			package extension
	[ "$VERSION" ] && VERFILE="${VERSION}.${APPARCH}.${APPTYPE}.${APPEXTN}" || VERFILE=''	# WARNING: this MUST come after the above assignments so the proper values are created
}


# Usage syntax: proxyAction
# Overview:	proxy's the action by creating a temporary shell script to execute on another device
# Notes:	https://unix.stackexchange.com/questions/22623/extract-middle-section-of-lines-of-a-text-file
#		https://unix.stackexchange.com/questions/2072/whats-the-best-way-to-take-a-segment-out-of-a-text-file
proxyAction() {
	( [ -e "${DIR_TEMP}/proxy.sh" ] || [ -e "${PROXY}/proxy.sh" ] ) && return 0		# if the script is already generated, we can skip re-creating it again

	echo '#!/bin/sh' > "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo '# Variable Declarations' >> "${DIR_TEMP}/proxy.sh"
	echo -e "COPY=${COPY}\nDOWNLOAD=${DOWNLOAD}${INSTALL}\nDEBUG=0\nEXTRA=${EXTRA}\nINDEX=0\nTOTAL=0\n" >> "${DIR_TEMP}/proxy.sh"
	echo -e "LOG_ERRS=\"\$(pwd)/proxy.log\"\nFLAG='proxy.flag'\nTEMP=''\n" >> "${DIR_TEMP}/proxy.sh"
	echo -e "REPO_PREFIX=\"\$(pwd)\"\nREPO_OPTION=\"\${REPO_PREFIX}/Software\"\nREPO_SYSTEM=\"\${REPO_PREFIX}/Software\"\nREPO_REMOTE='${REPO_REMOTE}'\nREPO_SOURCE='${REPO_SOURCE}'\nREPO_TARGET='${REPO_TARGET}'\n" >> "${DIR_TEMP}/proxy.sh"
	echo -e "CPU='${CPU}'\nKERNEL='${KERNEL}'\n" >> "${DIR_TEMP}/proxy.sh"
	echo -e "DEPENDENCY=''\nVERSION=''\nVERFILE=''\nRAWFILE=''\nOPTFILE=''\nDEPFILE=''\nAPPFILE=''\nAPPHEAD=''\nAPPNAME=''\nAPPARCH=''\nAPPTYPE=''\nAPPEXTN=''" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo '# Function Declarations' >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^exitGracefully()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"				# https://stackoverflow.com/questions/6916856/can-bash-show-a-functions-definition
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^splitName()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^addDependency()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^deleteDependency()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^processDependencies()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^copyPackage()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	sed -n '/^downloadPackage()/,/^}/p' "$0" | sed 's/[ \t]*# .*//' >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo '# Directory Checks' >> "${DIR_TEMP}/proxy.sh"
	echo "if [ ! -d \"\$REPO_OPTION\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "	mkdir -p \"\$REPO_OPTION\" >>\"\$LOG_ERRS\" 2>&1 || { echo \"ERROR: The storage directory (REPO_OPTION) does not exist and could not be created.\" | tee -a \$LOG_ERRS; exit 1; }" >> "${DIR_TEMP}/proxy.sh"
	echo "fi" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo '# Start Execution' >> "${DIR_TEMP}/proxy.sh"
	echo "for RAWFILE in \$(cat proxy.list); do" >> "${DIR_TEMP}/proxy.sh"
	echo "	processDependencies \"\${RAWFILE}\"" >> "${DIR_TEMP}/proxy.sh"
	echo "	[ ! \"\$DEPENDENCY\" ] && continue" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo "	while [ \"\$DEPENDENCY\" ] && [ \$INDEX -gt 0 ]; do" >> "${DIR_TEMP}/proxy.sh"
	echo "		splitName \"\$DEPENDENCY\"" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo "		if [ ! \"\$REPO_SOURCE\" ] && [ -e \"./\${APPFILE}\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "			SOURCE='local'" >> "${DIR_TEMP}/proxy.sh"
	echo "		elif [ \"\$REPO_SOURCE\" ] && ( echo \"\$REPO_SOURCE\"|grep -q ^'http' || echo \"\$REPO_SOURCE\"|grep -q ^'ftp' ); then" >> "${DIR_TEMP}/proxy.sh"
	echo "			cd \"\$REPO_OPTION\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			DOWNLOAD=TRUE" >> "${DIR_TEMP}/proxy.sh"
	echo "		elif [ \"\$REPO_SOURCE\" ] && ( echo \"\$REPO_SOURCE\"|grep -q ^'/' || echo \"\$REPO_SOURCE\"|grep -q ^'./' ) && ( [ -e \"\${REPO_SOURCE}/\${APPFILE}\" ] || [ -f \"\${REPO_SOURCE}/\${VERFILE}\" ] ); then" >> "${DIR_TEMP}/proxy.sh"
	echo "			cd \"\$REPO_SOURCE\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			unset DOWNLOAD" >> "${DIR_TEMP}/proxy.sh"
	echo "		elif [ -e \"\${REPO_SYSTEM}/\${APPFILE}\" ] || [ -f \"\${REPO_SYSTEM}/\${VERFILE}\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "			cd \"\$REPO_SYSTEM\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			unset DOWNLOAD" >> "${DIR_TEMP}/proxy.sh"
	echo "		else" >> "${DIR_TEMP}/proxy.sh"
	echo "			cd \"\$REPO_OPTION\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			( [ -e \"\${REPO_OPTION}/\${APPFILE}\" ] || [ -f \"\${REPO_OPTION}/\${VERFILE}\" ] ) && unset DOWNLOAD || DOWNLOAD=TRUE" >> "${DIR_TEMP}/proxy.sh"
	echo "		fi" >> "${DIR_TEMP}/proxy.sh"
	echo >> "${DIR_TEMP}/proxy.sh"
	echo "		if [ \"\$DOWNLOAD\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "			( [ \"\$SILENT\" ] || [ \"\$QUIET\" ] ) || echo -n \"\${APPFILE}: [remote] [download]\"" >> "${DIR_TEMP}/proxy.sh"
	echo "			[ \"\$REPO_TARGET\" ] && cd \"\$REPO_TARGET\" >>\$LOG_ERRS 2>&1 || cd \"\$REPO_OPTION\" >>\$LOG_ERRS 2>&1" >> "${DIR_TEMP}/proxy.sh"
	echo "			downloadPackage || exitGracefully 1" >> "${DIR_TEMP}/proxy.sh"
	echo "		elif [ \"\$COPY\" ]; then" >> "${DIR_TEMP}/proxy.sh"
	echo "			( [ \"\$SILENT\" ] || [ \"\$QUIET\" ] ) || echo -n \"\${APPFILE}: [local] [copy]\"" >> "${DIR_TEMP}/proxy.sh"
	echo "			copyPackage || exitGracefully 1" >> "${DIR_TEMP}/proxy.sh"
	echo "		fi" >> "${DIR_TEMP}/proxy.sh"
	echo "		( [ \"\$SILENT\" ] || [ \"\$QUIET\" ] ) || echo \" [done]\"" >> "${DIR_TEMP}/proxy.sh"
	echo "		deleteDependency TRUE" >> "${DIR_TEMP}/proxy.sh"
	echo "	done">> "${DIR_TEMP}/proxy.sh"
	echo "done">> "${DIR_TEMP}/proxy.sh"

	chmod 755 "${DIR_TEMP}/proxy.sh"
}


# Usage syntax: addDependency FILENAME
# Overview:	adds the passed package name onto the top of the stack of dependencies
# Parameters:
# FILENAME	[string] the package name that needs to be added to the stack
addDependency() {
	[ $DEBUG -gt 0 ] && echo -e "addDependency (old):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|" >>"$LOG_DBUG"

#echo "INDEX is 1 |$INDEX|"
	INDEX=$(( INDEX + 1 ))
#echo "INDEX is 2 |$INDEX|"
	TOTAL=$(( TOTAL + 1 ))
	eval "DEP${INDEX}=$1"									# NOTE: since busybox shell (ash) can't handle arrays (ugh!), we have to use this work around...
	eval "DEPENDENCY=\$DEP${INDEX}"

	[ $DEBUG -gt 0 ] && echo -e "addDependency (new):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|" >>"$LOG_DBUG"
}


# Usage syntax: deleteDependency [DECREASE]
# Overview:	deletes the top-most (last added) package from the stack of dependencies
# Parameters:
# DECREASE	[boolean] if the INDEX variable needs to be decreased by 1
deleteDependency() {
	[ $DEBUG -gt 0 ] && echo -e "deleteDependency (old):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|" >>"$LOG_DBUG"

	eval "unset DEP${INDEX}"
	[ "$1" ] && INDEX=$(( INDEX - 1 ))							# if we need to decrease the INDEX value, then do so!
	[ "$INDEX" -eq 0 ] && { unset DEPENDENCY; return 0; }					# if there isn't anything in the stack, delete the variable and exit
	[ "$1" ] && eval "DEPENDENCY=\$DEP${INDEX}"

	[ $DEBUG -gt 0 ] && echo -e "deleteDependency (new):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|" >>"$LOG_DBUG"
}


# Usage syntax: processDependencies PACKAGE [INDENT]
# Overview:	adds all the dependencies for the passed package onto the stack of dependencies to be installed
# Notes:	pwd is mostly irrelevent to this function as it will dynamically change internally					< DELETE this
# Notes:	the directory containing the file(s)-to-copy should already be entered BEFORE calling this function!
# Parameters:
# PACKAGE	[string] the package name that is being installed
# INDENT	[string] [optional] passed tabs (e.g. '\t\t') to indent the output (for the -t switch)
processDependencies() {
	local SOURCE=''
#	local TARGET=''
#	local RELEASE										# used to indicate that the iterated dependency is released to be unloaded
#	local DIR=''
	local DEPFILE
	local DEPBASE
	local DEPNAME
	local DEPTYPE
	local INDENT="$2"

	splitName "$1"

# UPDATED 2025/10/31 - replace APP* variables
#	[ $DEBUG -gt 0 ] && { echo -en "processDependencies:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:\n\tOPTFILE :${OPTFILE}:\n\tSOURCE  :${SOURCE}:\n\tTARGET  :${TARGET}:\n\tpwd     " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }
	[ $DEBUG -gt 0 ] && { echo -en "processDependencies:\n\tRAWFILE     |${RAWFILE}|\n\tPASSED      |${1}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${CPU}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\tOPTFILE     |${OPTFILE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

# UPDATED 2025/11/04 - we are now using DIRECTORY
#	[ "$REPO_TARGET" ] && TARGET="$REPO_TARGET" || TARGET="$REPO_OPTION"			# if a different target was specified, then store that as the target, otherwise use the default value
# UPDATED 2025/10/31 - replace APP* variables
#	DIR="${APPNAME/_${KERNEL}}"								# set the default value while removing any KERNEL value from the (directory) name
#	[ "$APPTYPE" = 'app' ] && DIR="web.de/_apps/${APPNAME}"					# if we're dealing with a web.de applet, set DIR to the package name for proper repo URI navigation
#	[ "$APPTYPE" = 'icn' ] && DIR="web.de/_icons/${APPNAME}"				# or an icon set
#	[ "$APPTYPE" = 'skn' ] && DIR="web.de/_skins/${APPNAME}"				# or a skin
#	[ "$APPTYPE" = 'thm' ] && DIR="web.de/_themes/${APPNAME}"				# or a theme
# REMOVED 2025/11/04 - the DIR value was added to REPO_REMOTE and the app,icn,skn,thm packages will need to be handled through web.de itself
#	DIR="${PACKAGE/_${KERNEL}}"								# set the default value to the package name, while removing the _KERNEL keyword
#	[ "$TYPE" = 'app' ] && DIR="web.de/_apps/${PACKAGE}"					# if we're dealing with a web.de applet, set DIR to the package name for proper repo URI navigation
#	[ "$TYPE" = 'icn' ] && DIR="web.de/_icons/${PACKAGE}"					# or an icon set
#	[ "$TYPE" = 'skn' ] && DIR="web.de/_skins/${PACKAGE}"					# or a skin
#	[ "$TYPE" = 'thm' ] && DIR="web.de/_themes/${PACKAGE}"					# or a theme

	# get us into the correct directory to process the request
# UPDATED 2025/11/04 - we now only use REPO_SOURCE and DIRECTORY, no more checking here and there...
## UPDATED 2025/10/31 - replace APP* variables
##	if [ ! "$REPO_SOURCE" ] && [ -e "./${APPFILE}" ]; then									# if no source was provided via '-S' and the pwd has the file (e.g. from a restore point), then...
#	if [ ! "$REPO_SOURCE" ] && [ -e "./${FILENAME}" ]; then							# if no source was provided via '-S' and the pwd has the file (e.g. from a restore point), then...
#		SOURCE='local '
#	elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'http' || echo "$REPO_SOURCE"|grep -q ^'ftp' ); then		# if a different SOURCE was provided -AND- it is remote, then...
#		cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1										# NOTE: we cd into this directory just as a precaution
#		SOURCE='remote'
## UPDATED 2025/10/31 - replace APP* variables
##	elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'/' || echo "$REPO_SOURCE"|grep -q ^'./' ) && [ -e "${REPO_SOURCE}/${APPFILE}" ]; then	# if a different SOURCE was provided -AND- it is a directory -AND- the iterated package exists in the REPO directory, then...
#	elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'/' || echo "$REPO_SOURCE"|grep -q ^'./' ) && [ -e "${REPO_SOURCE}/${FILENAME}" ]; then	# if a different SOURCE was provided -AND- it is a directory -AND- the iterated package exists in the REPO directory, then...
#		cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1
#		SOURCE='local '
## UPDATED 2025/10/31 - replace APP* variables
##	elif [ -e "${REPO_SYSTEM}/${APPFILE}" ]; then										# otherwise check that the file exists in the REPO_SYSTEM...
#	elif [ -e "${REPO_SYSTEM}/${FILENAME}" ]; then										# otherwise check that the file exists in the REPO_SYSTEM...
#		cd "$REPO_SYSTEM" >>"$LOG_ERRS" 2>&1
#		SOURCE='local '
#	else															# and lastly change to the default REPO_OPTION as a last resort to find/store the software
#		cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1
## UPDATED 2025/10/31 - replace APP* variables
##		[ -e "${REPO_OPTION}/${APPFILE}" ] && SOURCE='local ' || SOURCE='remote'
#		[ -e "${REPO_OPTION}/${FILENAME}" ] && SOURCE='local ' || SOURCE='remote'
#	fi
# UPDATED 2025/11/06
#	( echo "$REPO_SOURCE"|grep -q ^'http' || echo "$REPO_SOURCE"|grep -q ^'ftp' ) && SOURCE='remote' || SOURCE=' local'	# determine if the SOURCE is remote or local, then...
# MOVED 2025/11/07 - this was moved below and made to be dynamic
#	( echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) && SOURCE='remote' || SOURCE=' local'					# determine if the SOURCE is remote or local, then...

# MOVED 2025/11/05 - this is now done in the main part of the script
#	cd "$DIRECTORY" >>"$LOG_ERRS" 2>&1											# now cd into the DIRECTORY where the packages are

	# perform a few basic checks...
# UNTESTED
# UPDATED 2025/11/04 - we are now using DIRECTORY
#	if [ ! "$REPO_TARGET" ] && ( grep -qw "$RAWFILE" "${REPO_PREFIX}/${FLAG}" 2>/dev/null ); then				# if we're using an 'internal repo' (optional or system) -AND- the package IS listed as being flagged to not load, then...
	if ( grep -qwE ^"${PACKAGE}|${FILENAME}"$ "${REPO_PREFIX}/${FLAG}" 2>/dev/null ); then					# if the package (by its PACKAGE name -or- complete FILENAME) IS listed as being flagged to not load, then...
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage flagged from loading..." >>"$LOG_DBUG"
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[ FLAG ] ${APPNAME}.${APPTYPE}"
		showMsg 'step' "[ FLAG ] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is flagged from being loaded." 'log'
		return 1
	fi

	[ "$OPTFILE" ] && [ ! "$ALL" ] && [ ! -e "${DIR_LIST}/${OPTFILE}" ] && {						# if we've encountered a conditional package -AND- we are not using the -A option -AND- it's dependency is not installed, then we can safely skip it!
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage conditional missing..." >>"$LOG_DBUG"
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[absent] ${APPNAME}.${APPTYPE}"
		showMsg 'step' "[absent] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The conditional package is not installed." 'log'
		return 1
	}

	# perform checks for the action...
	[ "$COPY" ] && [ ! -e "${REPO_SOURCE}/${FILENAME}" ] && {							# if we're copying or downloading -AND- not forcing -AND- the package exists in the target DIRECTORY, then...
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is missing..." >>"$LOG_DBUG"
		showMsg 'step' "[absent] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is missing from REPO_SOURCE." 'log'
		return 1
	}
# MERGED 2025/11/05 - plus this should work for any action
## UPDATED 2025/10/31 - replace APP* variables and using showMsg()
##	[ "$COPY" ] && [ ! "$FORCE" ] && [ -e "${TARGET}/${APPFILE}" ] && {
##		[ $DEBUG -gt 0 ] && echo -e "\tPackage already exists..." >>"$LOG_DBUG"
##		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[exists] ${APPNAME}"
## UPDATED 2025/11/04 - we are now using DIRECTORY
##	[ "$COPY" ] && [ ! "$FORCE" ] && [ -e "${TARGET}/${FILENAME}" ] && {
#	[ "$COPY" ] && [ ! "$FORCE" ] && [ -e "${FILENAME}" ] && {							# if we're copy -AND- not forcing -AND- the package exists in the target DIRECTORY, then...
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage already exists..." >>"$LOG_DBUG"
#		showMsg 'step' "[exists] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
#		return 0
#	}
## UPDATED 2025/10/31 - replace APP* variables and using showMsg()
##	[ "$DOWNLOAD" ] && [ ! "$FORCE" ] && [ -e "${APPFILE}" ] && {
##		[ $DEBUG -gt 0 ] && echo -e "\tPackage already downloaded..." >>"$LOG_DBUG"
##		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[exists] ${APPNAME}.${APPTYPE}"
#	[ "$DOWNLOAD" ] && [ ! "$FORCE" ] && [ -e "${FILENAME}" ] && {							# if we're downloading a package -AND- not forcing -AND- the package exists in the target DIRECTORY, then...
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage already downloaded..." >>"$LOG_DBUG"
#		showMsg 'step' "[exists] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
#		return 0
#	}
	( [ "$COPY" ] || [ "$DOWNLOAD" ] ) && [ ! "$FORCE" ] && [ -e "${FILENAME}" ] && {				# if we're copying or downloading -AND- not forcing -AND- the package exists in the target DIRECTORY, then...
		[ $DEBUG -gt 0 ] && echo -e "\tPackage already exists in the target location." >>"$LOG_DBUG"					# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'step' "[exists] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0												# NOTE: do NOT return error, we will just simply skip the file so the user isn't forced to pass '-F' a lot
	}
# UNTESTED
# MERGED 2025/11/05 - plus this should work for any action
## UPDATED 2025/10/31 - replace APP* variables and using showMsg()
##	[ "$INSTALL" ] && [ ! "$FORCE" ] && [ ! "$RESTORE" ] && [ -e "${DIR_LIST}/${APPFILE}" ] && {			# if we're installing -AND- not updating (by forcing or creating a restore point) -AND- the software is already installed, then...
##		[ $DEBUG -gt 0 ] && echo -e "\tPackage already installed..." >>"$LOG_DBUG"
##		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[exists] ${APPNAME}.${APPTYPE}"
## UPDATED 2025/11/04 - unsure why RESTORE was added here since it doesn't have anything to do with installation
##	[ "$INSTALL" ] && [ ! "$FORCE" ] && [ ! "$RESTORE" ] && [ -e "${DIR_LIST}/${FILENAME}" ] && {			# if we're installing -AND- not forcing -AND- the software is already installed, then...
#	[ "$INSTALL" ] && [ ! "$FORCE" ] && [ -e "${DIR_LIST}/${FILENAME}" ] && {					# if we're installing -AND- not forcing -AND- the software is already installed, then...
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage already installed..." >>"$LOG_DBUG"
#		showMsg 'step' "[exists] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
#		return 0
#	}
## UPDATED 2025/10/31 - replace APP* variables and using showMsg()
##	[ "$RESTORE" ] && [ ! "$FORCE" ] && [ -e "${DIR_LIST}/${APPFILE}" ] && {					# if the iterated dependency is already installed, then go to the next one!
##		[ $DEBUG -gt 0 ] && echo -e "\tPackage currently installed..." >>"$LOG_DBUG"
##		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[exists] ${APPNAME}.${APPTYPE}"
#	[ "$RESTORE" ] && [ ! "$FORCE" ] && [ -e "${DIR_LIST}/${FILENAME}" ] && {					# if we're restoring from a restore point -AND- not forcing -AND- the software is already installed, then...
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage currently installed..." >>"$LOG_DBUG"
#		showMsg 'step' "[exists] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
#		return 0
#	}
	( [ "$INSTALL" ] || [ "$RESTORE" ] ) && [ ! "$FORCE" ] && [ -e "${DIR_LIST}/${FILENAME}" ] && {			# if we're installing or restoring -AND- not forcing -AND- the software is already installed, then...
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage currently installed..." >>"$LOG_DBUG"
		showMsg 'step' "[exists] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		[ $INDEX -eq 0 ] && {
			showMsg 'failure' "The package is currently installed." 'log'
			return 1
		}
		echo -e "\tThe dependency is currently installed." >>"$LOG_DBUG"
		return 0												# NOTE: this has to be a 0 because already installed packages (e.g. dependencies) would trigger failure
	}
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#	[ "$RESTORE" ] && [ ! -e "${APPFILE}" ] && {									# if the dependency is not in the restore point directory (pwd), then it must be already in 'optional' as a dep for another software
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is not in restore point..." >>"$LOG_DBUG"
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[absent] ${APPNAME}.${APPTYPE}"
	[ "$RESTORE" ] && [ ! -e "${FILENAME}" ] && {									# if the dependency is not in the restore point directory, then...
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is not in restore point..." >>"$LOG_DBUG"
		showMsg 'step' "[absent] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is not in the restore point." 'log'
		return 1
	}
# UPDATED 2025/10/22 - merged -P with -U
#	[ "$UNLOAD" ] && [ ! -e "${DIR_LIST}/${APPFILE}" ] && [ "$PURGE" -eq '0' ] && {					# if the iterated dependency is already unloaded -AND- we aren't uninstalling it, then go to the next one!
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#	[ "$UNLOAD" ] && [ ! -e "${DIR_LIST}/${APPFILE}" ] && [ "$PURGE" = '' ] && {					# if the iterated dependency is already unloaded -AND- we aren't uninstalling it, then go to the next one!
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage already unloaded..." >>"$LOG_DBUG"
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[absent] ${APPNAME}.${APPTYPE}"
	[ "$UNLOAD" ] && [ ! -e "${DIR_LIST}/${FILENAME}" ] && [ "$PURGE" = '' ] && {					# if the iterated dependency is already unloaded -AND- we aren't uninstalling it, then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tThe package is already unloaded." >>"$LOG_DBUG"				# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'step' "[absent] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0
	}
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#	[ "$UNLOAD" ] && ( echo ",$IGNORE" | grep -q ",$APPHEAD" ) && {							# if the iterated dependency is ignored -AND- we are unloading/uninstalling it, then go to the next one!
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is being ignored..." >>"$LOG_DBUG"
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[ignore] ${APPNAME}.${APPTYPE}"
# UPDATED 2025/11/04 - broadened the search range to be either a PACKAGE name or full FILENAME
#	[ "$UNLOAD" ] && ( echo ",${IGNORE}," | grep -q ",${BASENAME}," ) && {							# if the iterated dependency is ignored -AND- we are unloading/uninstalling it, then go to the next one!
	[ "$UNLOAD" ] && ( echo ",${IGNORE}," | grep -qE ",(${PACKAGE}|${FILENAME})," ) && {							# if the iterated dependency is ignored -AND- we are unloading/uninstalling it, then go to the next one!
		[ $DEBUG -gt 0 ] && echo -e "\tThe package was passed in the ignore list..." >>"$LOG_DBUG"			# NOTE: we left this line like this since this is not a failure, but just a package to skip
		showMsg 'step' "[ignore] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		return 0
	}
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#	[ "$UNLOAD" ] && ( [ -L "${DIR_LIST}/${APPHEAD}.soft" ] || [ ! -s "${DIR_LIST}/${APPHEAD}.soft" ] ) && {	# if the iterated dependency is on DATA (via symlink) or BOOT (via 0 byte file), then go to the next one!
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is being ignored (BOOT)..." >>"$LOG_DBUG"
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[ BOOT ] ${APPNAME}.${APPTYPE}"
	[ "$UNLOAD" ] && ( [ -L "${DIR_LIST}/${FILENAME}" ] || [ ! -s "${DIR_LIST}/${FILENAME}" ] ) && {	# if the iterated dependency is on DATA (via symlink) or BOOT (via 0 byte file), then go to the next one!
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is being ignored (FIRMWARE package)..." >>"$LOG_DBUG"
		showMsg 'step' "[SYSTEM] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is part of the base OS and can't be modified." 'log'
		return 1
	}
# UPDATED 2025/11/07 - removed COPY since it would already error out with the other check above; also we simply need to check if it's local or not
#	( [ "$COPY" ] || [ "$UNLOAD" ] || [ "$VALIDATE" ] ) && [ "$SOURCE" = 'remote' ] && {				# if we are copying, unloading/uninstalling, or validating -AND- the iterated dependency is considered 'remote' (can't be found due to needing a proper -S value) then, go to the next one!
	( [ "$UNLOAD" ] || [ "$VALIDATE" ] ) && ! -e "${REPO_SOURCE}/${FILENAME}" ] && {				# if we are copying, unloading/uninstalling, or validating -AND- the iterated dependency is not present, then go to the next one!
# UPDATED 2025/11/07
#		[ $DEBUG -gt 0 ] && echo -e "\tPackage is missing..." >>"$LOG_DBUG"
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[absent] ${APPNAME}.${APPTYPE}"
		showMsg 'step' "[absent] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		showMsg 'failure' "The package is missing from REPO_SOURCE." 'log'
		return 1
	}

	# determine if the SOURCE is remote or local, then...					# NOTE: for any actions that must perform locally, an error would have already been issued above
	[ -e "${REPO_SOURCE}/${FILENAME}" ] && SOURCE=' local'
	[ ! -e "${REPO_SOURCE}/${FILENAME}" ] && {
		( echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) || {
			showMsg 'step' "[!REPO!] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
			showMsg 'failure' "The package needs to be downloaded, but the REPO_SOURCE is local." 'log'
			return 1
		}
		SOURCE='remote'
	}

	# check that the dependency is not already in the list to be processed
# UPDATED 2025/11/05 - to reduce duplicates once they've been proceeded
#	if [ ! "$TREE" ] && [ ! "$VALIDATE" ]; then						# if we're not displaying a dependency tree -OR- validating packages, then...
	if [ ! "$TREE" ]; then									# if we're not displaying a dependency tree, then...
		[ $DEBUG -gt 0 ] && echo -e "\tChecking if dependency is already marked for processing..." >>"$LOG_DBUG"
#echo 'checking deps listing'
		for DEPFILE in $(seq 1 $INDEX); do						# check if the dependencies has already been added to the list to be processed, so...
			eval TEMP="\$DEP$DEPFILE"						#   since busybox 'sh' does not support arrays, we have to use this method to check each stored dependency
#echo "comparing |$TEMP|$FILENAME|"
# UPDATED 2025/11/05 - updated to be the full filename to prevent any issues with different TYPEs
#			if [ "$TEMP" = "$RAWFILE" ]; then					#   if the iterated dependency is already in the list (including any specific version number), then...
			if [ "$TEMP" = "$FILENAME" ]; then					#   if the iterated dependency is already in the list (including any specific version number), then...
				[ "$VALIDATE" ] && {
					showMsg 'step' "[duplicate] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1	# other possible values: processed
					return 0
				}

				[ $DEBUG -gt 0 ] && echo -e "\tPackage already marked for processing..." >>"$LOG_DBUG"			# NOTE: we left this line like this since this is not a failure, but just a package to skip
# UPDATED 2025/10/31 - replace APP* variables and using showMsg()
#				( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[marked] ${APPNAME}.${APPTYPE}"
	#			showMsg 'step' "[marked] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
				showMsg 'step' "[duplct] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1			# other possible values: marked, double, listed
				return 0
			fi
		done
	fi

	# --- IF WE HAVE MADE IT HERE, THEN DO SOME WORK ---

	if [ "$UNLOAD" ] && [ ! "$FORCE" ]; then						# if we're unloading the package, then...
# REMOVED 2025/11/07
#		RELEASE=1									#   (re)set the value
# UPDATED 2025/10/31
#		for DEPFILE in $(ls -1 "$DIR_LIST" 2>/dev/null | grep 'soft'$); do		#   for each currently installed package we need to see if any depend on the package to be unloaded, so...
		for DEPFILE in $(ls -1 "$DIR_LIST" 2>/dev/null | grep "${EXT_SOFT}"$); do		#   for each currently installed package we need to see if any depend on the package to be unloaded, so...
# UPDATED 2018/11/29
#			DEPNAME="$(echo "$DEPFILE" | head -c -5)"				#   since the files in DIR_INST are just NAME.TYPE, we need to split to form a whole filename
#			DEPTYPE="${DEPFILE##*.}"
# UPDATED 2025/10/31 - to use FILENAME
#			DEPNAME="$(echo "$DEPFILE" | head -c -14)"				#   since the files in DIR_LIST are NAME.ARCH.TYPE.EXTN, we need to split to form a whole filename
#			DEPTYPE="$(echo "$DEPFILE" | tail -c 9 | head -c 3)"
#
#			[ -e "${DIR_LIST}/${DEPNAME}.${CPU}.${DEPTYPE}.mark" ] && continue	# if the iterated dependency is already marked to be unloaded, then go to the next one
#			[ -e "${REPO_OPTION}/${DEPNAME}.${CPU}.${DEPTYPE}.deps" ] || continue	# if no .deps file exists for the iterated installed package, then continue since it does not depend on the package we are trying to unload
#
#			# if there is an EXEID -AND- the requested package is a dependency for the iterated installed software -AND- that iterated installed software is not in the EXEID file that can be uninstalled, then..
#			[ "$EXEID" ] && ( grep -q ^"$RAWFILE" "${REPO_OPTION}/${DEPNAME}.${CPU}.${DEPTYPE}.deps" ) && ( ! grep -q ^"${DEPNAME}.${CPU}.${DEPTYPE}.soft" "$EXEID" >/dev/null 2>&1 ) && {
#				[ $DEBUG -gt 0 ] && echo -e "\tOther software depends on this dependency..." >>"$LOG_DBUG"
#				( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[depend] [${DEPNAME}.${DEPTYPE}] ${APPNAME}.${APPTYPE}"
#				RELEASE=0							#   indicate that the dependency can not be removed
#				break								#   now break from the 'for' loop to conserve resources
#			}

# LEFT OFF - make sure this works with the installPackage() processing to prevent dependencies of other packages from getting uninstalled; can probably get rid of the files generated by installPackage()
			TEMP="${FILE_SCHEMA#*\}}"						#   remove just the package name portion from the package filename 'schema' - everything before the first '}' character
			eval TEMP="${TEMP}.${EXT_SOFT}"						#   combine the 'schema' (less the package name) values and the file extension value (e.g. i32.bin.soft)
			DEPNAME="$(echo $DEPFILE | sed "s/${TEMP}//")"				#   remove that combination from the passed package name (in case it was passed like bash.i32.bin.soft) to isolate just the package name (e.g. bash)
			DEPBASE="$(echo $DEPFILE | sed "s/.${EXT_SOFT}$//")"			#   remove the file extension from the name
			DEPTYPE="$(echo "$DEPFILE" | grep -oE '[\._\-](bin|dev|doc|drv|gir|lib|loc)' | sed -E 's/^[\._\-]//')"	# search for any variation of known type abbreviations and remove the preceeding separation character
			[ "$DEPTYPE" = '' ] && DEPTYPE='bin'					#   if the line above did not return any value, then default to 'bin'

			[ -e "${DIR_LIST}/${DEPBASE}.${EXT_MARK}" ] && continue			# if the iterated dependency is already marked to be unloaded, then go to the next one
# UPDATED 2025/11/04 - we are now using DIRECTORY
#			[ ! -e "${REPO_OPTION}/${DEPBASE}.deps" ] || continue			# if no .deps file exists for the iterated installed package, then continue since it does not depend on the package we are trying to unload
			[ ! -e "${DIRECTORY}/${DEPBASE}.${EXT_DEPS}" ] || continue		# if no .deps file exists for the iterated installed package, then continue since it does not depend on the package we are trying to unload

			# if there is an EXEID -AND- the requested package is a dependency for the iterated installed software -AND- that iterated installed software is not in the EXEID file that can be uninstalled, then..
# UPDATED 2025/11/04 - we are now using DIRECTORY
#			[ "$EXEID" ] && ( grep -q ^"$RAWFILE" "${REPO_OPTION}/${DEPBASE}.${EXT_DEPS}" ) && ( ! grep -q ^"${DEPFILE}" "$EXEID" >/dev/null 2>&1 ) && {
# UPDATED 2025/11/10
#			[ "$EXEID" ] && ( grep -q ^"$RAWFILE" "${DIRECTORY}/${DEPBASE}.${EXT_DEPS}" ) && ( ! grep -q ^"${DEPFILE}" "$EXEID" >/dev/null 2>&1 ) && {
# UPDATED 2025/11/12 - the filename has changed, and removed the beginning condition sine EXEID will always have a value
#			[ "$EXEID" ] && ( grep -q ^"$RAWFILE" "${DIRECTORY}/${DEPBASE}.${EXT_DEPS}" ) && ( ! grep -q ^"${DEPFILE}" "${DIR_TEMP}/${EXEID}" >/dev/null 2>&1 ) && {
			( grep -q ^"$RAWFILE" "${DIRECTORY}/${DEPBASE}.${EXT_DEPS}" ) && ( ! grep -q ^"${DEPFILE}" "${DIR_TEMP}/installed.${EXEID}" >/dev/null 2>&1 ) && {
				[ $DEBUG -gt 0 ] && echo -e "\tOther software depends on this dependency..." >>"$LOG_DBUG"			# NOTE: we left this line like this since this is not a failure, but just a package to skip
				showMsg 'step' "[depend] [(${DEPTYPE}) ${DEPNAME}] (${FILETYPE})${INDENT} ${PACKAGE}" 'both' 1 1
# REMOVED 2025/11/07
#				RELEASE=0							#   indicate that the dependency can not be removed
#				break								#   now break from the 'for' loop to conserve resources
				return 0
			}
		done
# REMOVED 2025/11/07
#		[ "$RELEASE" = '0' ] && return 0						#   if the dependency has NOT been released to unload, then don't!
	fi

	if [ "$TREE" ]; then
# UPDATED 2025/11/05 - replaced the APP* variables
#		echo "${INDENT}${APPNAME}.${APPTYPE}"
		echo "${INDENT}${PACKAGE} (${FILETYPE})"
	elif [ "$VALIDATE" ]; then
# REMOVED 2025/11/07 - this would be caught in the checks above
#		[ "$SOURCE" = 'remote' ] && showMsg 'step' "[ missing ] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
# UPDATED 2025/11/05 - replaced the APP* variables
#		[ -e "${DIR_LIST}/${APPFILE}" ] && showMsg 'step' "[installed] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
		[ -e "${DIR_LIST}/${FILENAME}" ] && showMsg 'step' "[installed] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
	elif [ "$UNLOAD" ]; then
		showMsg 'step' "[marked] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
	else
		showMsg 'step' "[${SOURCE}] (${FILETYPE}) ${INDENT}${PACKAGE}" 'both' 1 1
	fi

	# add the passed dependency to the stack
	addDependency "${FILENAME}"								# add the passed package to the stack to be processed outside of this function
	[ $DEBUG -gt 0 ] && echo "processDependencies (returned):" >>"$LOG_DBUG"

	[ "$ONLY" ] && {									# if we are only affecting the package itself and not any dependencies, then...
		[ $DEBUG -gt 0 ] && echo -e "\tJust downloading the package, not any dependencies..." >>"$LOG_DBUG"
# UPDATED 2025/11/05 - updated to be the full filename to prevent any issues with different TYPEs
#		addDependency "${RAWFILE}"							#   add the passed package to the stack to be processed outside of this function
# REMOVED 2025/11/07 - re-arranged the code so that this step is already taken above
#		addDependency "${FILENAME}"							#   add the passed package to the stack to be processed outside of this function
		return 0									#   now exit this function!
	}

	# obtain or copy the software .deps file
# UPDATED 2025/11/04 - turn this into the actions that do use this; also implement REPO_SOURCE and directory
#	if [ ! "$UNLOAD" ] && [ ! "$TREE" ] && [ ! "$VALIDATE" ] && [ "$SOURCE" = 'remote' ]; then		# if copying, downloading, or installing from an external source, then...	NOTE: this can NOT be '[ "$DOWNLOAD" ]' since more than one ACTION can utilize remote sources
#		cd "$TARGET" >>"$LOG_ERRS" 2>&1							# change into the desired TARGET directory before executing the download
#		[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.deps\"" >>"$LOG_DBUG"
#		wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.deps" >>"$LOG_ERRS" 2>&1				#   get any .deps file for the dependency itself
#	elif [ "$COPY" ] && [ -e "./${APPHEAD}.deps" ]; then					# NOTE: only the COPY will apply to this section
#		[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.deps\" \"${TARGET}\"" >>"$LOG_DBUG"
#		[ -e "./${APPHEAD}.deps" ] && cp -f "./${APPHEAD}.deps" "${TARGET}" >>"$LOG_ERRS" 2>&1
#	fi

# UPDATED 2025/11/07 - copy is strictly offline
#	if ( [ "$COPY" ] || [ "$DOWNLOAD" ] || [ "$INSTALL" ] ) && [ "$SOURCE" = 'remote' ]; then # if copying, downloading, or installing from an external source, then...	NOTE: we are already in the target storage directory
	if ( [ "$COPY" ] || [ "$DOWNLOAD" ] || [ "$INSTALL" ] ); then 				# if copying, downloading, or installing from an external source, then...	NOTE: we are already in the target storage directory
		[ $DEBUG -gt 0 ] && echo -e "\tChecking for package dependency file..." >>"$LOG_DBUG"
		if [ ! "$COPY" ] && [ "$SOURCE" = 'remote' ]; then
			eval SOURCE="${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}"				#   re-purpose SOURCE (since we're done using it for its original intention) incase REPO_SOURCE has any variables in it
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    wget -cq \"${SOURCE}\"" >>"$LOG_DBUG"
			wget -cq "${SOURCE}" >/dev/null 2>&1 || return 0				#   get any .deps file for the dependency itself	NOTE: we can't exit with an error since some packages do not have one of these files
		elif [ "$COPY" ] && [ -e "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" ]; then		# if we're copying and the dependency has a .deps file, then copy it over too!
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}\" './'" >>"$LOG_DBUG"
			cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" './' >/dev/null 2>&1 || {	#   copy the corresponding deps file
				showMsg 'failure' "The package deps file copy failed (${BASENAME}.${EXT_DEPS})." 'log'
				return 1
			}
		fi

		# process all the dependencies of the passed software
		if [ -e "${BASENAME}.${EXT_DEPS}" ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tA package dependency file exists, processing..." >>"$LOG_DBUG"
#echo "BASENAME |$BASENAME|" >>$LOG_DBUG
			for DEPFILE in $(cat "./${BASENAME}.${EXT_DEPS}" 2>/dev/null); do			# if the passed dependency also has dependencies, then...
#echo "DEPFILE |$DEPFILE|" >>$LOG_DBUG
				processDependencies "$DEPFILE" "$INDENT  " || return 1				# WARNING: this line needs to execute no matter the outcome of the 'wget' call above (so the addDependency() call can be made if needed) -AND- it needs to be the unaltered DEPFILE variable with any contained version number!!!
			done
		fi
	fi

	# add the passed dependency to the stack
# MOVED/UPDATED 2025/11/04 - moved above since we need to repurpose SOURCE and swapped APP* variables
#	if [ "$TREE" ]; then
#		echo "${INDENT}${APPNAME}.${APPTYPE}"
#	elif [ "$VALIDATE" ]; then
#		[ "$SOURCE" = 'remote' ] && echo "[ missing ] ${APPNAME}.${APPTYPE}"
#		[ -e "${DIR_LIST}/${APPFILE}" ] && echo "[installed] ${APPNAME}.${APPTYPE}"
#	elif [ "$UNLOAD" ]; then
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[marked] ${APPNAME}.${APPTYPE}"
#	else
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[${SOURCE}] ${APPNAME}.${APPTYPE}"
#	fi
# UPDATED 2025/11/05 - updated to be the full filename to prevent any issues with different TYPEs
#	addDependency "${RAWFILE}"								# at least add the passed package to the stack to be processed outside of this function
# MOVED 2025/11/07 - this was moved above the "obtain or copy the software .deps file" section
#	addDependency "${FILENAME}"								# add the passed package to the stack to be processed outside of this function
## UPDATED 2025/11/04 - replaced APP*
##	[ ! -f "${APPHEAD}.deps" ] && return 0							# if no dependency file exists for the passed package, then no need to process anything else in this function!	NOTE: we must put this here instead of the top since we need to (at least) process the first passed package!
##	[ "$UNLOAD" ] && touch "${DIR_LIST}/${APPHEAD}.mark"
# REMOVED 2025/11/05 - this is no longer required since the re-arrangement of code
#	[ ! -f "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" ] && return 0				# if no dependency file exists for the passed package, then no need to process anything else in this function!	NOTE: we must put this here instead of the top since we need to (at least) process the first passed package!
	[ "$UNLOAD" ] && touch "${DIR_LIST}/${BASENAME}.${EXT_MARK}"

# MOVED 2025/11/07 - moved into the "obtain or copy the software .deps file" section
#	# process all the dependencies of the passed software
## UPDATED 2025/11/04 - replaced APP*
##	for DEPFILE in $(cat "${APPHEAD}.deps" 2>/dev/null); do					# if the passed dependency also has dependencies, then...
## UPDATED 2025/11/07 - this should process the just-downloaded .deps file
##	for DEPFILE in $(cat "${REPO_SOURCE}/${BASENAME}.${EXT_DEPS}" 2>/dev/null); do		# if the passed dependency also has dependencies, then...
#	for DEPFILE in $(cat "./${BASENAME}.${EXT_DEPS}" 2>/dev/null); do			# if the passed dependency also has dependencies, then...
#		processDependencies "$DEPFILE" "$INDENT  " || return 1				# WARNING: this line needs to execute no matter the outcome of the 'wget' call above (so the addDependency() call can be made if needed) -AND- it needs to be the unaltered DEPFILE variable with any contained version number!!!
#	done
	return 0
}


# Usage syntax: copyPackage
# Overview:	copies the .soft and .hash files from a local directory to another local directory
# Notes:	the directory containing the file(s)-to-copy should already be entered BEFORE calling this function!
#		no need to copy the .deps file since that was handled via processDependencies().
copyPackage() {
	[ $DEBUG -gt 0 ] && { echo -en "copyPackage:\n\tRAWFILE     |${RAWFILE}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${CPU}|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	[ "$REPO_SOURCE" = "$DIRECTORY" ] && {
		showMsg 'failure' "The source and target locations are the same."
		return 1
	}

	[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"${REPO_SOURCE}/${BASENAME}.${EXT_SOFT}\" './'" >>"$LOG_DBUG"
# UPDATED 2025/11/10
#	cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_SOFT}" './' >>"$LOG_ERRS" 2>&1 || {		# copy the .soft file from the source directory
	( cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_SOFT}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {	# copy the .soft file from the source directory
		showMsg 'failure' "The package copy failed (${BASENAME}.${EXT_SOFT})." 'log'
		return 1
	}
	[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"${REPO_SOURCE}/${BASENAME}.${EXT_HASH}\" './'" >>"$LOG_DBUG"
# UPDATED 2025/11/10
#	cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_HASH}" './' >>"$LOG_ERRS" 2>&1 || {		# copy the corresponding hash file
	( cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_HASH}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {	# copy the corresponding hash file
		showMsg 'failure' "The package hash file copy failed (${BASENAME}.${EXT_HASH})." 'log'
		return 1
	}

	if [ "$EXTRA" ]; then
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'code' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.${EXT_CODE}\" './'" >>"$LOG_DBUG"
			if [ -e "${REPO_SOURCE}/${BASENAME}.${EXT_CODE}" ]; then
# UPDATED 2025/11/10
#				cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_CODE}" './' >>"$LOG_ERRS" 2>&1 || {	# copy the corresponding code file
				( cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_CODE}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {	# copy the corresponding code file
					showMsg 'failure' "The package source code file copy failed (${BASENAME}.${EXT_CODE})." 'log'
					return 1
				}
			fi
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'cpio' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.cpio\" './'" >>"$LOG_DBUG"
			if [ -e "${REPO_SOURCE}/${BASENAME}.cpio" ]; then
# UPDATED 2025/11/10
#				cp -f "${REPO_SOURCE}/${BASENAME}.cpio" './' >>"$LOG_ERRS" 2>&1 || {		# copy the corresponding cpio file
				( cp -f "${REPO_SOURCE}/${BASENAME}.cpio" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {		# copy the corresponding cpio file
					showMsg 'failure' "The package cpio file copy failed (${BASENAME}.cpio)." 'log'
					return 1
				}
			fi
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'info' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.${EXT_INFO}\" './'" >>"$LOG_DBUG"
			if [ -e "${REPO_SOURCE}/${BASENAME}.${EXT_INFO}" ]; then
# UPDATED 2025/11/10
#				cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_INFO}" './' >>"$LOG_ERRS" 2>&1 || {	# copy the corresponding info file
				( cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_INFO}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {	# copy the corresponding info file
					showMsg 'failure' "The package info file copy failed (${BASENAME}.${EXT_INFO})." 'log'
					return 1
				}
			fi
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'list' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.${EXT_LIST}\" './'" >>"$LOG_DBUG"
			if [ -e "${REPO_SOURCE}/${BASENAME}.${EXT_LIST}" ]; then
# UPDATED 2025/11/10
#				cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_LIST}" './' >>"$LOG_ERRS" 2>&1 || {	# copy the corresponding list file
				( cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_LIST}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {	# copy the corresponding list file
					showMsg 'failure' "The package manifest file copy failed (${BASENAME}.${EXT_LIST})." 'log'
					return 1
				}
			fi
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'make' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -f \"./${BASENAME}.${EXT_MAKE}\" './'" >>"$LOG_DBUG"
			if [ -e "${REPO_SOURCE}/${BASENAME}.${EXT_MAKE}" ]; then
# UPDATED 2025/11/10
#				cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_MAKE}" './' >>"$LOG_ERRS" 2>&1 || {	# copy the corresponding make file
				( cp -f "${REPO_SOURCE}/${BASENAME}.${EXT_MAKE}" './' 2>&1 | sed 's/^c/ \[failure\]\nc/' | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {	# copy the corresponding make file
					showMsg 'failure' "The package make file copy failed (${BASENAME}.${EXT_MAKE})." 'log'
					return 1
				}
			fi
		fi
	fi

	return 0

# UPDATED 2025/11/04
	local TARGET=''
	[ "$REPO_TARGET" ] && TARGET="$REPO_TARGET" || TARGET="$REPO_OPTION"			# if a different target was specified, then store that as the target, otherwise use the default value

	[ $DEBUG -gt 0 ] && { echo -en "copyPackage:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tTARGET  :${TARGET}:\n\tpwd     " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.soft\" \"$TARGET\"" >>"$LOG_DBUG"
	cp -f "./${APPHEAD}.soft" "$TARGET" >>"$LOG_ERRS" 2>&1 || {				# copy the .soft file from the source directory
		[ "$SILENT" ] || echo "ERROR: package copy failed (${APPHEAD}.soft)." >>"$LOG_ERRS"
		return 1
	}
	[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.hash\" \"$TARGET\"" >>"$LOG_DBUG"
	cp -f "./${APPHEAD}.hash" "$TARGET" >>"$LOG_ERRS" 2>&1 || {				# copy the corresponding hash file
		[ "$SILENT" ] || echo "ERROR: package hash copy failed (${APPHEAD}.hash)." >>"$LOG_ERRS"
		return 1
	}

	if [ "$EXTRA" ]; then
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'info' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.info\" \"$TARGET\"" >>"$LOG_DBUG"
			[ -e "./${APPHEAD}.info" ] && cp -f "./${APPHEAD}.info" "$TARGET" >>"$LOG_ERRS" 2>&1	# copy the corresponding info file
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'list' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: cp -f \"./${APPHEAD}.list\" \"$TARGET\"" >>"$LOG_DBUG"
			[ -e "./${APPHEAD}.list" ] && cp -f "./${APPHEAD}.list" "$TARGET" >>"$LOG_ERRS" 2>&1	# copy the corresponding list file
		fi
	fi

	return 0
}


# Usage syntax: downloadPackage
# Overview:	downloads the .soft and .hash files from the repo and compares the package checksum to validate the download
# Notes:	the directory to store the obtained file(s) should already be entered BEFORE calling this function!
#		no need to copy the .deps file since that was handled via processDependencies().
downloadPackage() {
	local BASE="${BASENAME}"
	local FILE="${BASENAME}.${EXT_SOFT}"
	[ "$VERBASE" ] && BASE="$VERBASE"
	[ "$VERFILE" ] && FILE="$VERFILE"
	eval REPO_SOURCE="${REPO_SCHEMA}"							# eval REPO_SOURCE incase it has any variables in it

	[ $DEBUG -gt 0 ] && { echo -en "downloadPackage:\n\tRAWFILE     |${RAWFILE}|\n\tFILENAME    |${FILE}|\n\tBASENAME    |${BASE}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${CPU}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\tOPTFILE     |${OPTFILE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	( echo "$REPO_SOURCE" | grep -qE ^'(http|ftp)' ) || {					# make sure the SOURCE is remote
		showMsg 'failure' "A non-Internet value is set for REPO_SOURCE." 'log'
		return 1
	}

	[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE}.${EXT_SOFT}\"" >>"$LOG_DBUG"
# UPDATED 2025/11/07 - updated to output to the log correctly
#	wget -cq "${REPO_SOURCE}/${BASE}.${EXT_SOFT}" >>"$LOG_ERRS" 2>&1 || {			# download the package file from the repo
#	( [ ! -e "${BASE}.${EXT_SOFT}" ] || [ ! -s "${BASE}.${EXT_SOFT}" ] ) && {		# if the file wasn't downloaded, or it's a zero byte file, then...	NOTE: this uses the 'pwd' as the download directory via 'wget'
	( wget -cq "${REPO_SOURCE}/${BASE}.${EXT_SOFT}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the package file from the repo	NOTE: the string of commands outputs to the pax.log correctly while still returning a proper exit code from wget
		showMsg 'failure' "The package file download failed (${BASE}.${EXT_SOFT})." 'log'
		return 1
	}

	[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE}.${EXT_HASH}\"" >>"$LOG_DBUG"
# UPDATED 2025/11/07 - updated to output to the log correctly
#	wget -cq "${REPO_SOURCE}/${BASE}.${EXT_HASH}" >>"$LOG_ERRS" 2>&1			# download the corresponding hash file
#	( [ ! -e "${BASE}.${EXT_HASH}" ] || [ ! -s "${BASE}.${EXT_HASH}" ] ) && {
	( wget -cq "${REPO_SOURCE}/${BASE}.${EXT_HASH}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the corresponding hash file
		showMsg 'failure' "The package hash file download failed (${BASE}.${EXT_HASH})." 'log'
		return 1
	}

	# if we ARE installing a specific version of the software, then...
	[ $DEBUG -gt 0 ] && [ "$VERSION" ] && echo -e "\tCalling: sed -i \"s/^${PACKAGE}/${VERSION}/\" \"${BASE}.${EXT_HASH}\"" >>"$LOG_DBUG"
	[ "$VERSION" ] && sed -i "s/^${PACKAGE}/${VERSION}/" "${BASE}.${EXT_HASH}"		# changing the package name to match the version number in the hash file

	if [ "$EXTRA" ]; then
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'code' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE}.${EXT_CODE}\"" >>"$LOG_DBUG"
# UPDATED 2025/11/07 - updated to output to the log correctly
#			wget -cq "${REPO_SOURCE}/${BASE}.${EXT_CODE}" >>"$LOG_ERRS" 2>&1	# download the corresponding source code file
#			( [ ! -e "${BASE}.${EXT_INFO}" ] || [ ! -s "${BASE}.${EXT_CODE}" ] ) && {
			( wget -cq "${REPO_SOURCE}/${BASE}.${EXT_CODE}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the corresponding source code file
				showMsg 'warning' "The package source code file download failed (${BASE}.${EXT_CODE})." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'cpio' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE}.cpio\"" >>"$LOG_DBUG"
# UPDATED 2025/11/07 - updated to output to the log correctly
#			wget -cq "${REPO_SOURCE}/${BASE}.cpio" >>"$LOG_ERRS" 2>&1	# download the corresponding info file
#			( [ ! -e "${BASE}.cpio" ] || [ ! -s "${BASE}.cpio" ] ) && {
			( wget -cq "${REPO_SOURCE}/${BASE}.cpio" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {		# download the corresponding cpio file
				showMsg 'warning' "The package cpio file download failed (${BASE}.cpio)." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'info' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE}.${EXT_INFO}\"" >>"$LOG_DBUG"
# UPDATED 2025/11/07 - updated to output to the log correctly
#			wget -cq "${REPO_SOURCE}/${BASE}.${EXT_INFO}" >>"$LOG_ERRS" 2>&1	# download the corresponding info file
#			( [ ! -e "${BASE}.${EXT_INFO}" ] || [ ! -s "${BASE}.${EXT_INFO}" ] ) && {
			( wget -cq "${REPO_SOURCE}/${BASE}.${EXT_INFO}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the corresponding info file
				showMsg 'warning' "The package info file download failed (${BASE}.${EXT_INFO})." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'list' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_SOURCE}/${BASE}.${EXT_LIST}\"" >>"$LOG_DBUG"
# UPDATED 2025/11/07 - updated to output to the log correctly
#			wget -cq "${REPO_SOURCE}/${BASE}.${EXT_LIST}" >>"$LOG_ERRS" 2>&1	# download the corresponding list file
#			( [ ! -e "${BASE}.${EXT_LIST}" ] || [ ! -s "${BASE}.${EXT_LIST}" ] ) && {
			( wget -cq "${REPO_SOURCE}/${BASE}.${EXT_LIST}" 2>&1 | sed 's/^w/ \[failure\]\nw/' | tee -a "$LOG_ERRS" | grep -q 404 ) && {	# download the corresponding manifest file
				showMsg 'warning' "The package manifest file download failed (${BASE}.${EXT_LIST})." 'log'
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
		fi
	fi

return 0
# REMOVED 2025/11/06 - the DIR value was added to REPO_REMOTE and the app,icn,skn,thm packages will need to be handled through web.de itself
	local DIR="${APPNAME/_${KERNEL}}"							# set the default value while removing any KERNEL value from the (directory) name
	[ "$APPTYPE" = 'app' ] && DIR="web.de/_apps/${APPNAME}"					# if we're dealing with a web.de applet, set DIR to the package name for proper repo URI navigation
	[ "$APPTYPE" = 'icn' ] && DIR="web.de/_icons/${APPNAME}"				# or an icon set
	[ "$APPTYPE" = 'skn' ] && DIR="web.de/_skins/${APPNAME}"				# or a skin
	[ "$APPTYPE" = 'thm' ] && DIR="web.de/_themes/${APPNAME}"				# or a theme

	[ $DEBUG -gt 0 ] && { echo -en "downloadPackage:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:\n\tDIR     :${DIR}:\n\tpwd     " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

	[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.soft\"" >>"$LOG_DBUG"
	wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.soft" >>"$LOG_ERRS" 2>&1			# download the .soft file from the repo
	( [ ! -e "${APPHEAD}.soft" ] || [ ! -s "${APPHEAD}.soft" ] ) && {			# if the file wasn't downloaded, or it's a zero byte file, then...	NOTE: this uses the 'pwd' as the download directory via 'wget'
		[ "$SILENT" ] || echo "ERROR: package download failed (${APPHEAD}.soft)." >>"$LOG_ERRS"
		return 1
	}
	# if we are NOT installing a specific version of the software, then...
	[ $DEBUG -gt 0 ] && [ ! "$VERSION" ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.hash\"" >>"$LOG_DBUG"
	[ ! "$VERSION" ] && wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.hash" >>"$LOG_ERRS" 2>&1		# download the corresponding hash file
	# otherwise we are, so...
	[ $DEBUG -gt 0 ] && [ "$VERSION" ] && echo -e "\tCalling: wget -cq -O - \"${REPO_REMOTE}/${DIR}/${APPHEAD}.hash\" | sed \"s/${VERSION}/${APPNAME}/\" >\"${APPHEAD}.hash\"" >>"$LOG_DBUG"
	[ "$VERSION" ] && wget -cq -O - "${REPO_REMOTE}/${DIR}/${APPHEAD}.hash" 2>>"$LOG_ERRS" | sed "s/${VERSION}/${APPNAME}/" >"${APPHEAD}.hash"		# download the corresponding hash file changing the name to match the version number
	( [ ! -e "${APPHEAD}.hash" ] || [ ! -s "${APPHEAD}.hash" ] ) && {			# if the file wasn't downloaded, or it's a zero byte file, then...
		[ "$SILENT" ] || echo "ERROR: package hash download failed (${APPHEAD}.hash)." >>"$LOG_ERRS"
		return 1
	}

	if [ "$EXTRA" ]; then
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'info' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.info\"" >>"$LOG_DBUG"
			wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.info" >>"$LOG_ERRS" 2>&1	# download the corresponding info file
			( [ ! -e "${APPHEAD}.info" ] || [ ! -s "${APPHEAD}.info" ] ) && {	# if the file wasn't downloaded, or it's a zero byte file, then...
				( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "WARNING: package info does not exist or download failed (${APPHEAD}.info)." >>"$LOG_ERRS"
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
		fi
		if [ "$EXTRA" = 'all' ] || [ "$EXTRA" = 'list' ]; then
			[ $DEBUG -gt 0 ] && echo -e "\tCalling: wget -cq \"${REPO_REMOTE}/${DIR}/${APPHEAD}.list\"" >>"$LOG_DBUG"
			wget -cq "${REPO_REMOTE}/${DIR}/${APPHEAD}.list" >>"$LOG_ERRS" 2>&1	# download the corresponding list file
			( [ ! -e "${APPHEAD}.list" ] || [ ! -s "${APPHEAD}.list" ] ) && {	# if the file wasn't downloaded, or it's a zero byte file, then...
				( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "WARNING: package list does not exist or download failed (${APPHEAD}.list)." >>"$LOG_ERRS"
				#return 1							  NOTE: since every package may not have one of these, don't error out here...
			}
		fi
	fi

	return 0
}


# Usage syntax: installPackage
# Overview:	performs the actual work of installing the contents of the package to the system via copy or symlink
# Notes:	pwd is irrelevent to this function										< UPDATED - this is no longer true as of 2018/11/27
# 		the directory containing the package(s) should already be entered BEFORE calling this function!
#		this can also performs package validation
#		all the necessary packages should already be obtained and in REPO_SOURCE (via COPY or DOWNLOAD)
installPackage() {
#	local SUCCESS=0										# indicates if the copy-to-RAM was successful (if that is desired)
#	local MARKER=''										# used to convert the install marker (/usr/local/tce.installed) to the XiniX naming convention
#	local SCRIPT=''										# used to convert the service script (/usr/local/etc/init.d) to the XiniX naming convention
	local SOURCE=''
	local TARGET=''
#	local OUTPUT=0
#	local PERM=0
#	local MODE=''

# UPDATED 2025/11/06 - replace APP* variables
#	[ $DEBUG -gt 0 ] && { echo -en "installPackage:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:\n\tpwd     " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }
# UPDATED 2025/11/07
#	[ $DEBUG -gt 0 ] && { echo -en "installPackage:\n\tRAWFILE     |${RAWFILE}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${CPU}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tOPTFILE     |${OPTFILE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }
	[ $DEBUG -gt 0 ] && { echo -en "installPackage:\n\tRAWFILE     |${RAWFILE}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${CPU}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\tOPTFILE     |${OPTFILE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

# UPDATED 2025/11/07
#	md5sum -c "${APPHEAD}.hash" >/dev/null 2>>"$LOG_ERRS" || {				# validate the package checksum before we install anything!!!
#		[ "$SILENT" ] || echo "ERROR: package failed hash checksum (${APPFILE})!" >>"$LOG_ERRS"
#		rm -f "${APPHEAD}".* >>"$LOG_ERRS" 2>&1						# remove the files if they fail (since something is wrong with the package)
#		return 1
#	}
# UPDATED 2025/11/12
#	md5sum -c "${BASENAME}.${EXT_HAS}" >/dev/null 2>>"$LOG_ERRS" || {				# validate the package checksum before we install anything!!!
	( md5sum -c "${BASENAME}.${EXT_HASH}" >/dev/null 2>&1 | sed "s/^${FILENAME}: OK//;s/^m/ \[failure\]\nm/" | tee -a "$LOG_ERRS" | grep -q ^'md5sum: ' ) && {	# download the corresponding manifest file
		showMsg 'failure' "The package file failed hash checksum (${BASENAME}.${EXT_HASH})." 'log'
		rm -f "${BASENAME}".* >>"$LOG_ERRS" 2>&1						# remove the files if they fail (since something is wrong with the package)
		return 1
	}

# UNTESTED
# UPDATED 2025/10/08
#	if [ -e "${DIR_LIST}/${APPFILE}" ] && [ "$RESTORE" ]; then				# if we are updating the installed package with a restore point, then...
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [restore] [creating]"
#		uninstallPackage || return 1
#	if
	if [ -e "${DIR_LIST}/${FILENAME}" ]; then						# if we are updating the installed package, then...
		showMsg 'step' " [unloading]" 'both' 0 0
		unloadPackage || return 1							#   unload the package first no matter what
		[ "$RESTORE" ] && {								#   if we're creating a restore point, then...
			showMsg 'step' " [archiving]" 'both' 0 0
			uninstallPackage || return 1						#      we need to uninstall of the package too
		}
	fi

# UPDATED 2025/11/07
#	# since we have to do this step no matter what, lets setup and mount the package now
#	[ ! -d "${DIR_LOOP}/${APPNAME}.${APPTYPE}" ] && /bin/mkdir -p "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1	# make the mounting directory if it doesn't exist
#	if ( ! /bin/mount 2>>"$LOG_ERRS" | grep -q "/${APPNAME}.${APPTYPE} type squashfs" ); then					# if the package is NOT already mounted and symlinked, then...
#		sudo /bin/mount -t squashfs -o loop,ro,bs=4096 "$APPFILE" "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 || return 1
#	fi
#	find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -type d -name modules 2>>"$LOG_ERRS" | grep -q . && MODULES=TRUE			# if the package has a [/lib/]'modules' directory, then we need to indicate we need to load those modules later
#	find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -type d -name lib 2>>"$LOG_ERRS" | grep -q . && LIBRARIES=TRUE			# if the package has a [/../]'lib' directory, then we need to indicate we need to load them later
	[ ! -d "${DIR_LOOP}/${BASENAME}" ] && /bin/mkdir -p "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1	# make the mounting directory if it doesn't exist
	if ( ! /bin/mount 2>>"$LOG_ERRS" | grep -q "${DIR_LOOP}/${BASENAME} type squashfs" ); then					# if the package is NOT already mounted and symlinked, then...
		sudo /bin/mount -t squashfs -o loop,ro,bs=4096 "${REPO_SOURCE}/${FILENAME}" "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || return 1
	fi
	# check if the package has any libs we need to load later						  NOTE: we check this way because simply checking for the directory can produce false positives
	( ls -1p "${DIR_LOOP}/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE				# NOTE: the "grep -qv '/'$" removes directories from the listing so only files remain (otherwise /lib/modules/ would provide a false positive)
	( ls -1p "${DIR_LOOP}/lib64" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	( ls -1p "${DIR_LOOP}/usr/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	( ls -1p "${DIR_LOOP}/usr/local/lib" 2>/dev/null | grep -qv '/'$ ) && LIBRARIES=TRUE
	# check if the package has a [/usr[/local]]'/lib/modules' directory to indicate we need to load modules later
	[ -d "${DIR_LOOP}/lib/modules" ] || [ -d "${DIR_LOOP}/usr/lib/modules" ] || [ -d "${DIR_LOOP}/usr/local/lib/modules" ] && MODULES=TRUE	# NOTE: we CAN simply check for directories here since files would be packaged under them
# UPDATED 2018/07/14 - since TC packages do NOT adhere to this, we need a more robust solution
#	[ "$APPTYPE" = 'lib' ] && LIBRARIES=TRUE										# if the package has dynamic libraries, then indicate we need to add those to the cache file later

# TEMP CHANGE - this is for TC Compatibility - use config files to differenciate between distros
#MARKER="$(ls -1 "${DIR_LOOP}/${APPNAME}.${APPTYPE}/usr/local/tce.installed" 2>/dev/null)"
#SCRIPT="$(ls -1 "${DIR_LOOP}/${APPNAME}.${APPTYPE}/usr/local/etc/init.d" 2>/dev/null)"
# UPDATED 2025/11/07
#	MARKER="$(ls -1 "${DIR_LOOP}/${APPNAME}.${APPTYPE}${DIR_INST}" 2>/dev/null)"						# NOTE: since XiniX uses different package names than TC, this renames the 'installed marker' to be appropriate; this can be removed once we start adjusting the contents of each package
#	SCRIPT="$(ls -1 "${DIR_LOOP}/${APPNAME}.${APPTYPE}${DIR_INIT}" 2>/dev/null)"						# same, but with the service script
# MOVED 2025/11/10 - below
#	MARKER="$(ls -1 "${DIR_LOOP}/${BASENAME}${DIR_INST}" 2>/dev/null)"							# check for installation scripts
#	SCRIPT="$(ls -1 "${DIR_LOOP}/${BASENAME}${DIR_INIT}" 2>/dev/null)"							# same, but with the service script

# MOVED 2025/11/12 - this is better placed outside of this function
#	# if '-M copy' was passed to this script -OR- the copy-everything-to-RAM file exists -OR- { the copy the system directory (REPO_SYSTEM) contents to RAM file exists -and- we're using that directory (e.g. booting) -and- REPO_SYSTEM and REPO_OPTION are NOT the same (to prevent TC from erroneously loading everything to RAM since those two would be the same) }, then...
#	if [ "$MODE" = 'copy' ] || [ -e "${REPO_PREFIX}/copy_all.flag" ] || ( [ -e "${REPO_PREFIX}/copy_sys.flag" ] && [ "$REPO_SOURCE" = "$REPO_SYSTEM" ] && [ "$REPO_SYSTEM" != "$REPO_OPTION" ] ); then
#echo top
#		[ $DEBUG -gt 0 ] && echo -e "\tInstall by copying..." >>"$LOG_DBUG"
#		showMsg 'step' " [copy]" 'both' 0 0
#		MODE='copy'
#	else
#echo btm
#		[ $DEBUG -gt 0 ] && echo -e '\tInstall using symlinks...' >>"$LOG_DBUG"
#		showMsg 'step' " [link]" 'both' 0 0
#		MODE='link'
#	fi
	showMsg 'step' " [${MODE}]" 'both' 0 0
#echo "DBUG Install"
#return 0

	TEMP=''											# set a default value
	( [ "$FORCE" ] || [ "$VALIDATE" ] ) && {						# if we've been instructed to force (overwrite) -OR- are validating (which always overwrites), then...
		showMsg 'step' " [overwrite]" 'both' 0 0					#   indicate this to the user
		TEMP='f'									#   store the force flag for usage below
		unalias cp >/dev/null 2>&1							#   remove anything existing that would force prompting for overwritting (e.g. alias cp='cp -i')
		unalias ln >/dev/null 2>&1
	}

	# if we only need to copy specified files out of the package, then lets obtain that list
	# NOTES:
	#	- if the passed file does NOT exist, it will NOT be in the filelist.txt
	#	- the final sed adds the directory to the listing so the 'for' loop below works correctly (since it needs preceeding directories, then files)
	#	  EXPLAINED: stores the entire line (with the filename) in the hold buffer; removes the filename from the line (leaving just the directory); prints the line; prints the hold buffer
	#	  SEE: https://stackoverflow.com/questions/12833714/the-concept-of-hold-space-and-pattern-space-in-sed
# UPDATED 2025/11/07
#	if [ "$FILELIST" ]; then
#		find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" ! -type d -name $(echo "$FILELIST" | sed 's/,/ -o -name /g') >"${DIR_TEMP}/filelist.txt" 2>>"$LOG_ERRS"
#	fi
	[ "$FILELIST" ] && find "${DIR_LOOP}/${BASENAME}" ! -type d -name $(echo "$FILELIST" | sed 's/,/ -o -name /g') | sed 'h;s|[^/]*$||;p;x' >"${DIR_TEMP}/filelist.${EXEID}" 2>>"$LOG_ERRS"

	# if a filelist.EXEID file does NOT exist, then we need to process all files in the package, otherwise -N was passed so only certain ones need to be
	# NOTES:
	#	- the sub-shell was constructed using to different conditions so the failure of a prior execution did not erroneously trigger an '||' execution
	#	- the '| tail -n +2' skips the first line of output, which is the current directory and should NOT be processed
	#	- we use EXEID here so simultaneous pax executions can operate without issues
	# WARNING: multiple problems occurred trying to use 'cp' (with these params: -aisL, -LRis, -HRis) but the task failed for one reason or another; the below was used instead
#echo before
	for SOURCE in $([ ! -e "${DIR_TEMP}/filelist.${EXEID}" ] && find "${DIR_LOOP}/${BASENAME}" | tail -n +2; [ -e "${DIR_TEMP}/filelist.${EXEID}" ] && cat "${DIR_TEMP}/filelist.${EXEID}"); do
#echo "iterating |$SOURCE|"
		TARGET="$(echo "$SOURCE" | sed "s:^${DIR_LOOP}/${BASENAME}::")"			# (re)set the value; remove the loopback mount point prefix to store only the target '/directory/filename' string
#echo "target |$TARGET|"
		if [ ! -d "$SOURCE" ]; then							# for each file...
#echo "[F] |$SOURCE|"
			( [ ! "$FORCE" ] && [ ! "$VALIDATE" ] ) && [ -e "${DIRECTORY}${TARGET}" ] && continue	#   if we're NOT forcing -AND- we're NOT validating -AND- the file does exist then go to the next file

			# NOE: the PREFIX will already be part of DIRECTORY (assigned at the beginning of the script processing)
			if [ "$MODE" = 'copy' ]; then
				# NOTE: if the package installation is done with root, the USER:GROUP ownership is preserved (e.g. when installing to /), otherwise it will default to the user and their default group (e.g. when installing to /Users/Public or $HOME)
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    cp -dp${TEMP} \"${SOURCE}\" \"${DIRECTORY}${TARGET}\"" >>"$LOG_DBUG"
				( cp -dp${TEMP} "${SOURCE}" "${DIRECTORY}${TARGET}" 2>&1 | sed "s/^cp: can't preserve ownership.*//;/^$/d;s/^c/ \[failure\]\nc/" | tee -a "$LOG_ERRS" | grep -q ^'cp: ' ) && {		# copy the file from the source directory
					showMsg 'failure' "The package file copy failed (${SOURCE})." 'log'
					return 1
				}
			else
				[ $DEBUG -gt 0 ] && echo -e "\tCalling:    ln -s${TEMP} \"${SOURCE}\" \"${DIRECTORY}${TARGET}\"" >>"$LOG_DBUG"
				( ln -s${TEMP} "${SOURCE}" "${DIRECTORY}${TARGET}" 2>&1 | sed 's/^l/ \[failure\]\nl/' | tee -a "$LOG_ERRS" | grep -q ^'ln: ' ) && {	# symlink the file from the source directory
					showMsg 'failure' "The package file symlink failed (${SOURCE})." 'log'
					return 1
				}
#echo done >>$LOG_DBUG
			fi
			continue
		fi
#echo "[D] |${DIRECTORY}${TARGET}|"
		# if we've made it here, then we're dealing with a directory, so...
		( [ ! "$FORCE" ] && [ ! "$VALIDATE" ] ) && [ -e "${DIRECTORY}${TARGET}" ] && continue	#   if we're NOT forcing -AND- we're NOT validating -AND- the directory does exist then cycle the 'for' loop

		if [ ! -e "${DIRECTORY}${TARGET}" ]; then						# create the directory
#echo creating
			[ $DEBUG -gt 0 ] && echo -e "\tCalling:    mkdir -p \"${DIRECTORY}${TARGET}\"" >>"$LOG_DBUG"
			( mkdir -p "${DIRECTORY}${TARGET}" 2>&1 | sed 's/^m/ \[failure\]\nm/' | tee -a "$LOG_ERRS" | grep -q ^'mkdir: ' ) && {
				showMsg 'failure' "The package directory creation failed (${DIRECTORY}${TARGET})." 'log'
				 return 1;
			}
		fi
	done
#echo "afterwards |$MODE|"

	# remove any -N filelist files
	[ -e "${DIR_TEMP}/filelist.${EXEID}" ] && rm -f "${DIR_TEMP}/filelist.${EXEID}" 2>>"$LOG_ERRS"

	# unmount if we copied
	[ "$MODE" = 'copy' ] && ( sudo /bin/umount "${DIR_LOOP}/${BASENAME}" >>"$LOG_ERRS" 2>&1 || return 1 )

# REMOVED 2025/11/10 - this doesn't look like it's necessary, but left until confirmed
#	MARKER="$(ls -1 "${DIR_LOOP}/${BASENAME}${DIR_INST}" 2>/dev/null)"							# check for installation scripts
#	[ "$MARKER" ] && {											# if a marker is included in the package, then...
#		rm "${DIR_INST}/${MARKER}" >>"$LOG_ERRS" 2>&1								#   remove the symlink created above
#		ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}/${DIR_INST}/${MARKER}" "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1	#   re-symlink using the XiniX naming convention
#	}
#
#	SCRIPT="$(ls -1 "${DIR_LOOP}/${BASENAME}${DIR_INIT}" 2>/dev/null)"							# same, but with the service script
#	[ "$SCRIPT" ] && {											# same with the service script
#		rm "${DIR_INIT}/${SCRIPT}" >>"$LOG_ERRS" 2>&1
#		ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}${DIR_INIT}/${SCRIPT}" "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>&1
#	}

# MOVED 2025/11/12 - this was moved into the main loop below so EVERY file it depends on is added
#	# add the package to the list of dependencies							  NOTE: this lists EVERY dependency for every dependency in one list; not just the dependencies for the requested package!
#	echo "$FILENAME" >>"${DIR_TEMP}/installed.${EXEID}"						# add the package to the cache file for future unloading/uninstalling information

	# update the "install" list
	# if we are NOT validating -AND- installing a requested package [INDEX==1] (not a dependency for it [INDEX>1]) -AND- it needs to be added to the optional.list -AND- the package isn't already in the LIST, then add the package to the LIST file
	[ ! "$VALIDATE" ] && [ "$INDEX" -eq 1 ] && [ ! "$NOLIST" ] && ( ! grep -q $RAWFILE "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS" ) && echo "$FILENAME" >>"${REPO_PREFIX}/${LIST}" 2>>"$LOG_ERRS"

	# defer the execution of any related marker/service scripts from the package(s) until everything is installed - if we are not validating package data!
	[ ! "$VALIDATE" ] && [ -x "${DIR_INST}/${BASENAME}" ] && ( ! grep -q "${DIR_INST}/${BASENAME}" ${DIR_TEMP}/installs.${EXEID} 2>/dev/null ) && echo "${BASENAME}" >>${DIR_TEMP}/installs.${EXEID} 2>>"$LOG_ERRS"
	[ ! "$VALIDATE" ] && [ -e "${DIR_INIT}/${BASENAME}" ] && ( ! grep -q "${DIR_INIT}/${BASENAME}" ${DIR_TEMP}/services.${EXEID} 2>/dev/null ) && echo "${BASENAME}" >>${DIR_TEMP}/services.${EXEID} 2>>"$LOG_ERRS"

	# now add to the 'catalog' of installed packages	
	ln -sf "$(pwd)/${FILENAME}" "${DIR_LIST}/${FILENAME}" 2>>"$LOG_ERRS"
	ln -sf "$(pwd)/${BASENAME}.${EXT_HASH}" "${DIR_LIST}/${BASENAME}.${EXT_HASH}" 2>>"$LOG_ERRS"
	ln -sf "$(pwd)/${BASENAME}.${EXT_DEPS}" "${DIR_LIST}/${BASENAME}.${EXT_DEPS}" 2>>"$LOG_ERRS"

return 0

	# if '-M copy' was passed to this script -OR- the copy-everything-to-RAM file exists -OR- the copy all system directories (REPO_OPTION and REPO_SYSTEM) contents to RAM file exists -and- we're using one of those directories, then...
	if [ "$MODE" = 'copy' ] || [ -e "${REPO_PREFIX}/copy_all.flag" ] || ( [ -e "${REPO_PREFIX}/copy_sys.flag" ] && [ ! "$REPO_TARGET" ] ); then
		[ $DEBUG -gt 0 ] && echo -e "\tInstall by copying..." >>"$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [copy]"
		[ "$VALIDATE" ] && { ( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [overwrite]"; }

		# NOTE: the below 'if' prevents the GNU tar from being a dependency during the boot process (but later for the 2nd stage loading)
		if [ ! "$BOOTING" ]; then							# if we are NOT booting, then GNU tar should be available so use it!
			( [ "$FORCE" ] || [ "$VALIDATE" ] ) && TEMP='-U --overwrite' || TEMP=''

			# NOTE: we use tar instead of cp to implement ownership in the copy process; the '-h' was removed on the extraction because it interferred with overwriting (even though -U was being issued too)
			if [ ! "$FILELIST" ]; then						# if we're copying all files out of the package, then...
				tar -C "${DIR_LOOP}/${APPNAME}.${APPTYPE}" --group=$GROUP . -cf - 2>>"$LOG_ERRS" | tar -C "${PREFIX}/" $TEMP -pxf - 2>>"$LOG_ERRS"
			else									# otherwise we only need to copy certain ones, so...
				tar -C "${DIR_LOOP}/${APPNAME}.${APPTYPE}" --group=$GROUP -T "${DIR_TEMP}/filelist.txt" -cf - 2>>"$LOG_ERRS" | tar -C "${PREFIX}/" $TEMP -pxf - 2>>"$LOG_ERRS"
			fi
		else										# otherwise we are booting and only have access to BB tar and can't execute the above lines, so use copy with the 'core' packages
			cp -dpR "${DIR_LOOP}/${APPNAME}.${APPTYPE}" "${PREFIX}/" 2>>"$LOG_ERRS"
		fi
		if [ $? -ne 0 ]; then
			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "WARNING: The (copy) install failed for ${APPFILE}!" >>"$LOG_ERRS"		# now we will fall back to the symlinking below this segment
			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [error] [attempting]"
		else
# REMOVED 2019/11/9 - we now have the compatibility package created
# LEFT OFF - TEMP CHANGE - this is for TC Compatibility and can remove this 'if' block once we create the tc_compatability package		maybe institute a -c(ompatibility) switch to 'pax' temporarily so it can work with TC packages
#if [ -d '/usr/local/tce.installed' ]; then						# LEFT OFF - do the same for SCRIPTS
#	mv /usr/local/tce.installed/* "$DIR_INST" 2>>"$LOG_ERRS"
#	rm -Rf /usr/local/tce.installed 2>>"$LOG_ERRS"
#	ln -s "$DIR_INST" /usr/local/tce.installed 2>>"$LOG_ERRS"
#fi
#if [ -d '/usr/local/etc/init.d' ]; then
#	mv /usr/local/etc/init.d/* "$DIR_INIT" 2>>"$LOG_ERRS"
#	rm -Rf /usr/local/etc/init.d 2>>"$LOG_ERRS"
#	ln -s "$DIR_INIT" /usr/local/etc/init.d 2>>"$LOG_ERRS"
#fi
			[ "$MARKER" = '' ] && MARKER="$APPNAME"								# if no default marker was included in the package, then default to its name
			[ $DEBUG -gt 0 ] && echo -e "\tMARKER :${MARKER}:\n\tSCRIPT :${SCRIPT}:" >>"$LOG_DBUG"

			# now update the naming conventions of the marker/script
			mv "${DIR_INST}/${MARKER}" "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>/dev/null
			[ "$SCRIPT" != '' ] && mv "${DIR_INIT}/${SCRIPT}" "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>/dev/null
			sudo /bin/umount -d "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 && rmdir "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1				# now that we have successfully copied the package contents to RAM, lets unmount and remove the mount point
			SUCCESS=1												# this indicates we do NOT need to symlink below (but we do need to do the other things down there...)
		fi
	fi

	# if we don't have SUCCESS at this point, then we need to symlink the package contents into the OS (either on purpose or as a fail-safe to the segment above)
	# WARNING: this MUST be two separate 'if' statements so if the one above fails, this one can still be entered!
	if [ $SUCCESS -eq 0 ]; then
		[ $DEBUG -gt 0 ] && echo -e '\tInstall using symlinks...' >>"$LOG_DBUG"
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [link]"

		( [ "$FORCE" ] || [ "$VALIDATE" ] ) && TEMP='f' || TEMP=''

		# WARNING: multiple problems occurred trying to use 'cp' (with these params: -aisL, -LRis, -HRis) but the task failed for one reason or another; the below was used instead
# UPDATED 2025/10/23 - this can now symlink specific files specified via -N
#		for SOURCE in $(find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -name '*'); do
		# if a filelist.txt file does NOT exist, then we need to symlink all files in the package, otherwise -N was passed so only certain ones need to be symlinked
		# NOTE: the sub-shell was constructed using to different conditions so the failure of a prior execution did not erroneously trigger an '||' execution
		for SOURCE in $([ ! -e "${DIR_TEMP}/filelist.txt" ] && find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -name '*'; [ -e "${DIR_TEMP}/filelist.txt" ] && cat "${DIR_TEMP}/filelist.txt"); do
			TARGET="$(echo $SOURCE | sed "s:^${DIR_LOOP}/${APPNAME}.${APPTYPE}::")"		# (re)set the value
			[ ! "$TARGET" ] && continue
			if [ ! -d "$SOURCE" ]; then							# for each file...
				if [ ! "$VALIDATE" ]; then						#   if this is a typical package install, then...
					[ -e "$TARGET" ] && [ ! "$FORCE" ] && continue			#     if the file doesn't exist -AND- we aren't forcing the install, then go to the next file
				else									#   otherwise, we are validating so...
					[ -e "$TARGET" ] && [ "$(readlink $TARGET)" = "$SOURCE" ] && [ "$(stat -c %G $TARGET 2>/dev/null)" = "$GROUP" ] && [ "$(stat -c %a $TARGET 2>/dev/null)" = '777' ] && continue	# if it exists and points to the correct source file -AND- the ownership and permissions are correct, then go to the next one	WARNING: do NOT implement PREFIX here!!!
					( [ "$SILENT" ] || [ "$QUIET" ] ) || {				#   if we made it here then there was a problem, so...
						[ $OUTPUT -eq 0 ] && { echo " [detected]"; OUTPUT=1; }
						echo -e "   Misconfigured: $TARGET"
					}
				fi
				ln -s$TEMP "$SOURCE" "${PREFIX}${TARGET}" >>"$LOG_ERRS" 2>&1 || return 1	#   if the file does NOT exist, then symlink
				continue								#   skip further processing
			fi

			# if we've made it here, then we're dealing with a directory, so...
			if [ ! "$VALIDATE" ]; then
				[ -e "$TARGET" ] && continue						# if the directory already exists, skip further processing
			else
				[ -e "$TARGET" ] && [ "$(stat -c %G $TARGET 2>/dev/null)" = "$GROUP" ] && [ "$(stat -c %a $TARGET 2>/dev/null)" = "$(stat -c %a $SOURCE 2>/dev/null)" ] && continue
				( [ "$SILENT" ] || [ "$QUIET" ] ) || {
					[ $OUTPUT -eq 0 ] && { echo " [detected]"; OUTPUT=1; }
						echo -e "   Misconfigured: $TARGET"
				}
			fi
			PERM=$(stat -c %a "$SOURCE" 2>/dev/null || echo 755)				# get the permissions of the original directory from the squashfs file
			[ ! -e "${PREFIX}$TARGET" ] && { mkdir -p "${PREFIX}${TARGET}" >>"$LOG_ERRS" 2>&1 || return 1; }		# create the directory in the OS	NOTE: we had to add the '-e' check since VALIDATE can go here even if the directory exists (owner or perm can be wrong)
			chown -h :$GROUP "${PREFIX}${TARGET}" >>"$LOG_ERRS" 2>&1				# apply the appropriate group and permissions
			chmod $PERM "${PREFIX}${TARGET}" >>"$LOG_ERRS" 2>&1
		done

		[ "$MARKER" != '' ] && {											# if a marker is included in the package, then...
			rm "${DIR_INST}/${MARKER}" >>"$LOG_ERRS" 2>&1								#   remove the symlink created above
# TEMP CHANGE - this is for TC Compatibility - use config files to differenciate between distros
#ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}/usr/local/tce.installed/${MARKER}" "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1
			ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}/${DIR_INST}/${MARKER}" "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1	#   re-symlink using the XiniX naming convention
		}
		[ "$SCRIPT" != '' ] && {											# same with the service script
			rm "${DIR_INIT}/${SCRIPT}" >>"$LOG_ERRS" 2>&1
# TEMP CHANGE - this is for TC Compatibility - use config files to differenciate between distros
#ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}/usr/local/etc/init.d/${SCRIPT}" "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>&1
			ln -s$TEMP "${DIR_LOOP}/${APPNAME}.${APPTYPE}${DIR_INIT}/${SCRIPT}" "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>&1
		}
	fi

	# remove any -N filelist files
	[ -e "${DIR_TEMP}/filelist.txt" ] && rm -f "${DIR_TEMP}/filelist.txt" 2>>"$LOG_ERRS"

	# remove the 0-byte marker/scripts (since we now have the catalog directory)
	[ ! -s "${DIR_INIT}/${APPNAME}.${APPTYPE}" ] && rm "${DIR_INIT}/${APPNAME}.${APPTYPE}" 2>/dev/null
	[ ! -s "${DIR_INST}/${APPNAME}.${APPTYPE}" ] && rm "${DIR_INST}/${APPNAME}.${APPTYPE}" 2>/dev/null

	# now add to the 'catalog' of installed packages
	ln -sf "$(pwd)/${APPFILE}" "${DIR_LIST}/${APPFILE}" 2>>"$LOG_ERRS"
	ln -sf "$(pwd)/${APPHEAD}.hash" "${DIR_LIST}/${APPHEAD}.hash" 2>>"$LOG_ERRS"
	ln -sf "$(pwd)/${APPHEAD}.deps" "${DIR_LIST}/${APPHEAD}.deps" 2>>"$LOG_ERRS"

	# update the appropriate list contents
# UPDATED 2025/11/10
#	( ! grep -q "$APPFILE" "${DIR_TEMP}/"* 2>>"$LOG_ERRS" ) && echo "$APPFILE" >> "$EXEID"		# if the package isn't already part of an existing list, then add the package to the cache file for future uninstalling information
	( ! grep -q "$APPFILE" "${DIR_TEMP}/"* 2>>"$LOG_ERRS" ) && echo "$APPFILE" >> "${DIR_TEMP}/${EXEID}"		# if the package isn't already part of an existing list, then add the package to the cache file for future uninstalling information

# UPDATED 2025/10/23 - the -L option is now a negation
#	[ ! "$VALIDATE" ] && [ "$INDEX" -eq 1 ] && [ "$NOLIST" ] && ( ! grep -q $RAWFILE "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS" ) && echo "$RAWFILE" >> "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS"	# if we are updating the system from (one of the) requested packages and not one of its dependencies (via INDEX==1) -AND- we're installing -AND- we're not only loading (no adjustment to LIST) -AND- the package isn't already in the LIST, then add the package to the LIST file
	[ ! "$VALIDATE" ] && [ "$INDEX" -eq 1 ] && [ ! "$NOLIST" ] && ( ! grep -q $RAWFILE "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS" ) && echo "$RAWFILE" >> "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS"	# if we are updating the system from (one of the) requested packages and not one of its dependencies (via INDEX==1) -AND- we're installing -AND- we're not only loading (no adjustment to LIST) -AND- the package isn't already in the LIST, then add the package to the LIST file

	# defer the execution of any related marker/service scripts from the package(s) until everything is installed - if we are not validating package data!
	[ ! "$VALIDATE" ] && [ -x "${DIR_INST}/${APPNAME}.${APPTYPE}" ] && ( ! grep -q "${DIR_INST}/${APPNAME}.${APPTYPE}" ${DIR_TEMP}/installs.list 2>/dev/null ) && echo "${DIR_INST}/${APPNAME}.${APPTYPE}" >> ${DIR_TEMP}/installs.list 2>>"$LOG_ERRS"		# if the package has an 'initialize' script post-install, then...
	[ ! "$VALIDATE" ] && [ -e "${DIR_INIT}/${APPNAME}" ] && ( ! grep -q "${DIR_INIT}/${APPNAME}" ${DIR_TEMP}/services.list 2>/dev/null ) && echo "${DIR_INIT}/${APPNAME}" >> ${DIR_TEMP}/services.list 2>>"$LOG_ERRS"		# if the package has a services start/stop script, then...
	return 0
}


# Usage syntax: unloadPackage
# Overview:	performs the actual work of deleting the package contents from the system no matter if they were copied or symlinked - with the option of a complete uninstallation
# Notes:	pwd is irrelevent to this function										< UPDATED - this is no longer true as of 2025/11/12
# 		the directory containing the package(s) should already be entered BEFORE calling this function!
#		if [ "$RAWFILE" != "$APPFILE" ] then a specific version was passed
#		http://forum.tinycorelinux.net/index.php/topic,5012.msg26650.html#msg26650
unloadPackage() {
	local PARAMS=''
	local FILE=''

# LEFT OFF 2025/11/10 - there appear to be no checks if the package is depended on by other software before unloading occurs!!!!

	[ $DEBUG -gt 0 ] && { echo -en "unloadPackage:\n\tRAWFILE     |${RAWFILE}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${CPU}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|\n\tVERBASE     |${VERBASE}|\n\tOPTFILE     |${OPTFILE}|\n\tREPO_SOURCE |${REPO_SOURCE}|\n\tDIRECTORY   |${DIRECTORY}|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

return 0

	[ $DEBUG -gt 0 ] && echo -e "unloadPackage:\n\tRAWFILE :${RAWFILE}:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:" >>"$LOG_DBUG"

# UPDATED 2025/10/22 - merged -P with -U
#	[ $PURGE -gt 0 ] && [ ! -e "${DIR_LIST}/${APPFILE}" ] && {				# if the package has been marked for uninstallation -AND- it currently is NOT installed, then...
	[ "$PURGE" != '' ] && [ ! -e "${DIR_LIST}/${APPFILE}" ] && {				# if the package has been marked for uninstallation -AND- it currently is NOT installed, then...
		uninstallPackage || return 1							#   uninstall the package files
		return 0									#   no need to process anything further!
	}
# UPDATED 2025/10/22 - merged -P with -U
#	[ $PURGE -eq 1 ] && PARAMS='! -path "*/etc/*"'						# if we have been instructed to NOT delete any 'etc' files, then add these parameters to the 'find' calls below   http://www.cyberciti.biz/faq/find-command-exclude-ignore-files/
# UPDATED 2025/10/2 - merged with -u
#	[ "$PURGE" = 'app' ] && PARAMS='! -path "*/etc/*"'					# if we have been instructed to NOT delete any 'etc' files, then add these parameters to the 'find' calls below   http://www.cyberciti.biz/faq/find-command-exclude-ignore-files/
	[ "$PURGE" = 'delete' ] && PARAMS='! -path "*/etc/*"'					# if we have been instructed to NOT purge any 'etc' files, then add these parameters to the 'find' calls below   http://www.cyberciti.biz/faq/find-command-exclude-ignore-files/

	if [ -e "${DIR_INIT}/${APPNAME}" ]; then						# if the package has a service start/stop script, then indicate we need to execute it before continuing
		[ $DEBUG -gt 0 ] && echo -e "\tPackage has service script...\n\tCalling: \"${DIR_INIT}/${APPNAME}\" stop" >>"$LOG_DBUG"
		"${DIR_INIT}/${APPNAME}" stop >>"$LOG_ERRS" 2>&1 || return 1
	fi

	if ( /bin/mount 2>>"$LOG_ERRS" | grep -q "/${APPNAME}.${APPTYPE} type squashfs" ); then	# if the package has been mounted and symlinked, then...
		[ $DEBUG -gt 0 ] && echo -e "\tPackage is symlinked...\n\tCalling: sudo /bin/umount \"${DIR_LOOP}/${APPNAME}.${APPTYPE}\"" >>"$LOG_DBUG"
		sudo /bin/umount "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 || return 1				#   umount the squashfs file to make sure no contents are being used by other software (thanks Marco Caminati)

		[ $DEBUG -gt 0 ] && echo -e "\tCalling: sudo /bin/mount \"./$APPFILE\" \"${DIR_LOOP}/${APPNAME}.${APPTYPE}\" -t squashfs -o loop,ro,bs=4096" >>"$LOG_DBUG"
		sudo /bin/mount "./$APPFILE" "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -t squashfs -o loop,ro,bs=4096 >>"$LOG_ERRS" 2>&1 || return 1			# remount it again for further processing
	else											# otherwise it was a copy-to-RAM, so...
		[ ! -e "${DIR_LOOP}/${APPNAME}.${APPTYPE}" ] && { mkdir -p "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 || return 1; }			# if the mount point doesn't exist, then create it!

		[ $DEBUG -gt 0 ] && echo -e "\tPackage is in the RAM...\n\tCalling: sudo /bin/mount \"./$APPFILE\" \"${DIR_LOOP}/${APPNAME}.${APPTYPE}\" -t squashfs -o loop,ro,bs=4096" >>"$LOG_DBUG"
		sudo /bin/mount "./$APPFILE" "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -t squashfs -o loop,ro,bs=4096 >>"$LOG_ERRS" 2>&1 || return 1			# now mount it for processing

		for FILE in $(find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" ! -type d 2>>"$LOG_ERRS" | sed "s:${DIR_LOOP}/${APPNAME}.${APPTYPE}::"); do		# scan to make sure that no software in the package is being used
			fuser "$FILE" >>"$LOG_ERRS" 2>&1 && return 1				#   if one of the files in the package is currently in use, then exit this function	https://liquidat.wordpress.com/2015/08/26/short-tip-show-processes-accessing-a-file-fuser-lsof/   http://unix.stackexchange.com/questions/60492/whats-the-difference-between-lsof-and-fuser-uvm
		done
	fi

	[ $DEBUG -gt 0 ] && echo -e "\tChecking for modules..." >>"$LOG_DBUG"
	find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -type d -name modules 2>>"$LOG_ERRS" | grep -q . && MODULES=TRUE			# if the package has a [/lib/]'modules' directory, then we need to indicate we need to unload those modules later
	find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" -type d -name lib 2>>"$LOG_ERRS" | grep -q . && LIBRARIES=TRUE			# if the package has a [/../]'lib' directory, then we need to indicate we need to load them later
# UPDATED 2018/07/14 - since TC packages do NOT adhere to this, we need a more robust solution
#	[ "$APPTYPE" = 'lib' ] && LIBRARIES=TRUE										# if the package has dynamic libraries, then indicate we need to remove those from the cache file later

	[ $DEBUG -gt 0 ] && echo -e "\tRemoving package contents from filesystem..." >>"$LOG_DBUG"
	for FILE in $(eval find "${DIR_LOOP}/${APPNAME}.${APPTYPE}" $PARAMS 2>>"$LOG_ERRS" | sed "s:${DIR_LOOP}/${APPNAME}.${APPTYPE}::" | sort -r); do		# if we've made it here, delete all the files/dirs contained in the package from the OS
		if [ ! -d "$FILE" ]; then rm -f "$FILE" >>"$LOG_ERRS" 2>&1 || return 1						#   if the iterated FILE is anything but a directory (e.g. device file, symlink, text file, ...), then delete it!
		elif [ ! "$(ls -A "$FILE" 2>/dev/null)" ]; then rmdir "$FILE" >>"$LOG_ERRS" 2>&1; fi				#   otherwise it is a directory, so check if it's empty and delete it if so! NOTE: we do NOT error out here if we can't delete it!
	done

	[ -e "${DIR_INIT}/${APPNAME}" ] && rm -f "${DIR_INIT}/${APPNAME}" >>"$LOG_ERRS" 2>&1					# delete any service script (if it hasn't already above; in the event we have a script with a different name than the package [e.g. a specific version number])
	[ -e "${DIR_INST}/${APPNAME}.${APPTYPE}" ] && rm -f "${DIR_INST}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1		# delete the tce.installed marker (if it hasn't already above; in the event we have a marker with a different name than the package [e.g. a specific version number])
	sudo /bin/umount -d "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1 || return 1					# finally umount the package
	rmdir "${DIR_LOOP}/${APPNAME}.${APPTYPE}" >>"$LOG_ERRS" 2>&1								# delete the packages mount point

# UPDATED 2025/10/22 - merged -P with -U
#	[ "$PURGE" -gt '0' ] && {
	[ "$PURGE" != '' ] && {
		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [uninstall]"
		uninstallPackage || return 1											# if the package has been marked for uninstallation, then...
	}
# LEFT OFF - when installing, and a file exists (e.g. grep symlink to busybox), then rename to FILE.-PACK.TYPE (or 'SYS' if not part of package); when the PACK.TYPE is uninstalled and one of those files exists, restore it
#		is this necessary if we are creating restore points?

	[ -e "${DIR_LIST}/${APPFILE}" ] && rm -f "${DIR_LIST}/${APPHEAD}."* >>"$LOG_ERRS" 2>&1					# delete the 'catalog' item
# UPDATED 2025/11/10
#	[ "$EXEID" ] && sed -i "/${RAWFILE}/d" "${EXEID%/*}/"*									# remove the package from all the cache files (since it was just unloaded!)	  NOTE: this was if a dep is in another list, but it doesn't have any deps and can be unloaded too
	[ "$EXEID" ] && sed -i "/${RAWFILE}/d" "${DIR_TEMP}/"*									# remove the package from all the cache files (since it was just unloaded!)	  NOTE: this was if a dep is in another list, but it doesn't have any deps and can be unloaded too

# UPDATED 2025/10/22 - merged -P with -U
#	[ "$INDEX" -eq 1 ] && [ "$PURGE" -gt '0' ] && sed -i "/${RAWFILE}/d" "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS"		# if we are updating the system from (one of the) requested packages and not one of its dependencies (via INDEX==1) -AND- we're unloading -AND- we're are actually purging (uninstalling), then remove the package from the onboot.lst file
	[ "$INDEX" -eq 1 ] && [ "$PURGE" != '' ] && sed -i "/${RAWFILE}/d" "${REPO_PREFIX}/$LIST" 2>>"$LOG_ERRS"		# if we are updating the system from (one of the) requested packages and not one of its dependencies (via INDEX==1) -AND- we're unloading -AND- we're are actually purging (uninstalling), then remove the package from the onboot.lst file
	return 0
}


# Usage syntax: uninstallPackage
# Overview:	performs the work of the actual removal of the package files (not contents - see unloadPackage()), optionally to a restore point
# Notes:	this should be called after the package has been unloaded first!!!
# 		the directory containing the file to uninstall should already be entered BEFORE calling this function!
uninstallPackage() {
	[ $DEBUG -gt 0 ] && echo -e "uninstallPackage:" >>"$LOG_DBUG"
	if [ ! "$RESTORE" ]; then								# if we do NOT need a restore point, then...
		[ $DEBUG -gt 0 ] && echo -e "\tSkip creating a restore point...\n\trm -f ${APPHEAD}.*" >>$LOG_DBUG
		rm -f "${APPHEAD}".* >>"$LOG_ERRS" 2>&1 || return 1				# just delete the packages' files (e.g. .deps, .hash, .soft, ...) and exit
		return 0
	fi

	# if we've made it here then we need to create a restore point
	[ $DEBUG -gt 0 ] && echo -e "\tCreating a restore point..." >>$LOG_DBUG
	if [ ! -e "${REPO_RESTOR}" ] && [ -e "${DIR_MOUNT}/DATA/Links" ]; then			# if the root-level restore directory doesn't exist (e.g. /var/restore/2017-01-01 > /var/restore) -AND- there's a DATA, then...
		if [ ! -e "${DIR_MOUNT}/DATA/Links${REPO_RESTOR}" ]; then
			mkdir -p "${DIR_MOUNT}/DATA/Links${REPO_RESTOR}" >>"$LOG_ERRS" 2>&1 || {					#   create the restore directory on the DATA partition so that it actually gets preserved between reboots of the device
				echo "ERROR: the restore directory could not be created." >>"$LOG_ERRS"				# NOTE: we only write this to the log
				return 1
			}
		fi
		ln -sf "${DIR_MOUNT}/DATA/Links${REPO_RESTOR}" "${REPO_RESTOR}" >>"$LOG_ERRS" 2>&1 || {				#   now symlink to it so we can reference its contents
			echo "ERROR: The symlink to the restore directory could not be created." >>"$LOG_ERRS"			# NOTE: we only write this to the log
			return 1
		}
	fi

	# now create a unique name for the restore point: ACTION PACKAGE_NAMES/DIR_NAME (e.g. Updating sdl)
	TEMP="$(date +%F)/"
	[ "$INSTALL" ] && ( [ "$FORCE" ] || [ "$RESTORE" ] ) && TEMP="${TEMP}Updating ${APPNAME}.${APPTYPE}"			# add a description of this process to the restore point
# UPDATED 2025/10/22 - merged -P with -U
#	[ "$UNLOAD" ] && [ "$PURGE" -gt '0' ] && TEMP="${TEMP}Uninstalling ${APPNAME}.${APPTYPE}"
	[ "$UNLOAD" ] && [ "$PURGE" != '' ] && TEMP="${TEMP}Uninstalling ${APPNAME}.${APPTYPE}"

	# NOTE: the below line will create the entire REPO_RESTOR directory structure if there is no DATA, or just the date directory in the event there is one
	[ ! -e "${REPO_RESTOR}/${TEMP}" ] && { mkdir -p "${REPO_RESTOR}/${TEMP}" >>"$LOG_ERRS" 2>&1 || return 1; }		# if the restore point directory doesn't exist, then create it!

	readlink "$APPFILE" >/dev/null 2>&1 && {												# if a particular prior version of the package that was installed (designated via a symlink), then...
		[ $DEBUG -gt 0 ] && echo -e "\tPrior version...\n\tmv -f \"$(readlink ${APPFILE} | head -c -6)\".* \"${REPO_RESTOR}/${TEMP}\"" >>"$LOG_DBUG"
		mv -f "$(readlink "${APPFILE}" 2>>"$LOG_ERRS" | head -c -6)".* "${REPO_RESTOR}/${TEMP}" >>"$LOG_ERRS" 2>&1 || return 1		# move the actual files referenced by the symlinks to the restore point (which would be the numerical named files)
	}
	[ $DEBUG -gt 0 ] && echo -e "\tmv -f ${APPHEAD}.* \"${REPO_RESTOR}/${TEMP}\"" >>"$LOG_DBUG"
	mv -f "${APPHEAD}".* "${REPO_RESTOR}/${TEMP}" >>"$LOG_ERRS" 2>&1 || return 1		# now move the iterated dependency into the restore point	NOTE: it will be symlinks if VERSION has a value
	return 0
}


# Usage syntax: validatePackage													REMOVED 2025/11/06
# Overview:	validates the package is 'correct', including all the dependencies are installed, all data files/dirs
#		from packages are installed, validate contents md5sum checks, ownership and permissions are correct
# Notes:	the directory containing the file to validate should already be entered BEFORE calling this function!
validatePackage() {
	( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${APPNAME}: [data]"
	( ! /bin/mount 2>>"$LOG_ERRS" | grep -q "/${APPNAME}.${APPTYPE} type squashfs" ) && MODE='copy' || MODE='link'	# if the package is not symlink, then indicate we need to copy it!
	installPackage || exitGracefully 1
	( [ "$SILENT" ] || [ "$QUIET" ] ) || echo " [done]"
	return 0
}




# LOAD VARIABLE PERSONALIZATION

[ -e "${DIR_CONF}/config" ] && . "${DIR_CONF}/config"						# overwrite any of the variables set above by reading in a global config file
# UPDATED 2025/10/25 - dash as sh threw errors
#[ -e "${HOME}/.${DIR_CONF:1}/config" ] && . "${HOME}/.${DIR_CONF:1}/config"			# same using a personalized config file - using XSB
#[ -e "${HOME}/.${DIR_CONF##*/}/config" ] && . "${HOME}/.${DIR_CONF##*/}/config"			# same using a personalized config file - using LSB
[ -e "${HOME}/.$(echo "${DIR_CONF}" | tail -c +2)/config" ] && . "${HOME}/.$(echo "${DIR_CONF}" | tail -c +2)/config"			# same using a personalized config file - using XSB
[ -e "${HOME}/.${DIR_CONF##*/}/config" ] && . "${HOME}/.${DIR_CONF##*/}/config"			# same using a personalized config file - using LSB




# SET DEFAULT/UNINITIALIZED VARIABLE VALUES							  NOTE: we have to set these here since they rely on functions above

# LEFT OFF - move these back up to the top of the script and eval them down here
[ ! "$LIST" ] && LIST="$( ( checkBootcode list2 && [ -e "${REPO_PREFIX}/$(getBootcode list2)" ] ) && getBootcode list2 || echo 'optional.list')"				# stores a specified secondary boot list (if it exists) -OR- uses the default 'optional.list' otherwise
[ ! "$FLAG" ] && FLAG="${LIST%.*}.flag"																		# store an accompanying blacklist flag file for packages that should NOT be installed from the secondary boot list (or their dependencies)
[ ! "$MODE" ] && MODE="$(TEMP="$(getBootcode mode)"; ( [ "$TEMP" = 'conservative' ] || readlink $REPO_PREFIX | grep -q DATA ) && echo 'link' || echo 'copy')"			# store the install mode: copy, (sym)link	NOTE: symlink by default if we are in a 'conservative' operation mode -OR- we are using DATA as the source of the repo




# SCRIPT PARAMETER PROCESSING

if [ "$1" = '--help' ]; then									# displays ACTION and OPTION help for this script
	echo
	echo " This script provides package management for a Linux distro that currently does"
	echo " not have this functionality, or is interested in switching from its existing"
	echo " implementation. The packages created and used by this system can be copied out"
	echo " or mounted and linked-to using the read-only and compact squashfs file system."
	echo
	echo "  Usage: ${0##*/} [OPTIONS] ACTION PACKAGE(S) [DIRECTORY]"
	echo
	echo '  ACTIONS:'
# LEFT OFF - implement the below; so for example say we are using the frame buffer and upgrade to Xorg, the drivers package for the device will have the Xorg driver as an optional dependency that would now be installed with this action
#	echo '	-a   adds optional dependencies for installed software'
#	echo '	-b   '
	echo '	-c   copy local packages to another directory'				# old '-t' > new '-c'	# NOTE: if you want to copy local and remote, use '-d' with '-S' and/or DIRECTORY
	echo '	-d   download package(s) only'
	echo '	-e   extract local package(s) contents'
	echo '	-f   find which local package(s) a file belongs to'
#	echo '	-g   '
#	echo '	-h   '
	echo '	-i   install package(s)'
#	echo '	-j   '
#	echo '	-k   '
# VER2 - also so packages that are downloaded, but not installed (e.g. from using the -L option so a user can delete them if desired)
	echo '	-l   list all currently installed packages'
	echo '	-m   make a new package (requires DIRECTORY)'					# this makes a new .soft package tarball based on the passed directory; 	NOTE: you can just have the .make file call builder to do all the heavy lifting
#	echo '	-n   '
# LEFT OFF -
#	echo '	-o   open a fifo for (client) communication'		# this will allow remote administration; uses DIR_TEMP/input
# LEFT OFF - check for updates to installed packages (compare the version numbers in the local .list files vs ones dl'ed from repo server); use cron to do this regularly
#	echo '	-p   process updates for installed packages'
#			check		simply checks for updates and notifies
#			download	checks and downloads updates
#			install		checks, downloads, and installs updates
#	echo '	-q   '
	echo '	-r   restore package(s) from a restore point'					# NOTE: this does not perform any uninstallation of newer running version or installation of the restored version, just restores the software (and deps) to the 'optional' directory (as if the package had just be downloaded)
# LEFT OFF - implement the below; it's like apt-search; this needs to work with both directory structure and URL submissions; make it so you can search for packages (names) or files (within a package, like the -f action but for all packages in the repo)
#		maybe create a php file that can be used in TC repo to allow this
#	echo '	-s   search the repo to find matches of passed term(s)'
#		non-db queries will need to download all the manifest files and grep them to find the file
#		db queries will need to utilize another variable REPO_QUERY specifying the URI of the script to submit the search to
	echo '	-t   show the dependency trees of package(s)'
	echo '	-u   uninstall package(s): unload, delete, purge'
	echo "	-v   validate package(s) info: data, deps"					# makes sure all data files/dirs from packages are installed, all the dependencies are installed, validate contents md5sum checks, ownership and permissions are correct; data=files,dirs,hash,owner,perms
#	echo '	-w   '
#	echo '	-x   '
#	echo '	-y   '
#	echo '	-z   '
	echo
	echo '	--help      shows this screen'
	echo '	--version   displays the software version'
	echo
	echo '  OPTIONS:'
# LEFT OFF - implement
#	echo '	-A   approval code/key from the server when making purchases'			# so after the software is purchased, the code/key can be passed as authentication to download the software package(s)
	echo '	-B   indicates we are currently booting the system'				# use this to indicate everything gets installed to root (PREFIX=/) and obtain files from REPO_SYSTEM
	echo '	-C   specifies an alternative CPU architecture: i32, i64, r32, r64'		# this allows for alternative CPU software downloads		r01 (raspi 0 and 1), r23 (raspi 2 and 3)
# UPDATED 2025/10/22
#	echo '	-D   sets the directory prefix when installing/unloading packages'		# this can be used to install to / (OS - admin permissions), /Users/.Public (everyone), $HOME (personal) while retaining the bin, sbin, lib, etc structure
	echo '	-D   sets the directory prefix when (un)installing packages'			# this can be used to install to / (OS - admin permissions), /Users/.Public (everyone), $HOME (personal) while retaining the bin, sbin, lib, etc structure
	echo '	-E   include extra package files: all, code, cpio, info, list, make'				# not installed by default to keep size down
	echo '	-F   force the ACTION to take place'						# NOTE: this ignores the package installed status on the existing system so if we need to download packages to another device (e.g. installing XiniX to other media) we can do so
#	echo '	-G   '
#	echo '	-H   '
	echo '	-I   list of dependencies to ignore during unload/uninstall'			# for example, web.de can be listed for theme uninstalls
	echo '	-J   just process the listed packages, not any dependencies'
	echo '	-K   specifies an alternative kernel name (4.1.6_xinix)'			# this allows for alternative kernel software downloads
# UPDATED 2025/10/23 - make this a negation instead of an inclusion, meaning we add to the list by default, but using the -L prevents this from happening
#	echo '	-L   adds the software to the (optional.)list when installing'			# this only is useful when installing
	echo '	-L   prevent package addition to (optional.)list when installing'			# this only is useful when installing
	echo '	-M   defines the package install mode: copy, link (default)'		# old '-R' > new '-M copy'		NOTE: if the OS is run from RAM, then the 'copy' value will copy into RAM, if it is on a disk, then it copies to the disk
	echo '	-N   do NOT install all files in the package, just those specified'		# allows users to install desired file(s) from a package so all the contents don't get installed (to keep the system as small as possible); keeps attack vector to a minimum
# LEFT OFF - implement the 'html' and 'xml' values
	echo '	-O   how output is displayed: none, fifo, text, xml, xmLive'		# old '-Q' > new '-O none'		NOTE: this defines the way the output is shown
# UPDATED 2025/10/22 - merged -P with -U
#	echo '	-P   purges all files of the uninstalled packages including configs'		# data ALWAYS is retained though! (e.g. mysql databases)
#	echo '	-P   '
	echo '	-Q   quiets the output to only show errors'				# old '-q' > new '-Q'
	echo '	-R   create a restore point when uninstalling'				# old '-N' > new 'absence of value'; if you want to create a restore point, you must now specify the flag!
	echo '	-S   changes the source directory/repo to obtain software from'			# mainly used when creating installation media to pull the files from an existing BOOT instead of an online repo
	echo '	-T   specifies the package type: bin, dev, doc, drv, gir, lib, loc'
# UPDATED 2025/10/22 - merged -P with -U
#	echo '	-U   uninstalls all files of the package excluding configs'		# old '-p' > new '-U'
# UPDATED 2025/10/23 - merged with -u
#	echo '	-U   uninstalls specified package files: all, app (leaves configs)'	# old '-p' > new '-U'		# data ALWAYS is retained though! (e.g. mysql databases)
#	echo '	-U   '
	echo '	-V   the specific version of a package to install'
	echo '	-W   installs all packages in .deps file, including optional'		# old '-A' > new '-W'			this is so that if a user is installing a drivers set, any optional software is also installed (e.g. [xf86_video_intel|xorg])
# VER2 - proxy other actions via ssh so that administrators can push software to clients, or reinstall/delete software that's currently installed
	echo '	-X   obtain packages via proxy using another device'				# Can be used when one location has little or no Internet access. For example, @home has bad internet connection, but work is good, can dl @work for @home.
#	echo '	-Y   '
#	echo '	-Z   '
	echo
	echo '  NOTES:'
	echo "	The '-e' ACTION will always overwrite data due to the unsquashfs binary"
	echo "	     always exiting with success - even when it fails if data already"
	echo "	     exists in the target destination."
	echo "	The '-i' ACTION first checks locally, then uses the repo."
	echo "	The '-m' ACTION can be used with pre-compiled software, or if a .make"
	echo "	     file is present, it will execute it to compile everything."
	echo "	     NOTES:"
	echo "	     - only one package can be processed per script execution"
	echo "	     - place the .make file alongside the source code directory"
# UPDATED 2025/10/23
#	echo "	     - the source code directory will also be used with packaging, so make"
#	echo "         sure to swap out its contents for the compiled software"
	echo "	     - if using a .make file, install the compiled software into a"
	echo "	       'package' directory alongside the .make file and source code"
	echo "	The '-r' ACTION does not perform an uninstallation of currently running"
	echo "	     versions, nor installation of the restored version itself, but"
	echo "	     simply restores the package files to the 'optional' directory to"
	echo "	     allow re-installation when you see fit to do so."
	echo "	The '-u' ACTION will always leave user data in place (docs, pics, etc)."
	echo "	     NOTES:"
	echo "	     - Unloading removes the application files, but leaves the config"
	echo "	       files and package for easy future re-installation"
	echo "	     - Deleting leaves the configs, but removes the application files"
	echo "	       and the package so it would need to be re-downloaded before"
	echo "	       another installation could occur"
	echo "	     - Purging does the same as deleting, but also deletes the config"
	echo "	       files as well"
	echo "	The '-I' OPTION value must be comma separated."
	echo "	The '-L', '-M', and '-V' OPTIONS can only be used with the '-i' ACTION."
	echo "	The '-N' OPTION takes a comma separated list of filenames."
	echo "	The '-O' OPTION must be the first parameter (to catch init errs)."
	echo "	The '-S' OPTION can take a directory or URL as its value."
	echo "	The '-T' OPTION can only be used once per call, so all the packages"
	echo "	     need to be of the same type. Alternatively, you can skip using"
	echo "	     this option and specify the full name of each package."
# UPDATED 2025/10/22 - merged -P with -U
#	echo "	The '-P' and '-U' OPTIONS can only be used with the '-u' ACTION and"
	echo "	The '-X' OPTION can only be used with the '-c' and '-d' ACTIONS."
	echo "	The '-O xmLive' OPTION does NOT encapsulate with <s> tags, so assume"
	echo "	     success unless an <f> tag is relayed."
	echo "	When using '-O fifo', the fifo must be managed by the calling script"
	echo "	     or binary, and must use DIR_TEMP/output as its location."
	echo "	When using the '-V' OPTION, you can only list one package at a time."
# REMOVED 2025/10/29 - this looks like part of an old description
#	echo "	     NAME.all.src.make file exists, it will use that to compile."
	echo "	The PACKAGE(S) value can be:"
	echo "	     - a file containing a list (one package per line)"
	echo "	     - directory containing the package(s)"
	echo "	     - or a space separated list of package names"
	echo "	The DIRECTORY as the last parameter must be:"
	echo "	     - a full path: /tmp/pax/"
	echo "	     - or a relative path: ./pax"
	echo "	     - or have a trailing slash: pax/"
	echo "	The presence of a REPO_PREFIX/copy_all.flag file will indicate that"
	echo "	     all packages will be loaded into RAM."
	echo "	The presence of a REPO_PREFIX/copy_sys.flag file will indicate that"
	echo "	     all the packages in REPO_SYSTEM will be loaded into RAM.  This"
	echo "	     only takes place if REPO_SYSTEM and REPO_OPTION are different."
	echo
	echo '  EXAMPLES:'
	echo '	Copy packages from optional to specified directory:'
# LEFT OFF - we need to use -S as the source path
	echo "	     ${0##*/} -c package1 package2 /target/path"
	echo '	Copy packages from specific directory to specified directory:'
	echo "	     ${0##*/} -S /source/path -c package1 package2 /target/path"
	echo '	Download a package from the repo:'
	echo "	     ${0##*/} -d package"
	echo '	Download a package from the repo into specified directory:'
	echo "	     ${0##*/} -d package /path/to/download"
	echo '	Download a package from a specific repo:'
	echo "	     ${0##*/} -S 'https://mydomain.com/repo' -d package"
	echo '	Extract package(s) contents in current directory:'
	echo "	     ${0##*/} -e package"
	echo '	Extract package(s) contents to a specified directory:'
	echo "	     ${0##*/} -e package /path/to/extract"
	echo '	Extract all packages in a specific directory to current directory:'
	echo "	     ${0##*/} -e /path/to/files"
	echo '	Extract specific package(s) in a directory to current directory:'
	echo "	     ${0##*/} -S /path/to/files -e package1 package2"
	echo '	Extract specific package(s) in a directory to specified directory:'
	echo "	     ${0##*/} -S /path/to/files -e package1 package2 /path/to/extract"
	echo '	Find files in available packages:'
	echo "	     ${0##*/} -f file1 file2"
	echo '	Find files in packages within a directory:'
	echo "	     ${0##*/} -f file1 file2 /path/to/local/files"
	echo "	     ${0##*/} -S /path/to/local/files -f file1 file2"
	echo '	Install a package:'
# LEFT OFF - we need to use -S as the source path; the DIRECTORY can act as a PREFIX
	echo "	     ${0##*/} -i package [/path/to/local/file]"
	echo '	Install packages from a file listing:'
	echo "	     ${0##*/} -i /path/to/package.list"
	echo '	Install a specific version:'
	echo "	     ${0##*/} -V 1.2.3 -i package [/path/to/local/file]"
	echo '	Make a package for distribution:'
	echo "	     ${0##*/} -m package /path/containing/{package|source}"
	echo "	     ${0##*/} -S /path/containing/{package|source} -m package"
# REMOVED 2025/11/04 - this is duplicated above
#	echo '	Extract package contents:'
#	echo "	     ${0##*/} -e package[.i32.bin.soft] [/path/to/extract]"
	echo '	Proxy a download:'
	echo "	     ${0##*/} -X /mnt/sdb1 -d package"
	echo '	Show dependency tree for package(s):'
	echo "	     ${0##*/} -t package"
	echo '	Show dependency tree for all installed packages:'
	echo "	     ${0##*/} -t"
	echo '	Update a package with optional restore point:'
	echo "	     ${0##*/} [-R] -i package"
	echo '	Unload a package:'
	echo "	     ${0##*/} -u unload package"
	echo '	Uninstall a package, leaving configs:'
	echo "	     ${0##*/} -u delete package"
	echo '	Uninstall a package, including configs too:'
	echo "	     ${0##*/} -u purge package"
	echo
	exit 0
elif [ "$1" = '--version' ] || [ "$3" = '--version' ]; then			# so a user can do 'pax -O xml --version'
# UPDATED 2025/10/25
#	head -10 $(which pax) | grep ^'# updated' | sed "s/.*\\t//;s/ .*//;s:/:.:g"
	if [ $# -gt 1 ]; then							# if we were passed more than just the '--version' option, it has to be '-O', so...
		if [ "$2" != 'none' ] && [ "$2" != 'text' ] && [ "$2" != 'xml' ]; then						# validate the passed '-O' value
			[ "$SILENT" ] || echo "ERROR: you must supply a proper value to the -O option." | tee -a "$LOG_ERRS"	# NOTE: we can't use showMsg() yet because we don't have it's value, so...
			exit 1
		fi
		OUTPUT=$2													# set that value to use from now on
	fi
	TEMP=$(head -10 $0 | grep ^'# updated' | sed "s/.*\\t//;s/ .*//;s:/:.:g")
	showMsg 'success' "$TEMP" 'screen'
	exit 0
else
	# PROCESS PASSED PARAMETERS

	while getopts BcC:dD:eE:fFiI:JK:lLmM:N:O:Qr:RS:tT:u:v:VW:X: OPTION; do			# NOTE: the 'V:' indicates that the '-V' parameter requires a value!
		case ${OPTION} in
			B) BOOTING=TRUE ;;
			c) COPY=TRUE ;;
# UPDATED 2025/11/03
#			C) ( echo ${OPTARG} | grep -q -e ^'i32'$ -e ^'i64'$ -e ^'r32'$ ) || {
			C) ( echo ${OPTARG} | grep -qE ^'(i32|i64|r32|r64)'$ ) || {
# UPDATED 2025/10/25
#				[ "$SILENT" ] || echo "ERROR: you must supply a CPU architecture to the -C option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a CPU architecture to the -C option." 'screen'
				exit 1
			   }
			   CPU="$OPTARG" ;;
			d) DOWNLOAD=TRUE ;;
			D) ( echo ${OPTARG} | grep -q ^'/' ) || {
# UPDATED 2025/10/25
#				[ "$SILENT" ] || echo "ERROR: you must supply an absolute path to the -D option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide an absolute path to the -D option." 'screen'
				exit 1
			   }
			   PREFIX="$OPTARG" ;;
			e) EXTRACT=TRUE ;;
# UPDATED 2025/11/03
#			E) if [ "$OPTARG" != 'all' ] && [ "$OPTARG" != 'info' ] && [ "$OPTARG" != 'list' ]; then
			E) ( echo ${OPTARG} | grep -qE ^'(all|info|list)'$ ) || {
# UPDATED 2025/10/25
#				[ "$SILENT" ] || echo "ERROR: you must supply a valid file to the -E option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a valid file to the -E option." 'screen'
				exit 1
#			   fi
			   }
			   EXTRA="$OPTARG" ;;
			f) FIND=TRUE ;;
			F) FORCE=TRUE ;;
			i) INSTALL=TRUE ;;
			I) ( echo ${OPTARG:0:1} | grep -q ^[0-9a-zA-Z] ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a comma separated list to the -I option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a comma separated list to the -I option." 'screen'
				exit 1
			   }
			   IGNORE="$OPTARG" ;;
			J) ONLY=TRUE ;;
			K) ( echo ${OPTARG:0:1} | grep -q ^[0-9] ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a kernel name to the -K option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a kernel name to the -K option." 'screen'
				exit 1
			   }
			   KERNEL="$OPTARG" ;;
			l) # [Colors]
			   NORMAL="\e[0m"
			   BLINK="\e[5m"
			   INVERSE="\e[7m"
			   HIDE="\e[8m"
			   UL="\e[4m"

			   BLACK="\e[0;30m"
			   GARNET="\e[0;31m"
			   GREEN="\e[0;32m"
			   BROWN="\e[0;33m"
			   NAVY="\e[0;34m"
			   MAGENTA="\e[1;35m"
			   TEAL="\e[0;36m"
			   DARKGREY="\e[1;30m"
			   GREY="\e[0;37m"
			   RED="\e[1;31m"
			   LIME="\e[1;32m"
			   YELLOW="\e[1;33m"
			   BLUE="\e[1;34m"
			   PURPLE="\e[0;35m"
			   CYAN="\e[1;36m"
			   WHITE="\e[1;37m"

			   # if we are looking for specific packages passed on the command line, then...
			   shift $(expr $OPTIND - 1)							# now that the OPTIONS have been processed, lets process the package name(s)
			   eval TEMP=\${$#}								# store the current last passed value to later check if a directory was passed as the last value	http://stackoverflow.com/questions/1853946/getting-the-last-argument-passed-to-a-shell-script
			   if [ "$TEMP" = "$0" ]; then							# if a blank or null value was given for the package name (since the 'shift' command will go back to $0), then...
				TEMP=''									#   no need to check for anything extra
			   else										# otherwise package(s) were passed, so...
				TEMP='^('								#   start a regex grep statement with packages matching the beginning of each name entered
				for RAWFILE in $@; do							#   cycle through each name passed
					TEMP="${TEMP}${RAWFILE}|"					#   adding to the regex statement
				done
				TEMP="${TEMP%|*})"							#   remove the trailing '|' character
			   fi

			   if [ "$OUTPUT" = 'text' ]; then
# UPDATED 2025/10/31
#				printf "${BLUE}%-30s %-4s %-32s %-10s\n" "Name" "Type" "              Hash" "  Version"
#				printf "${WHITE}%30s %4s %32s %10s\n" "------------------------------" "----" "--------------------------------" "----------"
				printf "${BLUE}%-30s %-9s %5s %-32s\n" "Name" " Version" "Types" "              Hash"
				printf "${WHITE}%30s %-9s %5s %32s\n" "------------------------------" "---------" "-----" "--------------------------------"
# REMOVED 2025/10/31
#			   elif [ "$OUTPUT" = 'xml' ]; then
#			   	showMsg 'HEADER' "<s>\n   <xml>\n"
			   fi

# UPDATED 2025/10/22 - no longer using APP* variables
#			   for FILE in $(ls -1 "$DIR_LIST" 2>/dev/null | grep 'soft'$); do		# NOTE: using 'grep' prevents directory from being part of FILE
#				splitName "$FILE"
#
#				printf "${NORMAL}%-30s %-49s\n" "$APPNAME" "$([ -e ${DIR_LIST}/${APPHEAD}.info ] && cat ${DIR_LIST}/${APPHEAD}.info | grep ^'Description:' | sed 's/Description:[ \t]*//')"
#				printf "%-30s ${BLUE}%-4s ${DARKGREY}%-32s ${BLUE}%-11s${NORMAL}\n" ' ' "$APPTYPE" "$([ -e ${DIR_LIST}/${APPHEAD}.hash ] && sed 's/ .*//' ${DIR_LIST}/${APPHEAD}.hash)" "$([ -e ${DIR_LIST}/${APPHEAD}.info ] && cat ${DIR_LIST}/${APPHEAD}.info | grep ^'Version:' | sed 's/Version:[ \t]*//')"
# UPDATED 2025/10/31
#			   for FILE in $(ls -1 "$DIR_LIST" 2>/dev/null | grep ${EXT_SOFT}$); do		# NOTE: using 'grep' prevents directory from being part of FILE
# UPDATED 2025/11/05 - updated to check for specific package(s)
#			   for FILE in $(ls -1 "$DIR_LIST" 2>/dev/null | grep ${EXT_SOFT}$); do		# NOTE: using 'grep' prevents directory from being part of FILE
			   for FILE in $(ls -1 "$DIR_LIST" 2>/dev/null | grep -E "${TEMP}" | grep ${EXT_SOFT}$); do		# NOTE: using 'grep' prevents directory from being part of FILE
				splitName "$FILE"
				case $BASENAME in
					*-dev*|*.dev*) TYPE='dev' ;;
					*-doc*|*.doc*) TYPE='doc' ;;
					*-drv*|*.drv*) TYPE='drv' ;;
					*-gir*|*.gir*) TYPE='gir' ;;
					*-lib*|*.lib*) TYPE='lib' ;;
					*-loc*|*.loc*) TYPE='loc' ;;
					*) TYPE='bin' ;;
				esac
				if [ "$OUTPUT" = 'fifo' ]; then
					echo "$PACKAGE" >"${DIR_TEMP}/output"
					echo "$TYPE" >"${DIR_TEMP}/output"
					echo "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//')" >"${DIR_TEMP}/output"
					echo "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${DIR_LIST}/${BASENAME}.${EXT_HASH})" >"${DIR_TEMP}/output"
					echo "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//')" >"${DIR_TEMP}/output"
				elif [ "$OUTPUT" = 'text' ]; then
# UPDATED 2025/10/31
#					printf "${BLUE}%-30s ${GREY}%-49s\n" "$PACKAGE" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//' | head -c 48)"
#					printf "%-30s ${TEAL}%-4s ${DARKGREY}%-32s ${MAGENTA}%-11s${NORMAL}\n" ' ' "$TYPE" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${DIR_LIST}/${BASENAME}.${EXT_HASH})" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//')"
					printf "${BLUE}%-30s ${GREY}%-49s\n" "$PACKAGE" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//' | head -c 48)"
					printf "${TEAL}%40s ${CYAN}%-5s ${DARKGREY}%-32s${NORMAL}\n" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//')" " $TYPE" "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${DIR_LIST}/${BASENAME}.${EXT_HASH})"
				elif [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ]; then
# UPDATED 2025/10/28
#					showMsg '' '	<package>'
#					showMsg 'file' "$FILE"
# UPDATED 2025/10/30
#					showMsg 'package' "$FILE" 'screen' 0 5
					showMsg 'package' "$FILE" 'screen' 1 4
					showMsg 'type' "$TYPE" 'screen'
					showMsg 'version' "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Version:' | sed 's/Version:[ \t]*//')" 'screen'
					showMsg 'hash' "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_HASH} ] && sed 's/ .*//' ${DIR_LIST}/${BASENAME}.${EXT_HASH})" 'screen'
					showMsg 'description' "$([ -e ${DIR_LIST}/${BASENAME}.${EXT_INFO} ] && cat ${DIR_LIST}/${BASENAME}.${EXT_INFO} | grep ^'Description:' | sed 's/Description:[ \t]*//')" 'screen'
# UPDATED 2025/10/28
#					showMsg '' '	</package>'
# REMOVED 2025/10/30
#					showMsg 'package' "" 'screen' 0 4
				fi
			   done
			   [ "$OUTPUT" = 'text' ] && echo -e "${NORMAL}"
# UPDATED 2025/10/30
#			   [ "$OUTPUT" = 'xml' ] && showMsg '' "   <xml>\n</s>\n"
# UPDATED 2025/10/31
#			   [ "$OUTPUT" = 'xml' ] && showMsg 'package' "   <xml>\n</s>" 1 6
			   ( [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ] ) && showMsg 'success' "" 'screen' 1 6
			   exit 0
			   ;;
			L) NOLIST=TRUE ;;
			m) MAKE=TRUE ;;
			M) if [ "$OPTARG" != 'copy' ] && [ "$OPTARG" != 'link' ]; then
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a proper mode type to the -M option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a proper mode type to the -M option." 'screen'
				exit 1
			   fi
			   MODE="$OPTARG" ;;
			N) FILELIST="$OPTARG" ;;
# UPDATED 2025/11/03
#			O) if [ "$OPTARG" != 'none' ] && [ "$OPTARG" != 'fifo' ] && [ "$OPTARG" != 'text' ] && [ "$OPTARG" != 'xml' ] && [ "$OPTARG" != 'xmLive' ]; then
			O) ( echo ${OPTARG} | grep -qE ^'(none|fifo|text|xml|xmLive)'$ ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a proper value to the -O option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a proper value to the -O option." 'screen'
				exit 1
#			   fi
			   }
			   [ "$OPTARG" = 'none' ] && SILENT=TRUE
			   [ "$OPTARG" = 'fifo' ] && [ ! -e "${DIR_TEMP}/output" ] && {
				showMsg 'failure' "The fifo does not exist, aborting execution." 'screen'
				exit 1
			   }
			   ( [ "$OPTARG" = 'xml' ] || [ "$OPTARG" = 'xmLive' ] ) && {
				echo -e 'Content-Type: text/xml; charset=utf-8'
				echo -e "<?xml version='1.0' encoding='UTF-8'?>\n\n"
			   }
			   [ "$OPTARG" = 'xmLive' ] && echo '<xml>'
			   OUTPUT=$OPTARG ;;
# MERGED 2025/10/22 - this was merged with -U
#			P) PURGE=2 ;;
			Q) QUIET=TRUE ;;
			r) ( echo ${OPTARG:0:1} | grep -q ^[0-9] ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a restore date to the -r action." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a restore date to the -r action." 'screen'
				exit 1
			   }
			   REPO_SOURCE="$REPO_RESTOR"				# set the source location to the restore points directory
			   RESTORE="$OPTARG" ;;
			R) RESTORE=TRUE ;;
# UPDATED 2025/11/03
#			S) if ( echo $OPTARG | grep -q ^'http' ) || ( echo $OPTARG | grep -q ^'ftp' ) || ( echo $OPTARG | grep -q ^'/' ) || ( echo $OPTARG | grep -q ^'./' ); then
			S) ( echo ${OPTARG} | grep -qE ^'(http|ftp|/|./)' ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a directory or http/ftp URI to the -S option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a directory or http/ftp URI to the -S option." 'screen'
				exit 1
#			   fi
			   }
			   REPO_SOURCE="$OPTARG" ;;
# UPDATED 2025/10/26
#			t) echo "Dependency trees for package(s)..."
# UPDATED 2025/10/30
#			t) showMsg 'action' "Dependency trees for package(s)..." 'screen' 0 0 0 1
			t) showMsg 'action' "Dependency trees for package(s)..." 'screen' 1 1
# UPDATED 2025/11/06
#			   TREE=TRUE ;;
			   # if we are looking for specific packages passed on the command line, then...
			   shift $(expr $OPTIND - 1)							# now that the OPTIONS have been processed, lets process the package name(s)
			   eval TEMP=\${$#}								# store the current last passed value to later check if a directory was passed as the last value	http://stackoverflow.com/questions/1853946/getting-the-last-argument-passed-to-a-shell-script

			   cd "${DIR_LIST}" >/dev/null
			   if [ "$TEMP" = "$0" ]; then							# if a blank or null value was given for the package name (since the 'shift' command will go back to $0), then...
				for PARAMETER in $(ls -1 *.${EXT_SOFT}); do				#   cycle each package to see what other packages depend on it
					splitName "$PARAMETER"
					TEMP="$BASENAME"
					showMsg 'package' "${PACKAGE} (${FILETYPE})" 'screen' 1 4
					for FILE in $(grep -lE ^"(${PACKAGE}|${FILENAME})" *.${EXT_DEPS}); do
						splitName "$FILE" "$EXT_DEPS"
						[ "$TEMP" = "$BASENAME" ] && continue
						showMsg 'dependency' "   (${FILETYPE}) ${PACKAGE}" 'screen' 1 4
					done
				done
			   else										# otherwise package(s) were passed, so...
				for PARAMETER in $@; do							#   cycle through each name passed
					[ -d "$PARAMETER" ] && {
						showMsg 'failure' "The DIRECTORY value can not be used with the -t action." 'screen'
						exit 1
					}
					splitName "$PARAMETER"
					showMsg 'package' "${PACKAGE} (${FILETYPE})" 'screen' 1 4
					for FILE in $(grep -lE ^"(${PACKAGE}|${FILENAME})" *.${EXT_DEPS}); do
						splitName "$FILE" "$EXT_DEPS"
						showMsg 'dependency' "   (${FILETYPE}) ${PACKAGE}" 'screen' 1 4
					done
				done
			   fi
			   ( [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ] ) && showMsg 'success' "" 'screen' 1 6
			   exit 0 ;;
# UPDATED 2025/11/03
#			T) if [ "$OPTARG" != 'bin' ] && [ "$OPTARG" != 'dev' ] && [ "$OPTARG" != 'doc' ] && [ "$OPTARG" != 'drv' ] && [ "$OPTARG" != 'gir' ] && [ "$OPTARG" != 'lib' ] && [ "$OPTARG" != 'loc' ]; then
			T) ( echo ${OPTARG} | grep -qE ^'(bin|dev|doc|drv|gir|lib|loc)' ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: the specified value to the -T option is invalid." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a proper value to the -T option." 'screen'
				exit 1
#			   fi
			   }
			   TYPE="$OPTARG" ;;
# UPDATED 2025/10/23 - merged with -U
#			u) UNLOAD=TRUE ;;
# UPDATED 2025/11/03
#			u) if [ "$OPTARG" != 'unload' ] && [ "$OPTARG" != 'delete' ] && [ "$OPTARG" != 'purge' ]; then
			u) ( echo ${OPTARG} | grep -qE ^'(unload|delete|purge)' ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: the specified value to the -u action is invalid." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a proper value to the -u action." 'screen'
				exit 1
#			   fi
			   }
			   UNLOAD=TRUE
			   [ "$OPTARG" != 'unload' ] && PURGE="$OPTARG" ;;		# specify the purge type if we're not just unloading the software
# UPDATED 2025/10/23 - merged with -u
#			U) if [ "$OPTARG" != 'app' ] && [ "$OPTARG" != 'all' ]; then
#				[ "$SILENT" ] || echo "ERROR: the specified value to the -U switch is invalid." | tee -a "$LOG_ERRS"
#				exit 1
#			   fi
#			   PURGE="$OPTARG" ;;
# UPDATED 2025/10/22
#			   PURGE=1 ;;
			v) if [ "$OPTARG" != 'data' ] && [ "$OPTARG" != 'deps' ]; then
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a proper mode type to the -v action." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a proper mode to the -v action." 'screen'
				exit 1
			   fi
			   VALIDATE="$OPTARG" ;;
			V) ( echo ${OPTARG:0:1} | grep -q ^[0-9] ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a version number to the -V option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a version number to the -V option." 'screen'
				exit 1
			   }
			   VERSION="$OPTARG" ;;
			W) ALL=TRUE ;;
			X) ( echo ${OPTARG} | grep -q ^'/' ) || {
# UPDATED 2025/10/26
#				[ "$SILENT" ] || echo "ERROR: you must supply a device mount point to the -X option." | tee -a "$LOG_ERRS"
				showMsg 'failure' "You must provide a device mount point to the -X option." 'screen'
				exit 1
			   }
			   proxyAction
			   PROXY="$OPTARG" ;;
			*) exit 1 ;;								# NOTE: since 'getopts' presents it own error, we don't need to do so here
		esac
	done

	EXE_CMD="${0##*/} $@"									# store the executed command for logging below

	# PROCESS THE 'DIRECTORY' PARAMETER
# REMOVED 2025/11/03 - this is no longer needed as we expanded FIND to use the DIRECTORY parameter
#if [ "$FIND" ]; then										# if we are trying to find a file in a package, then...
#	shift $(expr $OPTIND - 2)								#   remove the script name ($0) and the action (-f) and store all the filenames passed
#	eval TEMP=\${$#}
#
#elif [ ! "$FIND" ]; then									# we're not finding a file (since none of these checks are relevent for that action), then...
	shift $(expr $OPTIND - 1)								# now that the ACTIONS and OPTIONS have been processed, lets process the package name(s)
	eval TEMP=\${$#}									# store the current last passed value to later check if a directory was passed as the last value	http://stackoverflow.com/questions/1853946/getting-the-last-argument-passed-to-a-shell-script

	# WARNING: this MUST come before the directory processing!!!
	if [ "$TEMP" = "$0" ]; then								# if a blank or null value was given for the package name (since the 'shift' command will go back to $0), then...
# UPDATED 2025/10/26
#		echo "ERROR: you must provide a file or package name before processing can begin." | tee -a "$LOG_ERRS";
		showMsg 'failure' "You must provide a file or package name before processing can begin." 'screen'
		exit 1
	elif [ -f "$1" ] && [ ! "$(echo $1 | grep -e ${EXT_SOFT}$)" ]; then			# check if the PACKAGE(S) value was actually passed as a text file -AND- is NOT a package name (ending with the EXT_SOFT extension)	NOTE: can't check for mime type since busybox doesn't have a 'file' applet
		[ "$1" = "$TEMP" ] && TEMP=''							#   if the PACKAGE(S) value is the last passed value (and not a DIRECTORY), then erase the TEMP value to avoid directory processing below
		TEMPLIST="$(cat "$1" | tr '\n' ' ')"						#   store all the packages to load within the text file list
		[ "$TEMPLIST" = '' ] && exit 0							#   if there are NOT any packages listed in the text file, there's nothing to process so exit
		set -- $TEMPLIST								#   otherwise reset the $1, $2, $3, etc values (and $@ that is used in the main 'for' loop below) to be the package names in the text file (as if they were passed via the command line)
		unset TEMPLIST									#   erase this variable since it's no longer used
	fi

# REMOVED 2025/11/03 - this is handled below now
#	if [ "$MAKE" ] && ( ( echo "$1" | grep -q ^'/' ) || ( echo "$1" | grep -q ^'./' ) ); then
## UPDATED 2025/10/26
##		[ "$SILENT" ] || echo "ERROR: you must supply a package name with the -m action." | tee -a "$LOG_ERRS"
#		showMsg 'failure' "You must provide a package name with the -m action."
#		exit 1
#	fi

	if [ ! -d "$TEMP" ] && ( echo "$TEMP" | grep -q '/' ); then				# if a DIRECTORY was actually passed (via the presence of '/' characters), but doesn't exist then...
#echo oops
# UPDATED 2025/10/26
#		[ "$SILENT" ] || echo "ERROR: the passed file or directory does not exist (${TEMP})." | tee -a "$LOG_ERRS"	#   NOTE: this is shown to the screen and logged on purpose!
		showMsg 'failure' "The passed directory does not exist (${TEMP})." 'screen'
		exit 1
	elif [ -d "$TEMP" ] && ( echo "$TEMP" | grep -q '/' ); then				# otherwise it does exist, so...
#echo "@ |$@|"
#echo "1 TEMP |$1|$TEMP|"
		if [ "$1" = "$TEMP" ]; then							# if the DIRECTORY is the PACKAGE(S) value, then a directory needs to be processed as the 'list'...
#echo top
			TEMPLIST="$(ls -1 "${1}/"*.${EXT_SOFT} 2>/dev/null | tr '\n' ' ')"	#   store all the .soft packages to load within the directory
			[ "$TEMPLIST" = '' ] && exit 0						#   if there are NOT any packages in the directory, there's nothing to process so exit
			set -- "$TEMPLIST"							#   otherwise reset the $1, $2, $3, etc values (and $@ that is used in the main 'for' loop below) to be the package names in the directory (as if they were passed via the command line)
# REMOVED 2025/11/03 - no need to perform these checks and fixed a value storage bug
#			if [ "$TEMP" != "$REPO_OPTION" ] && [ "$TEMP" != "$REPO_SYSTEM" ]; then	#   if neither of the two defaults repo locations were passed (e.g. not booting) as the location, then...
				REPO_SOURCE="$TEMP"						#   automatically update this value since it is the source location where the desired files are stored
#				[ "$(echo $REPO_SOURCE|tail -c 2)" = '/' ] && TEMP="$(echo $REPO_SOURCE|head -c -2)"		# if the user included a trailing '/' on the passed directory, then remove it to prevent parsing below
#			fi
			( echo "$REPO_SOURCE"|grep -q '/'$ ) && REPO_SOURCE="$(echo "$REPO_SOURCE"|head -c -2)"		# if the user included a trailing '/' on the passed directory, then remove it to prevent parsing below
# REMOVED 2025/10/23 - unsure what this is being used for; it causes problems with -m
# RESTORED 2025/11/03 - we are now using DIRECTORY
		else										# otherwise a passed value for DIRECTORY was given (along with PACKAGE(S)), so...
#echo btm
			TEMPLIST=''
			for PARAM in ${@}; do							#   process each remaining parameter
				[ "$PARAM" = "$TEMP" ] && break					#   if we have reached the last parameter, break out of the 'for' loop
				TEMPLIST="$TEMPLIST $PARAM"					#   append each parameter to the list
			done
			unset PARAM
			set -- "$TEMPLIST"							#   now reset the $@ array to exclude the last directory

# UPDATED 2025/11/03 - we are now using DIRECTORY
#			REPO_TARGET="$TEMP"							#   update the target value since that is where the user wants the packages stored
#			[ "$(echo $REPO_TARGET|tail -c 2)" = '/' ] && TEMP="$(echo $REPO_TARGET|head -c -2)"
			DIRECTORY="$TEMP"						#   automatically update this value since it is the source location where the desired files are stored
			[ "$(echo $DIRECTORY|tail -c 2)" = '/' ] && DIRECTORY="$(echo $DIRECTORY|head -c -2)"		# if the user included a trailing '/' on the passed directory, then remove it to prevent parsing below
		fi
		unset TEMPLIST

# REMOVED 2025/10/23 - this appears to NOT be used (probably was for previous -m implementation since it stores the last part of the passed directory)		 do we need to store the value in TEMP, since it gets immediately erased afterwards?
#		TEMP="${TEMP##*/}"								# remove everything but the last directory to rename
	fi
#fi

	TEMP=''												# make sure this value is not contaminating anything
fi




# MANDATORY CHECKS BEFORE **ANY** PROCESSING

# check the variable values	NOTE: we can't write to a log yet since those checks haven't occurred
# UPDATED 2025/10/22 - the -f action does NOT supply a package name
#[ ! "$1" ] && { [ "$SILENT" ] || echo "ERROR: you must provide a PACKAGE name." | tee -a "$LOG_ERRS"; exit 1; }
# UPDATED 2025/10/26
#[ ! "$1" ] && [ ! "$FIND" ] && { [ "$SILENT" ] || echo "ERROR: you must provide a PACKAGE name." | tee -a "$LOG_ERRS"; exit 1; }
#[ ! "$2" ] && [ "$MAKE" ] && { [ "$SILENT" ] || echo "ERROR: you must provide a directory to package." | tee -a "$LOG_ERRS"; exit 1; }
#[ ! "$COPY" ] && [ ! "$DOWNLOAD" ] && [ ! "$EXTRACT" ] && [ ! "$FIND" ] && [ ! "$INSTALL" ] && [ ! "$MAKE" ] && [ ! "$RESTORE" ] && [ ! "$TREE" ] && [ ! "$UNLOAD" ] && [ ! "$VALIDATE" ] && { [ "$SILENT" ] || echo "ERROR: you must provide an ACTION." | tee -a "$LOG_ERRS"; exit 1; }
#[ ! -d "$REPO_PREFIX" ] && [ "$MAKE" ] && { [ "$SILENT" ] || echo "ERROR: the directory storing the package contents does NOT exist." | tee -a "$LOG_ERRS"; exit 1; }
#[ ! -d "$REPO_PREFIX" ] && [ ! "$MAKE" ] && { [ "$SILENT" ] || echo "ERROR: the package storage root directory does NOT exist." | tee -a "$LOG_ERRS"; exit 1; }
#[ ! -d "$REPO_OPTION" ] && [ ! "$MAKE" ] && ( mkdir -p "$REPO_OPTION" || { [ "$SILENT" ] || echo "ERROR: the package storage directory could NOT be created." | tee -a "$LOG_ERRS"; exit 1; } )
#[ "$MAKE" ] && [ "$(echo $REPO_PREFIX | head -c 1)" != '/' ] && { [ "$SILENT" ] || echo "ERROR: you must include the full path (not relative) when creating a package." | tee -a "$LOG_ERRS"; exit 1; }
#[ "$RESTORE" ] && [ ! -e "${REPO_RESTOR}/${RESTORE}" ] && { [ "$SILENT" ] || echo "ERROR: the passed path is not a valid restore point." | tee -a "$LOG_ERRS"; exit 1; }
[ ! "$COPY" ] && [ ! "$DOWNLOAD" ] && [ ! "$EXTRACT" ] && [ ! "$FIND" ] && [ ! "$INSTALL" ] && [ ! "$MAKE" ] && [ ! "$RESTORE" ] && [ ! "$TREE" ] && [ ! "$UNLOAD" ] && [ ! "$VALIDATE" ] && { showMsg 'failure' "You must provide an ACTION when executing this script." 'screen'; exit 1; }
# REMOVED 2025/11/03 - this never gets triggered as the mandatory checks above catches this
#[ ! "$FIND" ] && [ ! "$1" ] && { showMsg 'failure' "You must provide a package name before processing can begin."; exit 1; }
[ "$MAKE" ] && ( echo "$1" | grep -q '/' ) && { showMsg 'failure' "You must provide a package name before processing can begin." 'screen'; exit 1; }
# UPDATED 2025/11/03 - the above segment has been reworked and this needed to be adjusted
#[ "$MAKE" ] && [ ! "$2" ] && { showMsg 'failure' "You must provide a directory to package before processing can begin."; exit 1; }
# MOVED 2025/11/06 - moved below
# MOVED 2025/11/12 - this has to be moved below were the directory values are set
#[ "$MAKE" ] && [ "$DIRECTORY" = "$REPO_OPTION" ] && [ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && { showMsg 'failure' "You must provide a directory to package before processing can begin." 'screen'; exit 1; }
# REMOVED 2025/11/03 - this is no longer needed
#[ "$MAKE" ] && [ "$(echo "$REPO_PREFIX" | head -c 1)" != '/' ] && { showMsg 'failure' "The full, not relative, path must be included when creating a package."; exit 1; }
# MOVED 2025/11/06 - moved below
# MOVED 2025/11/12 - this has to be moved below were the directory values are set
#[ "$PROXY" ] && [ "$DIRECTORY" != "$REPO_OPTION" ] && { showMsg 'failure' "The DIRECTORY value is not used with this action." 'screen'; exit 1; }
# MOVED 2025/11/12 - this has to be moved below were the directory values are set
#[ "$RESTORE" ] && [ ! -e "${REPO_RESTOR}/${RESTORE}" ] && { showMsg 'failure' "The provided path does not contain any valid restore points." 'screen'; exit 1; }

# check the directories		NOTE: we can't write to a log yet since those checks are occurring
if [ ! -d "${DIR_LIST}" ]; then
# UPDATED 2025/10/27
#	mkdir -p "${DIR_LIST}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The init script directory (DIR_LIST) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
	mkdir -p "${DIR_LIST}" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The catalog directory (DIR_LIST) does not exist and could not be created." 'screen'; exit 1; }
fi
# UPDATED 2025/10/27
#touch "${DIR_LIST}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The init script directory (DIR_LIST) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
touch "${DIR_LIST}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The catalog directory (DIR_LIST) is not writable." 'screen'; exit 1; }
rm "${DIR_LIST}/writable" >>"$LOG_ERRS" 2>&1

if [ "$INSTALL" ] && [ "$PREFIX" = '' ] && [ "$DIRECTORY" = '' ]; then
	if [ ! -d "${DIR_INIT}" ]; then
# UPDATED 2025/10/27
#		mkdir -p "${DIR_INIT}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The init script directory (DIR_INIT) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
		mkdir -p "${DIR_INIT}" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The init script directory (DIR_INIT) does not exist and could not be created." 'screen'; exit 1; }
	fi
# UPDATED 2025/10/27
#	touch "${DIR_INIT}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The init script directory (DIR_INIT) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
	touch "${DIR_INIT}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The init script directory (DIR_INIT) is not writable." 'screen'; exit 1; }
	rm "${DIR_INIT}/writable" >>"$LOG_ERRS" 2>&1
fi

if [ ! -d "${DIR_INST}" ]; then
# UPDATED 2025/10/27
#	mkdir -p "${DIR_INST}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The installed cache directory (DIR_INST) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
	mkdir -p "${DIR_INST}" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The installed cache directory (DIR_INST) does not exist and could not be created." 'screen'; exit 1; }
fi
# UPDATED 2025/10/27
#touch "${DIR_INST}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The installed cache directory (DIR_INST) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
touch "${DIR_INST}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The installed cache directory (DIR_INST) is not writable." 'screen'; exit 1; }
rm "${DIR_INST}/writable" >>"$LOG_ERRS" 2>&1

if [ ! -d "${DIR_LOGS}" ]; then
# UPDATED 2025/10/27
#	mkdir -p "${DIR_LOGS}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The logs directory (DIR_LOGS) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
	mkdir -p "${DIR_LOGS}" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The logs directory (DIR_LOGS) does not exist and could not be created." 'screen'; exit 1; }
fi
# UPDATED 2025/10/27
#touch "${DIR_LOGS}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The logs directory (DIR_LOGS) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
touch "${DIR_LOGS}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The logs directory (DIR_LOGS) is not writable." 'screen'; exit 1; }
rm "${DIR_LOGS}/writable" >>"$LOG_ERRS" 2>&1

if [ ! -d "${DIR_LOOP}" ]; then
# UPDATED 2025/10/27
#	mkdir -p "${DIR_LOOP}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The mounting directory (DIR_LOOP) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
	mkdir -p "${DIR_LOOP}" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The mounting directory (DIR_LOOP) does not exist and could not be created." 'screen'; exit 1; }
fi
# UPDATED 2025/10/27
#touch "${DIR_LOOP}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The mounting directory (DIR_LOOP) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
touch "${DIR_LOOP}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The mounting directory (DIR_LOOP) is not writable." 'screen'; exit 1; }
rm "${DIR_LOOP}/writable" >>"$LOG_ERRS" 2>&1

if [ ! -d "${DIR_TEMP}" ]; then
# UPDATED 2025/10/27
#	mkdir -p "${DIR_TEMP}" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The temp directory (DIR_TEMP) does not exist and could not be created." | tee -a "$LOG_ERRS"; exit 1; }
	mkdir -p "${DIR_TEMP}" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The temp directory (DIR_TEMP) does not exist and could not be created." 'screen'; exit 1; }
fi
# UPDATED 2025/10/27
#touch "${DIR_TEMP}/writable" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The temp directory (DIR_TEMP) is not writable." | tee -a "$LOG_ERRS"; exit 1; }
touch "${DIR_TEMP}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The temp directory (DIR_TEMP) is not writable." 'screen'; exit 1; }
rm "${DIR_TEMP}/writable" >>"$LOG_ERRS" 2>&1

if [ ! -d "$REPO_PREFIX" ]; then
	mkdir -p "$REPO_PREFIX" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The package storage directory (REPO_PREFIX) could not be created." 'screen'; exit 1; }
fi
touch "${REPO_PREFIX}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The package storage directory (REPO_PREFIX) is not writable." 'screen'; exit 1; }
rm "${REPO_PREFIX}/writable" >>"$LOG_ERRS" 2>&1

if ( [ "$DOWNLOAD" ] || [ "$INSTALL" ] ) && [ ! -d "$REPO_OPTION" ]; then
	mkdir -p "$REPO_OPTION" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The optional package storage directory (REPO_OPTION) could not be created." 'screen'; exit 1; }
fi
touch "${REPO_OPTION}/writable" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The optional package storage directory (REPO_OPTION) is not writable." 'screen'; exit 1; }
rm "${REPO_OPTION}/writable" >>"$LOG_ERRS" 2>&1

# LEFT OFF - check the permissions on REPO_SYSTEM are root:root @ 770 (or root:advanced), but only if REPO_SYSTEM and REPO_OPTION are different locations (so that TC can work without root permissions)




showMsg 'start' "\n\n---------- [ Script Execution ] ----------" 'log'
showMsg 'start' "           $(date +'%Y-%m-%d  %H:%M:%S')\n" 'log'
showMsg 'start' "$EXE_CMD" 'log'




# SET DIRECTORY VALUES

[ "$DIRECTORY" = '' ] && DIRECTORY="$REPO_OPTION"						# set default values if none were specified in the passed parameters
[ "$REPO_SOURCE" = '' ] && REPO_SOURCE="$REPO_SCHEMA"

if [ "$COPY" ]; then										# if we are copying package(s), then...
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since we can only copy from local packages
	cd "$DIRECTORY" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'				#   now cd into the DIRECTORY where the packages are to be copied
elif [ "$DOWNLOAD" ]; then									# if we are downloading package(s), then...
#	REPO_SOURCE="${REPO_SCHEMA}"								#   eval REPO_SOURCE incase it has any variables in it
	cd "$DIRECTORY" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'				#   now cd into the DIRECTORY where the packages will be downloaded
elif [ "$EXTRACT" ]; then									# if we are extracting package(s) contents, then...
	[ "$DIRECTORY" = "$REPO_OPTION" ] && DIRECTORY='./'					#   if no directory was passed, then set the current directory as the target location to extract
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE='.'					#   if the REPO_SOURCE is still remote, then change it to the current directory (this allows for directories to be processed as package list)
	cd "$DIRECTORY" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'				#   now cd into the DIRECTORY where the packages are
elif [ "$FIND" ]; then										# if we are finding file(s) in packages, then...
	[ "$DIRECTORY" != "$REPO_OPTION" ] && REPO_SOURCE="$DIRECTORY"				#   if a directory was passed, then set the REPO_SOURCE as that value (so it can be used with '-S' interchangably)
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since we can only search local packages
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the REPO_SOURCE where the packages are
elif [ "$INSTALL" ]; then									# if we are installing package(s), then...
	if [ "$BOOTING" ]; then									#   if we're booting the device, then...
		DIRECTORY='/'									#     set DIRECTORY to the filesystem root
		REPO_SOURCE="$REPO_SYSTEM"							#     set REPO_SOURCE to the 'FIRMWARE' packages location
	else											#   otherwise the system is live and can use parameters, so...
		[ "$PREFIX" ] && DIRECTORY="${PREFIX}"						#     if the -D option was passed, add it to the directory structure
		[ ! "$PREFIX" ] && [ "$DIRECTORY" = "$REPO_OPTION" ] && DIRECTORY="$DIR_LIVE"	#     if the -D option was NOT passed, and the DIRECTORY was NOT passed, then set to the default installation location
	fi
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the REPO_SOURCE where the packages are
#elif [ "$LIST" ]; then										# if we are listing installed packages, then...
	# this is handled in the script parameter processing section above
elif [ "$MAKE" ]; then										# if we are creating a package for distribution, then...
	[ "$DIRECTORY" != "$REPO_OPTION" ] && REPO_SOURCE="$DIRECTORY"				#   if a directory was passed, then set the REPO_SOURCE as that value (so it can be used with '-S' interchangably)
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since we can only search local packages
	[ "$DIRECTORY" = "$REPO_OPTION" ] && {
		showMsg 'failure' "You must provide a directory to package before processing can begin." 'screen'
		exitGracefully 1 'screen'
	}
	cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 2 'screen'			#   now cd into the REPO_SOURCE where the source code or compiled software is
elif [ "$PROXY" ]; then										# if we are proxying an action, then...
	# this action can not use DIRECTORY or REPO_SOURCE
	[ "$DIRECTORY" != "$REPO_OPTION" ] && {
		showMsg 'failure' "The DIRECTORY value can not be used with this action." 'screen'
		exitGracefully 1 'screen'
	}
	[ "$REPO_SOURCE" != "$REPO_SCHEMA" ] && {
		showMsg 'failure' "The -S option can not be used with this action." 'screen'
		exitGracefully 1 'screen'
	}
#elif [ "$RESTORE" ]; then									# if we are restoring a package from a restore point, then...
#	adjust the below once the directory values get set
#	[ ! -e "${REPO_RESTOR}/${RESTORE}" ] && { showMsg 'failure' "The provided path does not contain any valid restore points." 'screen'; exit 1; }
#		[ "$RESTORE" ] && cd "${REPO_RESTOR}/${RESTORE}"				# change into the restore points directory to get all the requested software and any of its dependencies
elif [ "$UNLOAD" ]; then									# if we are unloading/uninstalling package(s), then...
	echo 'fill me out'
elif [ "$VALIDATE" ]; then									# if we are validating package(s) information, then...
	[ "$REPO_SOURCE" = "$REPO_SCHEMA" ] && REPO_SOURCE="$REPO_OPTION"			#   if the REPO_SOURCE is still remote, then change it to the REPO_OPTION directory since we can only validate local packages
	eval REPO_SOURCE="${REPO_SOURCE}"							#   eval REPO_SOURCE incase it has any variables in it
fi




# PERFORM SOME ACTUAL WORK

# MOVED and UPDATED 2025/11/07
#if [ $DEBUG -eq 0 ]; then
#	echo -e "\n\n---------- [ Script Execution ] ----------" >>"$LOG_ERRS"
#	echo -e "           $(date +'%Y-%m-%d  %H:%M:%S')\n" >>"$LOG_ERRS"
#else
#	echo -e "\n\n---------- [ Script Execution ] ----------" | tee -a "$LOG_DBUG" >>"$LOG_ERRS"
#	echo -e "           $(date +'%Y-%m-%d  %H:%M:%S')\n" | tee -a "$LOG_DBUG" >>"$LOG_ERRS"
#fi

[ "$COPY" ] && showMsg 'action' "Processing dependencies for the packages..." 'both' 1 4
[ "$DOWNLOAD" ] && showMsg 'action' "Processing dependencies for the packages..." 'both' 1 4
#[ "$EXTRACT" ]
#[ "$FIND" ]
[ "$INSTALL" ] && showMsg 'action' "Processing dependencies for the packages..." 'both' 1 4
#[ "$LIST" ]
#[ "$MAKE" ]
[ "$PROXY" ] && showMsg 'action' "Generating package list..." 'both' 1 4
if [ "$UNLOAD" ]; then										# if we are unloading/uninstalling package(s), then...
# REMOVED 2025/11/04 - this serves no functional purpose
#	TEMP=$OPTIND										#   store the current OPTIND value to restore it in just a second
# UPDATED 2025/11/04 - replaced APP*
#	for APPFILE in $@; do touch ${DIR_LIST}/${APPFILE}.mark; done				#   mark all the files we want to unload
# LEFT OFF - move this into the 'for' loop below and touch each file as it gets iterated to; there's no reason to place it here
	for FILE in $@; do touch ${DIR_LIST}/${FILE%.*}.${EXT_MARK}; done			#   mark all the files we want to unload
# REMOVED 2025/11/04 - this serves no functional purpose
#	OPTIND=$TEMP										#   restore the original value of OPTIND
fi
[ "$VALIDATE" = 'deps' ] && showMsg 'action' "Processing dependencies for the packages..." 'both' 1 4


# PROCESS PASSED PACKAGES

for RAWFILE in $@; do
# REMOVED 2025/11/04 - this is no longer necessary since the implementation of DIRECTORY
#	( [ "$RAWFILE" = "$REPO_OPTION" ] || [ "$RAWFILE" = "${REPO_OPTION}/" ] ) && continue	# if we've made it to a passed directory (with and without trailing '/'), then skip processing it

# TEMP 2025/11/05 - testing to see if we can have all the dependencies detected at once
	#INDEX=0											# reset these values each iteration
	#TOTAL=0
#echo 01
	splitName "$RAWFILE"									# NOTE: the RAWFILE value will be overwritten by the splitName() call
#continue
#	PACKAGE=$RAWFILE
#	eval FILENAME=${BASENAME}
#echo "|${RAWFILE}|${BASENAME}|"

# UPDATED 2025/10/22 - no longer using APP* variables
#	[ $DEBUG -gt 0 ] && echo -e "body:\n\tAPPFILE :${APPFILE}:\n\tAPPHEAD :${APPHEAD}:\n\tAPPNAME :${APPNAME}:\n\tAPPARCH :${APPARCH}:\n\tAPPTYPE :${APPTYPE}:\n\tAPPEXTN :${APPEXTN}:\n\tVERSION :${VERSION}:\n\tVERFILE :${VERFILE}:" >>"$LOG_DBUG"
	[ $DEBUG -gt 0 ] && echo -e "body (dependencies):\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tTYPE        |${FILETYPE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tCPU TYPE    |${CPU}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |${VERFILE}|" >>"$LOG_DBUG"
#echo 02
# UPDATED 2025/11/06 - this only needs to reference REPO_SOURCE
#	if [ ! "$DOWNLOAD" ] && [ ! "$FIND" ] && [ ! "$MAKE" ] && [ ! "$PROXY" ] && [ ! -e "${REPO_SYSTEM}/${FILENAME}" ] && [ ! -e "${REPO_OPTION}/${FILENAME}" ] && [ ! -e "${REPO_SOURCE}/${FILENAME}" ] && [ ! -e "./${FILENAME}" ]; then
	if [ ! "$DOWNLOAD" ] && [ ! "$FIND" ] && [ ! "$MAKE" ] && [ ! "$PROXY" ] && [ ! -e "${REPO_SOURCE}/${FILENAME}" ]; then
# UPDATED 2025/10/30
#		showMsg 'msg|failure' "The '${FILENAME}' file does not exist."
		showMsg 'failure' "The '${FILENAME}' package does not exist."
#echo 02b
		exitGracefully 1
	fi
#echo 03
# showMsg TAG MESSAGE [TARGET] [CR] [TAGS] [TRIM]

	#if [ "$COPY" ]; then									# if we are copying package(s), then...
		# this executes the processDependencies() call below
	#elif [ "$DOWNLOAD" ]; then								# if we are downloading package(s), then...
		# this executes the processDependencies() call below
	if [ "$EXTRACT" ]; then									# if we are extracting package(s) contents, then...
		# NOTE: we can NOT make unsquashfs use the 'pax -F' option since it will just error
		#	with success even though it doesn't process anything if files or directory
		#	structures exist. As a result always force unsquashfs to operate to ensure
		#	the process works.

# UPDATED 2025/10/27
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "Extracting the '${PACKAGE}' package:"
# UPDATED 2025/10/30
#		showMsg 'package' "Extracting the '${PACKAGE}' package:" 'screen' 1 0 0 1
		showMsg 'package' "Extracting the '${PACKAGE}' package:" 'both' 0 3
# UPDATED 2025/11/03 - implementing DIRECTORY
#		[ ! "$REPO_TARGET" ] && REPO_TARGET='./'					# if no directory was passed, then set the current directory as the target
#		[ $DEBUG -gt 0 ] && echo -e "unsquashfs -f -d \"$REPO_TARGET\" ${FILENAME}" >>"$LOG_DBUG"
#		unsquashfs -f -d "$REPO_TARGET" ${FILENAME} 1>/dev/null 2>>"$LOG_ERRS" || exitGracefully 2
		[ $DEBUG -gt 0 ] && echo -e "unsquashfs -f -d \"$DIRECTORY\" \"${REPO_SOURCE}/${FILENAME}\"" >>"$LOG_DBUG"
# UPDATED 2025/11/05 - the directory is changed into above now
#		unsquashfs -f -d "$DIRECTORY" "${REPO_SOURCE}/${FILENAME}" 1>/dev/null 2>>"$LOG_ERRS" || exitGracefully 2
		unsquashfs -f -d './' "${REPO_SOURCE}/${FILENAME}" 1>/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'package'
# UPDATED 2025/10/27
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo " [done]"
# UPDATED 2025/10/30
#		showMsg 'package' " [done]" 'screen' 2
		showMsg 'package' " [done]" 'both' 1 5 
		continue
	elif [ "$FIND" ]; then									# if we are finding file(s) in packages, then...
# UPDATED 2025/10/29
#		showMsg 'action' "Searching for '${PACKAGE}' in packages..." 'screen' 0 0 0 1
# UPDATED 2025/10/30
#		showMsg 'action' "Searching for '${PACKAGE}' in packages..." 'screen' 0 5
		showMsg 'action' "Searching for '${PACKAGE}' in packages..." 'both' 1 4	# NOTE: we store to the log so if any error occurs, we know what it relates to (the rest of this section can just show to the screen)
# DBUG
#REPO_SOURCE='/tmp'
#		cd "${REPO_SYSTEM}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1		#   change into the first repo location to check for the files
		for FILE in $(ls -1 "$REPO_SOURCE"/*.${EXT_SOFT}); do
#echo "file |$FILE|"
			[ $(stat -c %s $FILE) -eq 0 ] && continue				#   skip all 0 byte files (since they can just be placeholders); this really shouldn't come into play in this location, but better safe than sorry
			unsquashfs -ll $FILE | tail -n +5 | grep -v ^d | sed 's:.*/::' | grep -q "$PACKAGE" && {
# UPDATED 2025/10/27
#				echo $FILE
#				unsquashfs -ll $FILE | tail -n +5 | grep -v ^d | sed 's/.*squashfs-root/   /' | grep "$PACKAGE"
# UPDATED 2025/10/30
#				showMsg 'package' "$FILE" 'screen' 0 5
#				showMsg 'matches' "$(unsquashfs -ll "$FILE" | tail -n +5 | grep -v ^d | sed 's/.*squashfs-root/   /' | grep "$PACKAGE")" 'screen' 0 3 1
				showMsg 'package' "   $FILE" 'screen' 1 4 1
				showMsg 'matches' "$(unsquashfs -ll "$FILE" | tail -n +5 | grep -v ^d | sed 's/.*squashfs-root/      /' | grep "$PACKAGE")" 'screen' 1 2 1
# REMOVED 2025/10/30
#				showMsg 'package' "" 'screen' 0 4
			}
		done

# REMOVED 2025/11/05 - this is controlled completely by the user via the -S
#		if [ "$REPO_OPTION" != "$REPO_SYSTEM" ]; then					#   if there are separate repo's for packages (e.g. XiniX and not TC), then...
#			cd "${REPO_OPTION}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1	#	change into the optional repo location to further check for the files
#			for FILE in $(ls -1 *.${EXT_SOFT}); do
#				[ $(stat -c %s $FILE) -eq 0 ] && continue			#	skip all 0 byte files (since they can just be placeholders)
#				unsquashfs -ll $FILE | tail -n +5 | grep -v ^d | sed 's:.*/::' | grep -q "$PACKAGE" && {
## UPDATED 2025/10/28
##					echo $FILE
##					unsquashfs -ll $FILE | tail -n +5 | grep -v ^d | sed 's/.*squashfs-root/   /' | grep "$PACKAGE"
#					showMsg 'package' "" 'screen' 0 4
#					showMsg 'package' "$FILE" 'screen' 0 5
#					showMsg 'matches' "$(unsquashfs -ll "$FILE" | tail -n +5 | grep -v ^d | sed 's/.*squashfs-root/   /' | grep "$PACKAGE")" 'screen' 0 3 1
#				}
#			done
#		fi

#		showMsg 'package|success' "" 'screen' 0 4
# REMOVED 2025/10/30
#		showMsg 'action' "" 'screen' 0 4
		continue
	elif [ "$INSTALL" ]; then									# if we are installing package(s), then...
		# add the package to the list of dependencies						  NOTE: this lists EVERY dependency for every dependency in one list; not just the dependencies for the requested package!
		echo "$FILENAME" >>"${DIR_TEMP}/installed.${EXEID}"					# add the package to the cache file for future unloading/uninstalling information
	#elif [ "$LIST" ]; then										# if we are listing installed packages, then...
			# this is handled in the script parameter processing section
	elif [ "$MAKE" ]; then									# if we are creating a package for distribution, then...
# MOVED 2025/11/03 - this was moved above where all the other actions set these values
#		DIRECTORY="$2"
		TEMP=1
# UPDATED 2025/10/22 - no longer using APP* variables
#		if [ -e "${APPNAME}.all.src.make" ] && [ -x "${APPNAME}.all.src.make" ]; then	# if a compile script exists, then lets run that first!
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Making the '${APPNAME}' package..."
#			./${APPNAME}.all.src.make >${APPNAME}.all.src.make.log 2>&1 || {
# UPDATED 2025/11/05 - this now needs to be REPO_SOURCE so the -S can be used too
#		if [ -e "${DIRECTORY}/${BASENAME}.${EXT_MAKE}" ] && [ -x "${DIRECTORY}/${BASENAME}.${EXT_MAKE}" ]; then		# if a compile script exists (and is executable), then lets run that first!
		if [ -e "./${BASENAME}.${EXT_MAKE}" ] && [ -x "./${BASENAME}.${EXT_MAKE}" ]; then	# if a compile script exists (and is executable), then lets run that first!
# UPDATED 2025/10/28
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Making the '${PACKAGE}' package..."
# UPDATED 2025/10/30
#			showMsg 'action' "Compiling the '${PACKAGE}' package:" 'screen' 1 0 0 1
#			cd "${DIRECTORY}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'action' 'screen' 2			# change into the passed directory (e.g. /tmp/staging[/PACKAGE.make|src/] > /tmp) so the generated files get placed correctly
			showMsg 'action' "Compiling the '${PACKAGE}' package:" 'both' 0 3
# REMOVED 2025/11/05 - this is now handled above
#			cd "${DIRECTORY}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'action'			# change into the passed directory (e.g. /tmp/staging[/PACKAGE.make|src/] > /tmp) so the generated files get placed correctly
			./${BASENAME}.${EXT_MAKE} >${BASENAME}.${EXT_MAKE}.log 2>&1 || {
# UPDATED 2025/10/28
#				[ "$SILENT" ] || echo "ERROR: a compile error occurred - see the log for details."
#				showMsg 'failure' "An error occurred while compiling."
# UPDATED 2025/10/30
#				exitGracefully 1 'action' 'screen' 2
				exitGracefully 4 'both' 5 'action'
			}
			showMsg 'action' " [done]" 'both' 1 5
# REMOVED 2025/10/30 - this is handled elsewhere now
#			TEMP=0									# indicate we do NOT need to show the XML header again
# REMOVED 2025/11/05 - this is now handled above
#			cd - >/dev/null
		fi

# UPDATED 2025/10/22 - no longer using APP* variables
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Creating the '${APPNAME}' package..."
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Creating the '${PACKAGE}' package..."
# UPDATED 2025/10/30
#		showMsg 'action' "Creating the '${PACKAGE}' package..." 'screen' 0 5 0 $TEMP
## UPDATED 2025/10/23 - corrected the location to be the passed directory, and moved it to the top of this block
##		cd "${REPO_PREFIX}" >/dev/null 2>>"$LOG_ERRS"					# change into the previous directory (REPO_PREFIX) so the generated files get placed correctly (e.g. /tmp/staging > /tmp)
#		cd "${DIRECTORY}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'action' 'screen' 2				# change into the passed directory (e.g. /tmp/staging[/package][/bin,/etc,/usr,...] > /tmp) so the generated files get placed correctly
		showMsg 'action' "Creating the '${PACKAGE}' package..." 'both' 1 4
# REMOVED 2025/11/05 - this is now handled above
#		cd "${DIRECTORY}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 2 'both' 6					# change into the passed directory (e.g. /tmp/staging[/package][/bin,/etc,/usr,...] > /tmp) so the generated files get placed correctly
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[1/4] Erasing any prior files"
# UPDATED 2025/10/30
#		showMsg 'step' "   [1/4] Erasing any prior files:" 'screen' 1 3 1		# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
# #UPDATED 2025/10/22 - no longer using APP* variables
##		rm -f ${APPHEAD}.* >/dev/null 2>>"$LOG_ERRS"
#		[ -e "${FILENAME}" ] && { rm -f "${FILENAME}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'; }
#		[ -e "${BASENAME}.${EXT_HASH}" ] && { rm -f "${BASENAME}.${EXT_HASH}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'; }
#		[ -e "${BASENAME}.${EXT_LIST}" ] && { rm -f "${BASENAME}.${EXT_LIST}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'; }
#		[ -e "${BASENAME}.${EXT_INFO}" ] && { rm -f "${BASENAME}.${EXT_INFO}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'; }
#		[ -e "${BASENAME}.${EXT_DEPS}" ] && { rm -f "${BASENAME}.${EXT_DEPS}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'; }
#		showMsg 'step' " [done]" 'screen' 2 3
		showMsg 'step' "   [1/4] Erasing any prior files:" 'both' 0 3			# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
		[ -e "${FILENAME}" ] && { rm -f "${FILENAME}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		[ -e "${BASENAME}.${EXT_HASH}" ] && { rm -f "${BASENAME}.${EXT_HASH}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		[ -e "${BASENAME}.${EXT_LIST}" ] && { rm -f "${BASENAME}.${EXT_LIST}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		[ -e "${BASENAME}.${EXT_INFO}" ] && { rm -f "${BASENAME}.${EXT_INFO}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		[ -e "${BASENAME}.${EXT_DEPS}" ] && { rm -f "${BASENAME}.${EXT_DEPS}" >/dev/null 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'; }
		showMsg 'step' " [done]" 'both' 1 5
# UPDATED 2025/10/22 - no longer using APP* variables
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[2/4] Creating the .soft file"
#		mksquashfs "${REPO_OPTION##*/}" "$APPFILE" >>"$LOG_ERRS" 2>&1
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[2/4] Creating the .${EXT_SOFT} file"
# UPDATED 2025/10/30
#		showMsg 'step' "   [2/4] Creating the .${EXT_SOFT} file:" 'screen' 1 3 1
## UPDATED 2025/10/28
##		[ -d "${DIRECTORY}/package" ] && TEMP='package' || TEMP="${2##*/}"		# if the compiled software call above created a 'package' directory then use it to create the packages below, otherwise use the directory that was passed
#		[ -d "${DIRECTORY}/package" ] && TEMP='package' || TEMP=''			# if the compiled software call above created a 'package' directory then use it to create the packages below, otherwise use the directory that was passed
## UPDATED 2025/10/23 - corrected the location to be the passed directory
##		mksquashfs "${REPO_OPTION##*/}" "${FILENAME}" >>"$LOG_ERRS" 2>&1
#		mksquashfs "${TEMP}" "${FILENAME}" >>"$LOG_ERRS" 2>&1 || exitGracefully 1 'step' 'screen' 2 3 'action'
#		showMsg 'step' " [done]" 'screen' 2 3
		showMsg 'step' "   [2/4] Creating the .${EXT_SOFT} file:" 'both' 0 3
		[ -d "${DIRECTORY}/package" ] && TEMP='package' || TEMP='./'			# if the compiled software call above created a 'package' directory then use it to create the packages below, otherwise use the directory that was passed
		mksquashfs "${TEMP}" "${FILENAME}" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'step'
		showMsg 'step' " [done]" 'both' 1 5
# UPDATED 2025/10/22 - no longer using APP* variables
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[3/4] Creating the .hash file"
#		md5sum "$APPFILE" > "${APPHEAD}.hash" 2>>"$LOG_ERRS"
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[3/4] Creating the .${EXT_HASH} file"
# UPDATED 2025/10/30
#		showMsg 'step' "   [3/4] Creating the .${EXT_HASH} file:" 'screen' 1 3 1
#		md5sum "${FILENAME}" >"${BASENAME}.${EXT_HASH}" 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'
#		showMsg 'step' " [done]" 'screen' 2 3
		showMsg 'step' "   [3/4] Creating the .${EXT_HASH} file:" 'both' 0 3
		md5sum "${FILENAME}" >"${BASENAME}.${EXT_HASH}" 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'
		showMsg 'step' " [done]" 'both' 1 5
# UPDATED 2025/10/22 - no longer using APP* variables
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[4/4] Creating the .list file"
#		find "${REPO_OPTION##*/}" -not -type d 2>>"$LOG_ERRS" | sed "s/${REPO_OPTION##*/}//" > "${APPHEAD}.list" 2>>"$LOG_ERRS"
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "[4/4] Creating the .${EXT_LIST} file"
# UPDATED 2025/10/30
#		showMsg 'step' "   [4/4] Creating the .${EXT_LIST} file:" 'screen' 1 3 1
## UPDATED 2025/10/23 - corrected the location to be the passed directory
##		find "${REPO_OPTION##*/}" -not -type d 2>>"$LOG_ERRS" | sed "s/${REPO_OPTION##*/}//" > "${BASENAME}.${EXT_LIST}" 2>>"$LOG_ERRS"
#		find "${TEMP}" -not -type d 2>>"$LOG_ERRS" | sed "s|${TEMP}||" >"${BASENAME}.${EXT_LIST}" 2>>"$LOG_ERRS" || exitGracefully 1 'step' 'screen' 2 3 'action'
#		showMsg 'step' " [done]" 'screen' 2 3
#		showMsg 'action' "" 'screen' 0 4
		showMsg 'step' "   [4/4] Creating the .${EXT_LIST} file:" 'both' 0 3
		find "${TEMP}" -not -type d 2>>"$LOG_ERRS" | sed "s|${TEMP}||" >"${BASENAME}.${EXT_LIST}" 2>>"$LOG_ERRS" || exitGracefully 4 'both' 5 'step'
		showMsg 'step' " [done]" 'both' 1 5
	#	showMsg 'action' "" 'screen' 0 4
# UPDATED 2025/10/28
#		echo -e "\nThe package has been created!"
## UPDATED 2025/10/22 - no longer using APP* variables
##		echo -e "Don't forget to create/update the .deps and .info files!\n"
#		echo -e "Don't forget to create/update the .${EXT_HASH} and .${EXT_INFO} files!\n"
	#	showMsg 'note|success' "\nThe package has been created!\nDon't forget to create/update the .${EXT_DEPS} and .${EXT_INFO} files!\n"
		showMsg 'note' "\nThe package has been created!\nDon't forget to create/update the .${EXT_DEPS} and .${EXT_INFO} files!\n" 'both' 1 2 1
		showMsg 'success' "" 'both' 1 6
		exit 0										# prevent the code below from executing since we're done with this ACTION
	elif [ "$PROXY" ]; then									# if we are proxying an action, then...
# UPDATED 2025/10/28
#		echo "$RAWFILE" >> "${DIR_TEMP}/proxy.list"
		echo "$PACKAGE" >> "${DIR_TEMP}/proxy.list"					# create the proxy package list
		continue
	elif [ "$UNLOAD" ]; then									# if we are unloading/uninstalling package(s), then...
		EXEID="$(grep -lH "$PACKAGE" "${DIR_TEMP}/installed."*)"			# store the cache file containing the software to be uninstalled
	fi

	# NOTE: everything below this point in this segment is simply to build the dependency list, the actual work is done in the following 'while' loop
# REMOVED 2025/11/07
#	else
#echo "INDEX |$INDEX|"
# MOVED 2025/11/12 - this was moved above
#		[ "$RESTORE" ] && cd "${REPO_RESTOR}/${RESTORE}"				# change into the restore points directory to get all the requested software and any of its dependencies
# UPDATED 2025/10/22 - using PACKAGE
#		[ "$UNLOAD" ] && EXEID="$(grep -lH "$RAWFILE" "${DIR_TEMP}/"*)"			# store the cache file containing the software to be uninstalled
# MOVED 2025/11/12 - this was moved above
#		[ "$UNLOAD" ] && EXEID="$(grep -lH "$PACKAGE" "${DIR_TEMP}/"*)"			# store the cache file containing the software to be uninstalled
# REMOVED 2025/11/06 - this was moved in the parameter processing above
#		[ "$TREE" ] && {
## UPDATED 2025/10/28
##			echo -e "\n[ DEPENDENTS ]"
### UPDATED 2025/10/22 - no longer using APP* variables
###			echo "${APPNAME}.${APPTYPE}"
##			echo "${PACKAGE}"
## UPDATED 2025/10/31
##			showMsg 'dependents' "\n[ DEPENDENTS ]" 'screen' 0 5 1
##			showMsg 'dependent' "${PACKAGE}" 'screen' 0 3
#			showMsg 'dependents' "\n[ DEPENDENTS ]" 'both' 1 4 1
#			showMsg 'package' "${PACKAGE}" 'both' 1 1
## VER2 - update this once we have our own repo
##			echo "${PACKAGE}[${TYPE}]"
## UPDATED 2025/10/22 - no longer using APP* variables
##			for DEPFILE in $(ls -1 $DIR_LIST | grep 'deps'$); do			# find any form of the iterated package (e.g. bash.i64.bin.soft, bash.bin, etc) in any installed software .deps file
##				grep -q "${APPNAME}.${APPARCH}.${APPTYPE}.${APPEXTN}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
##				grep -q "${APPNAME}.${APPTYPE}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
##				grep -q "${RAWFILE}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
#			for DEPFILE in $(ls -1 "$DIR_LIST" | grep ${EXT_DEPS}$); do		# find any form of the iterated package (bash.i64.bin.soft, bash[bin], bash) in any installed software .deps file
## UPDATED 2025/10/28
##				grep -q "${FILENAME}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
## UPDATED 2025/10/29
##				grep -q "${PACKAGE}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
## UPDATED 2025/10/31
##				grep -q "${FILENAME}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { showMsg 'dependent' "   $DEPFILE" 'screen' 0 3 1; continue; }
#				grep -q "${FILENAME}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { showMsg 'dependent' "   $DEPFILE" 'both' 1 1 1; continue; }
## VER2 - uncomment this once we have our own repo (since it's another variation of the filename that can be present in the deps file)
##				grep -q "${APPNAME}.${APPTYPE}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { echo "  $DEPFILE"; continue; }
## UPDATED 2025/10/31
##				grep -q "${PACKAGE}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { showMsg 'dependent' "   $DEPFILE" 'screen' 0 3 1; continue; }
#				grep -q "${PACKAGE}" "${DIR_LIST}/${DEPFILE}" 2>/dev/null && { showMsg 'dependent' "   $DEPFILE" 'both' 1 1 1; continue; }
#			done
## UPDATED 2025/10/31
##			showMsg 'dependents' '' 'screen' 0 4
#			showMsg 'dependents' '' 'both' 1 5
## UPDATED 2025/10/28
##			echo -e "\n[DEPENDENCIES]"
## UPDATED 2025/10/31
##			showMsg 'dependencies' "\n[DEPENDENCIES]" 'screen' 0 5 1
#			showMsg 'dependencies' "\n[DEPENDENCIES]" 'both' 1 4 1
#		}
# UPDATED 2025/10/22 - using PACKAGE
#		processDependencies "${RAWFILE}"
		processDependencies "${PACKAGE}" || exitGracefully 2 'screen' 5 'step'
		[ ! "$DEPENDENCY" ] && continue							# if the iterated package has already been installed (via a prior package), then no need to waste resources below...
# UPDATED 2025/10/31
#		[ "$TREE" ] && { showMsg 'dependencies' '' 'screen' 0 4; continue; }		# if we are simply displaying a dependency tree, then go to the next package in the list
	# probably don't need this any longer
	#	[ "$TREE" ] && { showMsg 'dependencies' '' 'both' 1 5; continue; }		# if we are simply displaying a dependency tree, then go to the next package in the list
# REMOVED 2025/11/06 - since this become its own loop, we don't need this any longer
#		[ "$VALIDATE" = 'deps' ] && continue						# if we are validating a packages dependencies, then go to the next package
# UPDATED 2025/10/28
#		[ "$VALIDATE" = 'data' ] && { ( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -e "\nValidating the package data..."; }
# UPDATED 2025/10/31
#		[ "$VALIDATE" = 'data' ] && { showMsg 'action' "\nValidating the package data..." 'screen' 0 0 1; }
# REMOVED 2025/11/06 - this was moved outside of this loop
#		[ "$VALIDATE" = 'data' ] && { showMsg 'action' "\nValidating the package data..." 'screen' 1 4 1; }
		[ "$UNLOAD" ] && {								# if we are unloading, then...
			INDEX=1									#   change the INDEX value since we need to reverse the order to process the dependencies
			eval "DEPENDENCY=\$DEP${INDEX}"						#   reset the variable value to the new 'pointer' value of the 'array'
		}
# REMOVED 2025/11/07
#	fi
# ADJUSTED 2025/11/05 - made these two separate loops so all the dependencies get processed at once to generate the entire list before actual actions take place
#echo DBUG
#continue
#echo DBUG
#exit 0

	# PROCESS THE ACTION (per passed package)						NOTE: this has to be done this way so that (un)installations can create and process proper file lists

	[ $DEBUG -gt 1 ] && {
		echo -en "   Do you want to proceed with the action? [Y/N] (N): "
		read
		( [ "$REPLY" = 'N' ] || [ "$REPLY" = 'n' ] || [ "$REPLY" = '' ] ) || exitGracefully 0
	}

	[ "$COPY" ] && showMsg 'action' "Copying the specified package(s)..." 'both' 1 4
	[ "$DOWNLOAD" ] && showMsg 'action' "Downloading the specified package(s)..." 'both' 1 4
	#[ "$EXTRACT" ]
	#[ "$FIND" ]
	[ "$INSTALL" ] && {
		showMsg 'action' "Installing the specified package(s)..." 'both' 1 4

		# if '-M copy' was passed to this script -OR- the copy-everything-to-RAM file exists -OR- { the copy the system directory (REPO_SYSTEM) contents to RAM file exists -and- we're using that directory (e.g. booting) -and- REPO_SYSTEM and REPO_OPTION are NOT the same (to prevent TC from erroneously loading everything to RAM since those two would be the same) }, then...
		if [ "$MODE" = 'copy' ] || [ -e "${REPO_PREFIX}/copy_all.flag" ] || ( [ -e "${REPO_PREFIX}/copy_sys.flag" ] && [ "$REPO_SOURCE" = "$REPO_SYSTEM" ] && [ "$REPO_SYSTEM" != "$REPO_OPTION" ] ); then
#echo top
			[ $DEBUG -gt 0 ] && echo -e "\tInstall by copying..." >>"$LOG_DBUG"
#			showMsg 'step' " [copy]" 'both' 0 0
			MODE='copy'
		else
#echo btm
			[ $DEBUG -gt 0 ] && echo -e '\tInstall using symlinks...' >>"$LOG_DBUG"
#		showMsg 'step' " [link]" 'both' 0 0
			MODE='link'
		fi
	}
	#[ "$LIST" ]
	#[ "$MAKE" ]
	#[ "$PROXY" ]
	[ "$VALIDATE" ] && showMsg 'action' "Validating the package contents..." 'both' 1 4


	# now process the dependencies obtained from the above segment!
	while [ "$DEPENDENCY" ] && [ $INDEX -gt 0 ]; do						# while we have a dependency to process via the DEPENDENCY value set by processDependencies() and INDEX adjusted within this loop itself
# UPDATED 2025/10/22 - no longer using APP* variables; UPDATED AGAIN 2025/11/05 - the dependency files are all the full names so we don't have to worry about splitting anything
		splitName "$DEPENDENCY"

# REMOVED 2025/11/05 - with adjustments made above, these statements may no longer be relevent
##		# find and change into, the directory containing the package to be processed	  NOTE: the downloadPackage() will make further directory adjustments below
## UPDATED 2025/10/22 - no longer using APP* variables
##		if [ ! "$REPO_SOURCE" ] && [ -e "./${APPFILE}" ]; then								# if no source was provided via '-S' and the pwd has the file (e.g. from a restore point), then...
#		if [ ! "$REPO_SOURCE" ] && [ -e "./${FILENAME}" ]; then						# if no source was provided via '-S' and the pwd has the file (e.g. from a restore point), then...
#			SOURCE='local'
#		elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'http' || echo "$REPO_SOURCE"|grep -q ^'ftp' ); then	# if a different SOURCE was provided -AND- it is remote, then...
#			cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1 || exitGracefully 1						# NOTE: we cd into this directory just as a precaution
#			DOWNLOAD=TRUE
## UPDATED 2025/10/22 - no longer using APP* variables
##		elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'/' || echo "$REPO_SOURCE"|grep -q ^'./' ) && ( [ -e "${REPO_SOURCE}/${APPFILE}" ] || [ -f "${REPO_SOURCE}/${VERFILE}" ] ); then	# if a different SOURCE was provided -AND- it is a directory -AND- the iterated package exists in the REPO directory, then...	NOTE: the use of -f is required in case VERFILE is blank
#		elif [ "$REPO_SOURCE" ] && ( echo "$REPO_SOURCE"|grep -q ^'/' || echo "$REPO_SOURCE"|grep -q ^'./' ) && ( [ -e "${REPO_SOURCE}/${FILENAME}" ] || [ -f "${REPO_SOURCE}/${VERFILE}" ] ); then	# if a different SOURCE was provided -AND- it is a directory -AND- the iterated package exists in the REPO directory, then...	NOTE: the use of -f is required in case VERFILE is blank
#			cd "$REPO_SOURCE" >>"$LOG_ERRS" 2>&1 || exitGracefully 1
#			unset DOWNLOAD
## UPDATED 2025/10/22 - no longer using APP* variables
##		elif [ -e "${REPO_SYSTEM}/${APPFILE}" ] || [ -f "${REPO_SYSTEM}/${VERFILE}" ]; then				# otherwise check that the file exists in the REPO_SYSTEM...
#		elif [ -e "${REPO_SYSTEM}/${FILENAME}" ] || [ -f "${REPO_SYSTEM}/${VERFILE}" ]; then		# otherwise check that the file exists in the REPO_SYSTEM...
#			cd "$REPO_SYSTEM" >>"$LOG_ERRS" 2>&1 || exitGracefully 1
#			unset DOWNLOAD
#		else														# and lastly change to the default REPO_OPTION as a last resort to find the software
#			cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1 || exitGracefully 1
## UPDATED 2025/10/22 - no longer using APP* variables
##			( [ -e "${REPO_OPTION}/${APPFILE}" ] || [ -f "${REPO_OPTION}/${VERFILE}" ] ) && unset DOWNLOAD || DOWNLOAD=TRUE
#			( [ -e "${REPO_OPTION}/${FILENAME}" ] || [ -f "${REPO_OPTION}/${VERFILE}" ] ) && unset DOWNLOAD || DOWNLOAD=TRUE
#		fi

# UPDATED 2025/10/22 - no longer using APP* variables
#		[ $DEBUG -gt 0 ] && { echo -en "  body:\n\tINDEX      :${INDEX}:\n\tDEPENDENCY :${DEPENDENCY}:\n\tAPPFILE    :$APPFILE:\n\tAPPHEAD    :$APPHEAD:\n\tAPPNAME    :$APPNAME:\n\tAPPARCH    :$APPARCH:\n\tAPPTYPE    :$APPTYPE:\n\tAPPEXTN    :$APPEXTN:\n\tVERSION :${VERSION}:\n\tVERFILE    :$VERFILE:\n\tDOWNLOAD  :$DOWNLOAD:\n\tpwd        " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }
# UPDATED 2025/11/05 - the dependency files are all the full names so we don't have to worry about splitting anything
#		[ $DEBUG -gt 0 ] && { echo -en "  body:\n\tINDEX      |${INDEX}|\n\tDEPENDENCY |${DEPENDENCY}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE    |${PACKAGE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tTYPE        |${FILETYPE}|\n\tVERSION |${VERSION}|\n\tVERFILE    |$VERFILE|\n\tDOWNLOAD  |$DOWNLOAD|\n\tpwd        " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }
		[ $DEBUG -gt 0 ] && { echo -en "body (implementation):\n\tINDEX       |${INDEX}|\n\tDEPENDENCY  |${DEPENDENCY}|\n\tFILENAME    |${FILENAME}|\n\tBASENAME    |${BASENAME}|\n\tPACKAGE     |${PACKAGE}|\n\tEXT_SOFT    |${EXT_SOFT}|\n\tTYPE        |${FILETYPE}|\n\tVERSION     |${VERSION}|\n\tVERFILE     |$VERFILE|\n\tDOWNLOAD    |$DOWNLOAD|\n\tpwd         " >>"$LOG_DBUG"; pwd >>"$LOG_DBUG" 2>>"$LOG_ERRS"; }

		# NOTE: this is a separate 'if' on purpose!	NOTE: these only need to execute if we are NOT validating packages
# UPDATED 2025/11/06
#		if [ ! "$DOWNLOAD" ] && [ ! "$VALIDATE" ]; then
		if [ ! "$DOWNLOAD" ]; then
# UPDATED 2025/10/22 - no longer using APP* variables
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${APPFILE}: [local]"
# UPDATED 2025/10/28
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${FILENAME}: [local]"
# UPDATED 2025/11/05
#			showMsg 'step' "${FILENAME}: [local]" 'screen' 1
			showMsg 'step' "${DEPENDENCY}: [local]" 'both' 0 3
# UPDATED 2025/11/06
#		elif [ "$DOWNLOAD" ] && [ ! "$VALIDATE" ]; then
		elif [ "$DOWNLOAD" ]; then
# UPDATED 2025/10/22 - no longer using APP* variables
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${APPFILE}: [remote]"
# UPDATED 2025/10/28
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "${FILENAME}: [remote]"
# UPDATED 2025/11/05
#			showMsg 'step' "${FILENAME}: [remote]" 'screen' 1
#			[ "$REPO_TARGET" ] && cd "$REPO_TARGET" >>"$LOG_ERRS" 2>&1 || cd "$REPO_OPTION" >>"$LOG_ERRS" 2>&1		# if a different target was specified, then cd into it now, otherwise use the default location!
			showMsg 'step' "${DEPENDENCY}: [remote]" 'both' 0 3
			downloadPackage || exitGracefully 4 'screen' 5 'step'
		fi

		# NOTE: this is a separate 'if' on purpose!
		if [ "$COPY" ]; then								# if we're copying package(s), then...
# UPDATED 2025/10/28
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [copy]"
			showMsg 'step' " [copy]" 'both' 0 0
# UPDATED 2025/11/05
#			copyPackage || exitGracefully 1
			copyPackage || exitGracefully 4 'screen' 5 'step'
		#elif [ "$EXTRACT" ]; then									# if we are extracting package(s) contents, then...
			# this is handled in the package processing above
		#elif [ "$FIND" ]; then									# if we are finding file(s) in packages, then...
			# this is handled in the package processing above
		elif [ "$INSTALL" ]; then							# if we're installing package(s), then...
# REMOVED 2025/10/21 - unsure what this was doing
#			if [ -e "${DIR_LIST}/${APPFILE}" ]; then						# if we are updating the installed package, then...
# UPDATED 2025/10/08
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [install]"
# UPDATED 2025/10/28
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || {
## UPDATED 2025/10/22 - no longer using APP* variables
##				[ ! -e "${DIR_LIST}/${APPFILE}" ] && echo -n " [install]"
##				[ -e "${DIR_LIST}/${APPFILE}" ] && echo -n " [update]"
#				[ ! -e "${DIR_LIST}/${FILENAME}" ] && echo -n " [install]"
#				[ -e "${DIR_LIST}/${FILENAME}" ] && echo -n " [update]"
#			}
			[ ! -e "${DIR_LIST}/${FILENAME}" ] && showMsg 'step' " [install]" 'both' 0
			[ -e "${DIR_LIST}/${FILENAME}" ] && showMsg 'step' " [update]" 'both' 0
# UPDATED 2025/11/12
#			installPackage || exitGracefully 1
			installPackage || exitGracefully 4 'screen' 5 'step'
		#elif [ "$LIST" ]; then									# if we are listing the installed packages, then...
			# this is handled in the script parameter processing section
		#elif [ "$MAKE" ]; then									# if we are creating a package for distribution, then...
			# this is handled in the package processing above
		#elif [ "$PROXY" ]; then									# if we are proxying an action, then...
			# this is handled in the final processing below
		elif [ "$RESTORE" ]; then							# if we're restoring package(s), then...
# UPDATED 2025/10/28
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [restore]"
			showMsg 'step' " [restore]" 'screen' 1
# UPDATED 2025/10/22 - no longer using APP* variables
#			[ -e "${DIR_LIST}/${APPFILE}" ] && { unloadPackage || exitGracefully 1; }				# if an undesired version/non-working package is currently installed, remove it now
			[ -e "${DIR_LIST}/${FILENAME}" ] && { unloadPackage || exitGracefully 1; }			# if an undesired version/non-working package is currently installed, remove it now
			copyPackage || exitGracefully 1										# copy the restore point packages back into the system
			installPackage || exitGracefully 1									# install that version
		#elif [ "$TREE" ]; then
			# this is handled in the script parameter processing section
		elif [ "$UNLOAD" ]; then							# if we're unloading package(s), then...
# UPDATED 2025/10/28
#			( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n " [unload]"
			showMsg 'step' " [unload]" 'screen' 1
			unloadPackage || exitGracefully 1
		elif [ "$VALIDATE" ]; then							# if we're validating package(s), then...
# UPDATED 2025/11/06
#			validatePackage || exitGracefully 1
#			deleteDependency TRUE
#			continue
			eval TEMP="${DIR_LOOP}/${LOOP_SCHEMA}"
			( /bin/mount | grep -q "${TEMP} type squashfs" ) && MODE='link' || MODE='copy'	# store the package installation mode: symlinked or copied
			installPackage || exitGracefully 4 'screen' 5 'step'
		fi
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo " [done]"
		showMsg 'step' " [done]" 'both' 1 5

# LEFT OFF - installing doesn't appear to process dependencies without a trailing TRUE
		deleteDependency								# delete the dependency before assigning the next one below
		[ "$UNLOAD" ] && INDEX=$(( INDEX + 1 ))						# if we are unloading, then we need to reverse the order to process the dependencies
		[ ! "$UNLOAD" ] && INDEX=$(( INDEX - 1 ))					# move the 'pointer' within the $DEP 'array' (instead of calling deleteDependency() since we need those values below)
		eval "DEPENDENCY=\$DEP${INDEX}"							# reset the variable value to the new 'pointer' value of the 'array'
	done
done


echo DBUG
exit 0


# EXECUTE FINAL PROCESSING

# finalize any output for '-O xml' with any of these actions
# UPDATED 2025/10/31 - combined the statements
#if [ "$EXTRACT" ] && ( [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ] ); then		# if we are extracting a packages contents, then...
#	showMsg 'success' "" 'both' 1 6
#elif [ "$FIND" ] && ( [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ] ); then			# if we are finding files in packages, then...
#	showMsg 'success' "" 'screen' 1 6
#fi
if ( [ "$COPY" ] || [ "$EXTRACT" ] || [ "$FIND" ] ) && ( [ "$OUTPUT" = 'xml' ] || [ "$OUTPUT" = 'xmLive' ] ); then		# if we're copying, extracting, or finding, then...
	showMsg 'success' "" 'both' 1 6
	exitGracefully 0

# now move the proxy files to the external storage device
elif [ "$PROXY" ]; then
# UPDATED 2025/10/28
#	( [ "$SILENT" ] || [ "$QUIET" ] ) || echo -n "Creating the proxy information: "
# UPDATED 2025/10/31
#	showMsg 'action' "Creating the proxy information:" 'screen' 1 0 0 1
	showMsg 'action' "Implementing the proxy..." 'both' 1 4

	showMsg 'step' "   [1/3] Checking the directory:" 'both' 0 3			# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
	if [ -d "${PROXY}/pax" ]; then
		showMsg 'step' " [exists]" 'both' 1 5
	else
		showMsg 'step' " [creating]" 'both' 0 0
# UPDATED 2025/10/28
#		mkdir -p "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The proxy directory does not exist and could not be created." >>"$LOG_ERRS"; exitGracefully 1; }
# UPDATED 2025/10/31
#		mkdir -p "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The proxy directory does not exist and could not be created." 'log'; exitGracefully 1 'action' 'screen' 2; }
		mkdir -p "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'action'
		showMsg 'step' " [done]" 'both' 1 5
	fi

	showMsg 'step' "   [2/3] Moving proxy.sh script:" 'both' 0 3			# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
# UPDATED 2025/10/23 - since the script contains the actions to take (e.g. download or copy), the script must be copied everytime; this is also helpful if its contents get updated in a future version to not have stale versions of it
#	if [ -e "${DIR_TEMP}/proxy.sh" ]; then							# if the script isn't already on the storage device, then copy it!
# UPDATED 2025/10/28
#		mv "${DIR_TEMP}/proxy.sh" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The device mount point is not writable or invalid." >>"$LOG_ERRS"; exitGracefully 1; }
# UPDATED 2025/10/31
#		mv "${DIR_TEMP}/proxy.sh" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The device mount point is not writable or invalid." 'log'; exitGracefully 1 'action' 'screen' 2; }
		mv "${DIR_TEMP}/proxy.sh" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'action'
#	fi
	showMsg 'step' " [done]" 'both' 1 5
	showMsg 'step' "   [3/3] Moving the proxy list :" 'both' 0 3			# NOTE: we can't do an "rm -f BASENAME.* since it would erase the .make file too
# UPDATED 2025/10/28 - to prevent prior proxy contamination, we need to move the list over every time
#	if [ ! -e "${PROXY}/pax/proxy.list" ]; then						# if the list isn't, then move it!
#		mv "${DIR_TEMP}/proxy.list" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { echo "ERROR: The device mount point is not writable or invalid." >>"$LOG_ERRS"; exitGracefully 1; }
# UPDATED 2025/10/31
#		mv "${DIR_TEMP}/proxy.list" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || { showMsg 'failure' "The device mount point is not writable or invalid." 'log'; exitGracefully 1 'action' 'screen' 2; }
		mv "${DIR_TEMP}/proxy.list" "${PROXY}/pax" >>"$LOG_ERRS" 2>&1 || exitGracefully 4 'both' 5 'action'
#	else											# otherwise, there is so lets add to it!
#		cat "${DIR_TEMP}/proxy.list" >> "${PROXY}/pax/proxy.list" 2>>"$LOG_ERRS" || { echo "ERROR: The device mount point is not writable or invalid." >>"$LOG_ERRS"; exitGracefully 1; }
#		rm "${DIR_TEMP}/pax/proxy.list" >>"$LOG_ERRS" 2>&1
#	fi
	showMsg 'step' " [done]" 'both' 1 5

# UPDATED 2025/10/28
#	echo " [done]"
#	echo
#	echo "On another device execute the 'pax/proxy.sh' script that was just created on the"
#	echo "removable media to obtain the desired package(s).  Return to this device and use"
#	echo "pax to install the files placed on the removable media into this OS."
#	echo
# UPDATED 2025/10/31
#	showMsg 'action' " [done]" 'screen' 0 4
#	showMsg 'note' "\nOn another device execute the 'pax/proxy.sh' script that was just created on the\nremovable media to obtain the desired package(s).  Return to this device and use\npax to install the files placed on the removable media into this OS.\n"
	showMsg 'note' "\nOn another device execute the 'pax/proxy.sh' script that was just created on the\nremovable media to obtain the desired package(s).  Return to this device and use\npax to install the files placed on the removable media into this OS.\n" 'both' 1 2 1
	showMsg 'success' "" 'both' 1 6
	exitGracefully 0
fi

# now update the system that all the packages contents have been installed
if [ "$INSTALL" ] || [ "$RESTORE" ] || [ "$UNLOAD" ]; then					# since these are the only ACTIONs that would require the system to be updated...
	# if any processing so far has determined that a package(s) have kernel modules to process, then...			  NOTE: no need for 'sudo' when booting since the user is root at that time
	if [ "$MODULES" ]; then
		[ $DEBUG -gt 0 ] && echo -e '\tThere are kernel modules to (un)install...' >>"$LOG_DBUG"
		/sbin/depmod -a >>"$LOG_ERRS" 2>&1
		/sbin/udevadm trigger >>"$LOG_ERRS" 2>&1
	fi
	if [ "$LIBRARIES" ]; then
		[ $DEBUG -gt 0 ] && echo -e '\tThere are dynamic libraries to (un)install...' >>"$LOG_DBUG"
		/sbin/ldconfig >>"$LOG_ERRS" 2>&1
	fi
fi

# now call any marker/service scripts (if not unloading which is handled in unloadPackage())
if [ "$INSTALL" ] || [ "$RESTORE" ]; then
	if [ -s ${DIR_TEMP}/installs.list ]; then
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Running deferred install scripts..." | tee -a "$LOG_ERRS"
		showMsg 'action' "Running deferred install scripts..."
# UPDATED 2025/10/22 - no longer using APP* variables
#		for APPFILE in $(cat ${DIR_TEMP}/installs.list); do
#			echo "$APPFILE" | tee -a "$LOG_ERRS"
#			"$APPFILE" 2>&1 | tee -a "$LOG_ERRS"
		for FILE in $(cat ${DIR_TEMP}/installs.list); do
			echo "$FILE" | tee -a "$LOG_ERRS"
			"$FILE" 2>&1 | tee -a "$LOG_ERRS"
		done
		rm -f ${DIR_TEMP}/installs.list 2>>"$LOG_ERRS"
	fi
	if [ -s ${DIR_TEMP}/services.list ]; then
# UPDATED 2025/10/28
#		( [ "$SILENT" ] || [ "$QUIET" ] ) || echo "Running deferred service scripts..." | tee -a "$LOG_ERRS"
		showMsg 'action' "Running deferred service scripts..."
# UPDATED 2025/10/22 - no longer using APP* variables
#		for APPFILE in $(cat ${DIR_TEMP}/services.list); do
#			echo "$APPFILE" | tee -a "$LOG_ERRS"
#			"$APPFILE" start 2>&1 | tee -a "$LOG_ERRS"
		for FILE in $(cat ${DIR_TEMP}/services.list); do
			echo "$FILE" | tee -a "$LOG_ERRS"
			"$FILE" start 2>&1 | tee -a "$LOG_ERRS"
		done
		rm -f ${DIR_TEMP}/services.list 2>>"$LOG_ERRS"
	fi
fi

exitGracefully 0


#LEFT OFF

#pax
#implement -p and -O (don't load during booting unless debug>0)			show OUTPUT (screen,log,both) MESSAGE
#instituting EXT_* vars, left off @ split name()
#	use TYPE for APPTYPE (since that's set via switches)

#
#   Outstanding (LEFT OFF)
#	dependency.i32.lib.soft[1.2.3-2.3.1]				package requires within this range of version numbers of this dependency
#	dependency.i32.lib.soft[>1.2.3] or [1.2.3+]			package requires a version greater than or equal to stated of this dependency
#	dependency.i32.lib.soft[<1.2.3] or [1.2.3-]			package requires a version less or equal to than stated of this dependency
#	dependency.i32.lib.soft[=1.2.3] or [1.2.3!]	(implemented)	package requires this exact version of this dependency and will fail if not currently installed; useful for upgrading web.de themes to make sure web.de itself is at a certain version for compatibility
#	dependency.i64.bin.soft|dependency2.i64.bin.soft|...		package requires any of these dependencies (e.g. thttpd,apache,paged,...)	NOTE: should be in order of preference by OEM; (e.g. TC - size to keep overall size of system down)
#	dependency.i64.bin.soft{file1,file2,file3,...}			package requires only certain files from the dependency


# TESTS
# cd ~/Projects/Scripts/pax
# sudo su root
# cp -dpR TESTING/* /tmp
# exit
# cd /tmp
# pax -S /tmp -c zip zipperityduda zebra4/			can incorporate .deps.err files to check that errors occur corrently
# pax -e zip zebra4/
# pax -e zebra6/
# pax -e zip[.i64.bin.soft] zlib_base[.i64.dev.soft]
# pax -O fifo -e zip zlib_base
# pax -O xml -e zip[.i64.bin.soft] zlib_base
# pax -l
# pax -l zip zlib
# pax -m ASDF /tmp/zebra2
# pax -O fifo -m ASDF /tmp/zebra2
# pax -O xml -m ASDF /tmp/zebra2
# pax -X /tmp/zebra5/ -d zip
# pax -O fifo -X /tmp/zebra5/ -d zip
# pax -O xml -X /tmp/zebra5/ -d zip
# pax -t libreoffice
# pax -O fifo -t libreoffice
# pax -O xml -t libreoffice





#builer
#- expand -i to take 'root' (/etc/builder/...) or 'home' (~/.etc/builder/...)
#- get script to check in XSB and LSB directories




# 'sudo pax -v data compiletc' does not work

# ask where to install: system (/), everyone (/Users/Public/.{bin|sbin|lib|...}), personal (/Users/$USER/.{bin|sbin|lib|...})		NOTE: there are no sbin's any more; also /Users/Public is for system-wide usage WITHOUT having elevated installation credentials (compared to system installations to /)
#	how do we address where to install during boot?		maybe utilize .list files for this?

# file	description
# -------------------
# pre	checks that the account has permission to install the value
#	Example values: group	advanced	(to indicate the user needs to be a member of the 'advanced' group to install this package; can issue UI prompt for elevated account status)
#			location /
#
# post	indicates any actions required post-install
#	Example values: device	reboot		(to indicate that a reboot is neccessary to complete install)
#			service	restart		(to indicate a service needs to restart)

