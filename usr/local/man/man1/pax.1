.\"Man page for pax, by Dave Henderson.
.TH pax 1 "2026 January 22"
.SH NAME
\fIpax\fR - package manager




.SH SYNOPSIS
.B pax [OPTIONS] ACTION {PACKAGE(S)|FILELIST} [DIRECTORY]

ACTIONS:
  -c   copy local packages to another directory
  -d   download package(s) only
  -e   extract local package(s) contents
  -f   find which local package(s) a file belongs to
  -i   install package(s)
  -l   list all currently installed packages
  -m   make a new package (requires DIRECTORY)
  -o   open a fifo for (remote) communication
  -t   show the dependency trees of package(s): relies, reliant
  -u   uninstall package(s): update, unload, unlist, delete, purge
  -v   validate package(s) info: data, hash, deps, fix
  -z   populates DIR_LIST with package files'

  --help      shows this screen
  --install   installs pax as the default package manager
  --uninstall uninstalls pax as the default package manager
  --version   displays the software version

OPTIONS:
  -B   indicates we are currently booting the system
  -C   specifies an alternative CPU architecture: i32, i64, r32, r64
  -D   dependency handling: none, default, all, source
  -E   include extra package files: all, code, cpio, info, list, make
  -F   force the ACTION to take place
  -I   list of dependencies to ignore
  -K   specifies an alternative kernel name
  -L   the list to adjust: none, boot, live
  -M   defines the package install mode: copy, link (default)
  -N   do NOT install all files in the package, just those specified
  -O   display output format: fifo, text, xml, xmLive
  -P   prompt before taking action
  -Q   quiets the output: all, errors, default, verbose, none
  -R   the action applies to restore points
  -S   changes the source directory/repo to obtain software from
  -T   specifies the package type: bin, dev, doc, drv, gir, lib, loc
  -V   the specific version of a package to install
  -X   obtain packages via proxy using another device
  -Y   performs a dry run of the action
  -Z   add color to the output




.SH TOC
1.  DESCRIPTION
2.  CONFIG
3.  PARAMETERS
4.  ACTIONS
5.  OPTIONS
6.  EXAMPLES
7.  BUGS
8.  ACKNOWLEDGEMENTS
9.  COPYRIGHT
10. AUTHORS




.SH DESCRIPTION
.I pax
is a lightweight, robust, and versatile package manager for Linux distros.
While not quite as feature rich as the apt/dpkg Debian system, pax also is
a fraction of its size (almost a 10th at 200kb)! The development of this
project will continue so that all commonly used functions will eventually
be incorporated, along with several that are unique. There are also plans
to have this package manager work with non-native package formats such as
.deb and .rpm, allowing users and admins another (standardized) option in
their network of devices.

Currently this project can perform a variety of operations including:
  o Copying packages (and dependencies) from one location to another
  o Extracting packages (and dependencies) to a specified location
  o Downloading packages (and dependencies) to a specified location
  o Finding local packages that one or more files belong to
  o (Un)installing packages (and dependencies)
  o (Un)installing different versions of packages
  o List installed packages
  o Make and package software for distribution
  o Open a fifo for network client operation
  o Display dependency trees for packages
  o Validate and repair installed software
  o Output can be displayed in various formats
  o Proxy several actions from an offline to an online device

Common outstanding features include:
  o Ability to search online repos
  o Automated package checking/downloading/updating
  o A graphical user interface

Unique outstanding features include:
  o Ability to process .deb (and other) package types
  o Expand output to include an 'html' and 'json' option
  o More proxy actions
  o A centralized update server
  o A network server to manipulate packages on clients




.SH CONFIG
There are a variety of values that can be modified so that pax can work
with any Linux distro. This ranges from package storage locations and
operational directories, to package extensions and schemas. Each value
will be covered below, but first lets discuss config file placements.
There are three locations that pax searches for its configuration. The
first is the system-wide settings found in /etc/pax/config. The second
and third locations are for personal configurations and are found in
~/.etc/pax/config (XSB) and ~/.pax/config (LSB). The search order is
completed by the passed values during execution, each instance taking
precedence over its predecessor.

To summarize:
  o The search order: /etc/pax, ~/.[etc/]pax, passed values

We will now cover each variable available for adjustment in the config
file.

.I Local Repo Values

.B REPO_PREFIX
This directory contains the file lists (LIST_BOOT and LIST_LIVE) as well
as the directories containing your downloaded software packages. So just
as the name suggests, its the prefix to your local repo.

.B REPO_OPTION
A sub-directory of REPO_PREFIX, this directory stores all the optional
software that is added to a basic operating system.

.B REPO_SYSTEM
Like the previous variable, this one also stores additional software.
However, this directory would contain packages to expand a default OS.
For example, XiniX VE stores all the X11 packages in here to load during
the device bootup. This can also contain packages like NTFS so that
filesystems of that type are available for usage. Basically any software
that the base operating system would need, should be added here. Also of
note, this is the default directory processed when the -B switch is
passed.

.B REPO_RESTOR
Specific to pax, this package manager creates restore points when a user
uninstalls software by issuing a '-u delete', '-u purge', or '-u update'
switch.

.I Directory Values

.B DIR_INIT
This directory contains the daemon service scripts.

.B DIR_INST
This directory contains the package installation scripts.

.B DIR_LIST
This directory contains the additional package files for installed
software.

.B DIR_LIVE
Once a device has booted, this is the default directory where packages
get installed. On most distro's this will simply be root (/). However,
XiniX defaults to the /Users/Public directory (which is similar to the
/usr tree in LSB). An interesting feature of this variable allows its
value to end with a dot (.) that will replace the initial slash of
the packaged files. So, for example, if a package contains a file in
the /etc directory, it would then become /Users/Public/.etc in the
XiniX OS (or any other using that notation).

.B DIR_LOGS
This directory contains the softwares logs.

.B DIR_LOOP
This directory contains the mount points for symlinked packages.

.B DIR_TEMP
This directory contains temp files used by the software.

.I Package Extensions

.B EXT_CORE
[text file] Used to mark a package as part of the base OS

.B EXT_CODE
[tgz file] The file extension used for a packages' source code

.B EXT_DEPS
[text file] The file extension used for the package dependency list

.B EXT_HASH
[text file] The file extension used for the package validation hash

.B EXT_INFO
[text file] The file extension used for the package details info

.B EXT_LIST
[text file] The file extension used for the package manifest info

.B EXT_MAKE
[text file] The file extension used for the package make commands

.B EXT_SOFT
[mksquashfs file] The file extension of the actual packaged software

.I Log Files

.B LOG_DBUG
The log file for debug output

.B LOG_ERRS
The log file for (error) output

.I Ownership and Permissions

.B OWN_GROUP
The default group that all users are members of

.B OWN_SYSTEM
The full ownership (user and group) of REPO_SYSTEM directory

.B PRM_SYSTEM
The permissions that the REPO_SYSTEM directory must have (for security)

.I Value Definitions

.B FIFO_SERVER
The default name for the -o action fifo

.B ARCH_VALUES
The valid values for the -C option

.I Schema Values

Since schema's are used as templates, these values can incorporate the
use of several variables. When using these variables, be sure to use
them in the fashion they are shown below. With the exception of the
ARCH_SCHEMA and KRNL_SCHEMA values, all the others should be enclosed
with single quotes (') as they are interprited at specific times instead
of once during the initial execution of the script. The variables are:
  ${PACKAGE} - the package name
  ${ARCH}    - the devices' CPU architecture
  ${TYPE}    - package type
  ${VERSION} - any included package version

.B ARCH_SCHEMA
The command executed to determine which CPU architecture the device falls
under, and relates to one of the values in ARCH_VALUES. This should be
encapsulated with double quotes (").

.B FILE_SCHEMA
This is the schema for the local package filenames and should be enclosed
in single quotes ('). This value should NOT include a file extension!

.B KRNL_SCHEMA
The currently used kernel string that gets appended to Linux kernel driver
packages. Typically this is just "$(uname -r)".

.B REPO_SCHEMA
This is the URL for the distro's online repo, and should be within single
quotes ('). This value should include the 'http' prefix!

.B VERS_SCHEMA
This variable indicates the package naming convention within the online
source repo, using the schema variables to provide the most flexibility
for the distro. For example, if the distro wants to place all associated
files in a single package directory, they can utilize multiple variables
to do so. Contrarily, if the distro wants to separate the various packages
by different URL's, then they can do so as well by using the REPO_SCHEMA
variable. Of course, both values can be simultaneously used for even
greater flexibility. This value should be enclosed with single quotes (')
and WITHOUT a file extension!

.B VERT_SCHEMA
Working alongside VERS_SCHEMA, this variable indicates the target filename
that should be used locally. The '${VERSION}' schema variable usually is
part of this value, but is not mandatory. This value should NOT include a
file extension!

.I Lists and Flags

There are two package lists and four flag files that define which packages
are loaded at the different stages of device operation. The lists should
be considered which packages are desired, whereas the flag files designate
which packages are forbidden - even if they are dependencies of packages
in the list files! Each of these variables should have their values
encapsulated in single quotes (') as they are interprited ondemand.

These variables also have access to a shell function called 'getBootcode'
that allows the value to change depending on the passage of a value from
the boot loader such as grub or syslinux. This way a user can define an
alternative value to use, or the distro default otherwise. An example of
a value could be:
  '$( V=$(getBootcode code); [ "$V" ] && echo $V || echo default )'

.B LIST_BOOT
This list defines which packages are loaded during the device bootup. A
unique feature of pax is that the package loading can be split into two
phases to speed up this process. Packages contained within this list
get loaded in the foreground, causing the bootup to wait until all have
been loaded before continuing. For this reason, kernel drivers and other
necessary packages should be placed here. User applications like an email
and an office suite should be placed in LIST_LIVE.

To enable this dual-phase process, this file must exist, even if it is
blank. Its absense will indicate that all packages need to be processed
in the traditional way, with a longer bootup.

.B LIST_LIVE
A value for this list is mandatory. Unlike LIST_BOOT, this file must
exist as it is used to load packages whether the dual-stage booting is
enabled or not. In fact, to manually switch to a single-stage bootup,
simply move the packages from LIST_BOOT into this list and erase the
other file. And unless an alternate list is specified with the -L
switch, this one is used to know which packages need to be loaded by
default versus which ones should be reserved for ondemand loading.

.B FLAG_BOOT
The complement flag file to LIST_BOOT that contains packages that should
not be loaded during bootup. The list can even contain dependency files.
In essence, this is a blacklist to LIST_BOOT.

.B FLAG_LIVE
The complement flag file to LIST_LIVE that contains packages that should
skipped during the processing of automatically loaded software. This is a
blacklist to LIST_LIVE.

.B FLAG_COPY
Unlike the prior two flag files, the mere presence of this file is the
only requirement to indicate that ALL packages need to be copied instead
of symlinked. This can be overwritten by passing the '-M link' switch when
calling pax though.

.B FLAG_FIRM
Also indicating that packages need to be copied instead of symlinked, but
this flag only pertains to the base OS packages found in REPO_SYSTEM and
LIST_BOOT.

.I Miscellaneous Definitions

.B FOLLOWUP
This variable includes any unique command for the distro that needs to be
called after all packages are loaded. If the value contains the variable
${PACKAGE}, then it will be called once for every package passed into pax.
In its absence, the command will be called once.

.B DEBUG
To see everything that takes place while pax is being executed, set this
value to 1. A pax.debug log will be produced containing a plethora of
information. Setting this value to 2 will additional prompt before any
actual system changes take place.

.B COLORS
If you like colored output, then set this to 'TRUE' and avoid having to
pass the -Z switch every time.




.SH PARAMETERS
To maintain consistency, there are several parameters to note. The first
that we'll cover is PACKAGE(S). Normally this value will consist of a
space separated list of package names. However, a text file containing
one package per line can also be used as an alternative. This can come
in handy if automating any process by moving a variable list of packages
into a text file while calling a uniformed pax command.

The final value that can be used is a directory itself, and will process
all contained packages. The downside to this is that the DIRECTORY value
can no longer be used. An alternative to this method while retaining the
ability to use the DIRECTORY value, is to use -S for the source location.

To summarize, the PACKAGE(S) value can be:
  o A space separated list of package names
  o A file containing a list (one package per line)
  o Or directory containing the package(s)

The last parameter pax can accept is DIRECTORY. Typically it operates as
the target location for the passed action (with the exception outlined
above), and is optional. To provide flexibility for the user, there are
several different syntaxes that are permitted. Both full and relative
paths are permissible, but the value must contain a forward slash (/) to
indicate it's a directory instead of a package name. This will not be a
problem with full paths as they obviously start with one. Relative paths
can either begin with a './', end with a '/', or contain a slash within
the value (e.g. 'some/dir').

To summarize, the DIRECTORY value can be:
  o A full path: /tmp/pax/
  o Or a relative path: ./pax
    Containing a slash: dir/pax
    With a trailing slash: pax/




.SH ACTIONS
As with virtually all software, switches can be passed to modify its
operation. The below section covers each switch in detail, separating
the actions from the options. It is important to note that the options
actually need to proceed the actions when calling pax.

.B --help
Shows helpful information about the program

.B --install
Installs pax as the default package manager in non-XiniX Linux distros. In
this process, there is an option to configure dual or single-stage device
bootup that can speed up the time it takes to get into the OS. See the
'Lists and Flags' section above for more information.

.B --uninstall
Uninstalls pax as the default package manager in non-XiniX Linux distros.

.B --version
Displays the software version and exits.

.B -c
Users can simply use a graphical file manager, or the 'cp' command at a
shell prompt to copy files. However, this would require manually tracing
dependency trees to copy all the necessary packages required to make a
program work correctly. This action reduces all that work into a single,
convenient command. If no PACKAGE(S) value is passed, then all packages
in the DIR_OPTION (or -S location) will be processed.

.B -d
There may be times when a package just needs to be downloaded so it can
be processed in the future. This could include network update servers,
software testing, or even pre-installed ondemand software for (device)
deployment scenarios. Using this action allows the packages to be
obtained before they are required.

.B -e
Similar to the -d ACTION, this switch will extract the contents of one or
more packages to a specified location. This can be useful in situations
where packages need to be (forensically) compared, imaging devices, or any
other situation requiring the extraction of package files. Without passing
a PACKAGE(S) value, all packages in the DIR_OPTION (or -S location) will
be processed.

It is important to note that this action will always overwrite data due to
the underlying binary being used.

.B -f FILES
While not a routine task, there may be times when it is useful to find the
package that a particular file belongs to. This action will allow you to
enter one or more files and search which local packages contains them.

.B -i
The cornerstone of all packages managers, this switch performs the actual
installation of packages so that users don't have to find, compile, and
install software themselves. The packages, or dependencies, can be local
or remote. If no PACKAGE(S) value is passed, then all packages in the
DIR_OPTION (or -S location) will be processed.
If speed is a necessity, and all packages and their dependencies are in
source directory, a '-D none' switch can be included to skip that check.

.B -l
To list the packages currently installed, use this switch. Currently the
output uses a verbose 2 line per package layout containing a plethora of
information about each package - provided the .info files are also present
in the DIR_INST directory. Users can pass specific packages to list, or
process all installed software without a PACKAGE(S) value.
NOTE: There are plans to reduce this to one line in a future version.

.B -m NAME DIRECTORY
This switch can be used to create a package file for distribution and will
bundle all the files in a passed directory. With the presence of a .make
file, pax will execute it to compile software before the packaging phase
takes place. This will enable package maintainers to include their .make
file alongside the packaged software so anyone can easily build from
source.

Unlike other switches, this one can only process one package at a time,
with the PACKAGE(S) value being used as the name of the created package.
This value can still be given in a text file, but only one name can be
included per execution. The other mandatory value is a DIRECTORY (or -S)
value to indicate the location of the files/source code to process.

If no .make file is present, then the passed directory will be considered
the root level for the package being created. If a .make file does exist,
then it needs to be named using the FILE_SCHEMA syntax with a .make file
extension, and placed directly inside the passed directory. Likewise, the
source code directory needs to be in the same location. Its name, however,
if of no value to pax since that will be handled by the .make script. The
compile process must install the created software into a staging directory
named 'project'. The layout should look like:
   /tmp/staging/
           PACKAGE.make
           PACKAGE-source-code-dir/
           project/

.B -o [NAME] [clear]
While there is not a package server manager yet, this switch will be used
by client devices to enable remote administration of packages. This will
be accomplished by using a value similar to:
   FIFO_SERVER='/sshfs/directory/device_NIC_MAC'
to enable network admins to remotely manage packages installed on devices
under their control, including the (un)installation, updating, and repair
of any software.

To give the fifo a different name, you can either modify the FIFO_SERVER
value in the config file, or pass a new name as a value to the -o switch.
In the event that a fifo was left behind due to some type of error, a
cleanup can be made by passing a trailing 'clear' to the pax command.

.B -t VALUE
Sometimes it is helpful to see dependency trees to packages. This switch
offers two different modes to show you this information. Using a value of
'relies' will display the dependencies that the passed package(s) rely on.
Contrarily, a value of 'reliant' will show all the packages that rely on
the ones passed.

.B -u VALUE
This action offers a range of uninstallation modes to handle your needs.
The first mode, 'unload', simply uninstalls the software files from your
device, leaving behind the config and package files for a quick reinstall.
The 'unlist' value performs the same tasks as 'unload', but additionally
removes the package from the LIST_LIVE (or -L list). If the software will
no longer be used, passing a 'delete' command will unlist and delete the
associated package files, leaving the configs untouched. To remove even
the package config files, use a 'purge' value to completely remove all
traces of the software from the device. Keep in mind that none of these
commands affect any data generated by the software, only the software
itself.

The last mode, is 'update', and as the name implies it's for updating
currently installed software to a new version. Unless overwritten, a
restore point is generated for the old version before the new one gets
installed. When performing this action, you need to be in the directory
containing the update so that the -S and DIRECTORY values can operate
as designed (the former being where the existing package file is located
and the latter being the path were the package is installed to).

To summarize:
  o 'unload' - removes application files
  o 'unlist' - unloads and removes LIST_LIVE (or -L) entry
  o 'delete' - unlists and removes package files
  o 'purge'  - deletes and removes config files
  o 'update' - unloads current version, installs new version

.B -v VALUE
There may be times when validating package data is necessary, especially
if software is malfunctioning. This action will enable you to validate the
package dependencies are installed by issuing a 'deps' value. It can also
validate that the files in a package are installed, have the appropriate
ownership/permissions, and either symlinked to the correct target, or that
each installed file is legitimate. Both tasks can be accomplished with a
'data' value, however, using 'hash' will extend validation of each copied
(not symlinked) file via hashes instead of the quicker comparison using
file sizes. The latter mode will take a bit longer to complete. If any
issues are found, you can use a 'fix' value to resolve them.

.B -z
This action is only useful when pax is installed in a distro using several
package managers, but it's not configured as the exclusive default. This
switch will sync the necessary cache files so that it can operate properly
in the OS. Even with this switch, alternating between various managers is
highly discouraged outside of testing environments.

If there are packages whose contents are installed some place other than
root, home, or DIR_LIVE, and have no installation marker, then make sure
to enter the root-level directory containing those files before executing
this action so that the packages can be properly processed.




.SH OPTIONS
To adjust the behavior of actions, you can pass one or more options with
each execution of pax. Remember that these actually need to proceed the
action switch!

.B -B
Used to indicate the device is booting so that packages can be processed
as configured using either a single or dual-phase installation. This also
sets DIRECTORY='/' and checks only REPO_SYSTEM. Users should never pass
this flag in a live environment.

.B -C VALUE
Specifies an alternative CPU architecture to process. This could be useful
for mixed 32/64 bit environments, or for building the OS for a different
target device.

.B -D VALUE
This switch controls how dependencies are processed. A value of 'none'
will prevent this step and affect only the packages pax is instructed to
process via a list, file, or directory. The 'default' value is the normal
mode of operation and will process dependencies. Some packages have
optional dependencies (e.g. documentation) that will also be processed by
using 'all' as the value. There is an additional mode, 'source', which
will work like 'default', but mandates that all the dependencies reside
in the passed -S location. It is impossible to combine the functionality
of 'all' and 'source' - at least presently.

To list packages as optional in the .deps file, use the following syntax:
   [OPTIONAL.EXT_SOFT|INSTALLLED.EXT_SOFT]

Unless '-D none' is used, the search order for dependencies is:
   REPO_SOURCE (-S), REPO_OPTION, REPO_SYSTEM, [REPO_SCHEMA]

.B -E VALUE[,VALUE,...]
In some cases a user might want more than the package files necessary
for an installation. For example, they may want a .make file to build
the package from source, or the .cpio file to include as part of the
base OS. Even downloading the .info file will provide extra package
info when using the -l action. Possible values include:
   all  - download all additional package files
   code - package source code
   cpio - initial ramdisk inclusion file
   info - package information
   list - package manifest listing
   make - package compile script

.B -F
Be careful with the inclusion of this option as it will force the action
to take place, even if dire consequences result!

.B -I VALUE[,VALUE,...]
In rare cases, there may be a need to ignore a dependency from getting
processed. For example, there may be a dependency that is still desired
to retain after another program that relies on it has been uninstalled.
Instead of adding a package to a flag file, this value can be passed
during the execution of pax.

.B -K VALUE
During normal operation, this flag would never be used since it changes
the kernel string attached to driver packages. However, if a kernel update
or an OS build for another device were required, this switch would become
useful.

.B -L VALUE
When installing a package, the default process adds the package to the
LIST_LIVE list. This can be foregone with a value of 'none', or placed
in the LIST_BOOT with a 'boot' value.

.B -M VALUE
Sets the mode for the installation of the package contents. The only two
values are 'copy' and 'link', with the latter referring to maintaining a
loopback mount to the package and symlinking its contents into the OS.
There are several advantages with this method including conservation of
storage space and the inability to manipulate a readonly file system.
This doesn't mean malicious activity can't take place, since symlinks can
be redirected, or replaced with an actual binary. But it does add some
more barriers.

If speed of operation is your primary goal, then you would want to use
the 'copy' value here, which is the default. If the OS uses a ramdisk,
then the speed is even greater than with attached storage.

.B -N VALUE[,VALUE,...]
For instances where storage space is at a premium, security is critical
(by miniming the attack vectors), or those that simply want the smallest
footprint possible, this option will allow only desired files to be
installed instead of the entire package. Using this switch will imply a
'-D none' value, so make sure that any lib packages necessary for the
desired files are also installed.

This can also be implemented within the .deps files themselves using the
following syntax:
   PACKAGE.EXT_SOFT{file1,file2,file3,...}

.B -O VALUE
Another unique feature of pax is that the output can be more than just the
default 'text'. Currently there are three other options with two of them
related to XML. The first is just 'xml' and will display the entire result
of the call at the end of execution. This means that the output will be
inside either a '<s>' (success) or '<f>' (failure) tag. The second is the
'xmLive' value that will display output as it is being processed, adding a
'<failure>' tag in the event of a problem being encountered.

The third additional option is 'fifo' that will output text to a named
pipe file. The long term goal is to build a server/client framework for
networks so that devices can be managed by an admin team using this
interface. Please note, that when using this value, the fifo must be
managed by the calling script or binary, and must use DIR_TEMP/output as
its location. This may be updated in future versions.

Since there may be a race condition while processing parameters, this one
should always be the first in the list to ensure the output is in the
format desired.

There are plans to also add 'json' and 'html' values in a future release.

.B -P
This switch simply prompts the user before implementing the requested
action, showing what is going to occur in the existing output.

.B -Q VALUE
Like most software that has the option to control verbosity, this switch
modifies the quietness of the output. Therefore, a value of 'all' will
actually produce no output, whereas a value of 'none' would make it the
most verbose it could be. Use 'errors' to reduce the output to only show
encountered problems, or 'verbose' to show slightly more than the default.

Since there may be a race condition while processing parameters, this one
should always be the first or second (if -O is also passed) in the list to
ensure the output is in the format desired.

.B -R VALUE
Without this flag, whatever action is passed works with the active local
or remote repo for packages. There may be instances where packages from
the restore points are desired. For example, lets say that a package got
updated on the device and now there's an issue. Until that issue can be
resolved, the user may want to rollback to their prior installation. To
accomplish this, the user simply needs to run pax with an appropriate -R
restore point value and the '-u update' action.

Another example may be where a user (accidentally) deleted software from
their device and now needs it replaced. This can be reversed by issuing
the -R switch with the corresponding restore point name and the -i action.

To view all the restore points use "-R '*' -l". To view the list within a
date, specify "-R 'YYYY-MM-DD' -l", or to see the packages contained in a
certain restore point, use "-R 'YYYY-MM-DD/Restore Point Name' -l". To
remove certain restore points, use the '-u {delete|purge}' action with the
date or complete path value for -R, to delete a group or individual point
respectively.

To summarize:
   o This option works with the -i, -l, and -u actions.
   o The prevent creating a restore point use '-R none' with -u
   o The format with -i is: 'YYYY-MM-DD/Restore Point Name'
   o The format with -l is: '*' or 'YYYY-MM-DD[/Restore Point Name]'
   o The format with -u is: 'YYYY-MM-DD[/Restore Point Name]'

.B -S VALUE
This switch changes the source location where the action obtains the
necessary packages. Depending on the action, this value may be a local
or network directory, or a remote repo (beginning with 'http' or 'ftp').

An interesting use of the -V, -S, and DIRECTORY values may be to perform
dianostics on an attached hard drive from another device.

.B -T VALUE
To prevent typing the full name of each package, this switch will fill in
this portion of the package name automatically. For example, lets say you
want to install the alsa-lib package. You can do so by using either the
full package name '-i alsa-lib' or '-T lib -i alsa'. This switch becomes
more pratical for a longer list of package names. Please note that all
packages listed must be of the same type.

.B -V VALUE
Sometimes unknown bugs are discovered once software is released to the
public, causing productivity issues. In this instance it is helpful to be
able to install a prior version, even temporarily until the problem can be
resolved. Using this switch will accomplish that task. The value to pass
will vary between distros as some may use actual software version numbers,
others may use values corresponding to releases of their OS. And like the
-m action, this one can also only process one package at a time.

This can also be implemented within the .deps files themselves using the
following syntax:
   PACKAGE.EXT_SOFT[1.2.3]

.B -X VALUE
Another unique feature of pax is the ability to proxy certain actions from
one device to another. This may be useful in situations where there is an
air gap between devices for security, or this may come in handy where the
Internet connection at a location is slow or intermittent but better at
another one.

This switch requires a value corresponding to the removable media mount
point so the pax command can be executed on another device. Once written,
plug the media in the other device and execute the 'proxy.sh' script found
in the 'pax' directory. Please note that the other device needs to also be
running Linux, or have the ability to process shell scripts. After running
the script, take the media back to the original device and run that same
script again. This will install the desired packages automatically.

Currently this switch can only work with the -c, -d, and -i actions.

.B -Y
If you want to see exactly what is going to take place before running the
actual command, use this switch to perform a dryrun. To get a complete log
of what will take place, add the '-Q none' switch and/or set DEBUG=1 in
the config file.

.B -Z
This switch simply adds color to the output.




.SH EXAMPLES

The below list shows various examples for using pax. This list is not
exhaustive and does not indicate modifications using any options.

Performing action with all packages [to current directory]:
     ${TEMP} -{ceilt}
Performing action with specific packages [to current directory]:
     ${TEMP} -{cdeilt} package1 package2
Performing action with package list [to current directory]:
     ${TEMP} -{cdeilt} packages.txt
Performing action with specific packages to/in a specified directory:
     ${TEMP} -{cdeilt} package1 package2 /target/path
Performing action with a package list to/in a specified directory:
     ${TEMP} -{cdeilt} packages.txt /target/path
Performing action with specific packages from/in a specified directory:
     ${TEMP} -S {URL|/source/path} -{cdeilt} package1 package2
Performing action with a package list from/in a specified directory:
     ${TEMP} -S {URL|/source/path} -{cdeilt} packages.txt
Performing action with all packages between specified directories:
     ${TEMP} -S {URL|/source/path} -{cdei} /target/path
Performing action with a package list between specified directories:
     ${TEMP} -S {URL|/source/path} -{cdei} packages.txt /target/path

Find files in available packages:
     ${TEMP} -f file1 file2
Find files in available packages from a filelist:
     ${TEMP} -f files.txt
Find files in packages within a specified directory:
     ${TEMP} -f file1 file2 /source/path
     ${TEMP} -S /source/path -f file1 file2
Install a specific version:
     ${TEMP} -V 1.2.3 -i package
Install a package from a valid restore point:
     ${TEMP} -R 'YYYY-MM-DD/Restore Point' -i package
List all restore points:
     ${TEMP} -R '*' -l
List all restore points in a valid date:
     ${TEMP} -R 'YYYY-MM-DD' -l
List all packages in a valid restore point:
     ${TEMP} -R 'YYYY-MM-DD/Restore Point' -l
Make a package for distribution:
     ${TEMP} -m package /path/containing/{package|source}
     ${TEMP} -S /path/containing/{package|source} -m package
     ${TEMP} -S /path/containing/{package|source} -m file
Open a fifo to operate pax:
     ${TEMP} -o
Open a fifo to operate pax in a specified directory:
     ${TEMP} -o /path/to/fifo
     ${TEMP} -S /path/to/fifo -o
Open a fifo to operate pax using a specific fifo:
     ${TEMP} -o name
Open a fifo to operate pax, clearing a prior failure:
     ${TEMP} -o clear
Open a fifo to operate pax, clearing and using specific fifo:
     ${TEMP} -o name clear
Proxy a download:
     ${TEMP} -X /mnt/sdb1 -d package1 package2
Proxy an install:
     ${TEMP} -X /mnt/sdb1 -i package1 package2
Unload a package:
     ${TEMP} -u unload package
Uninstall a package, leaving configs:
     ${TEMP} -u delete package
Uninstall a package, including configs too:
     ${TEMP} -u purge package
Uninstall a package, without a restore point:
     ${TEMP} -R none -u delete package
Update a package (uninstall old, install new):
     ${TEMP} -u update package
Delete a restore point(s):
     ${TEMP} -R 'DATE[/Restore Point]' -u {delete|purge}




.SH BUGS

There are no known bugs as of January 2026.

Please visit our website for the latest list of opened bug reports for
this software project - http://www.cliquesoft.org.




.SH ACKNOWLEDGEMENTS

This program is based on the various package managers currently in use
for the many Linux distros available today. We use them as a guide to
incorporate new features to expand the project.




.SH COPYRIGHT

Copyright (C) 2016-2026 Cliquesoft

Unless a valid Cliquesoft Private License (CPLv1) has been purchased for your
device, this software is licensed under the Cliquesoft Public License (CPLv2)
as found on the Cliquesoft website at www.cliquesoft.org.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the appropriate Cliquesoft License for details.

You should have received a copy of the Cliquesoft Public License v2 with the
software itself; if not, please visit our website for the complete document:

   https://www.cliquesoft.org




.SH AUTHORS

Dave Henderson

