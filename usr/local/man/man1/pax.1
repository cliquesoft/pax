.\"Man page for pax, by Dave Henderson.
.TH pax 1 "2026 January 22"
.SH NAME
\fIpax\fR - package manager




.SH SYNOPSIS
.B pax [OPTIONS] ACTION {PACKAGE(S)|FILELIST} [DIRECTORY]

ACTIONS:
  -c   copy local packages to another directory
  -d   download package(s) only
  -e   extract local package(s) contents
  -f   find which local package(s) a file belongs to
  -i   install package(s)
  -l   list all currently installed packages
  -m   make a new package (requires DIRECTORY)
  -o   open a fifo for (remote) communication
  -t   show the dependency trees of package(s): relies, reliant
  -u   uninstall package(s): update, unload, unlist, delete, purge
  -v   validate package(s) info: data, hash, deps, fix
  -z   populates DIR_LIST with package files'

  --help      shows this screen
  --install   installs pax as the default package manager
  --uninstall uninstalls pax as the default package manager
  --version   displays the software version

OPTIONS:
  -B   indicates we are currently booting the system
  -C   specifies an alternative CPU architecture: i32, i64, r32, r64
  -D   dependency handling: none, default, all, source
  -E   include extra package files: all, code, cpio, info, list, make
  -F   force the ACTION to take place
  -I   list of dependencies to ignore
  -K   specifies an alternative kernel name (4.1.6_xinix)
  -L   the list to adjust: none, boot, live
  -M   defines the package install mode: copy, link (default)
  -N   do NOT install all files in the package, just those specified
  -O   display output format: fifo, text, xml, xmLive
  -P   prompt before taking action
  -Q   quiets the output: all, errors, default, verbose, none
  -R   the action applies to restore points
  -S   changes the source directory/repo to obtain software from
  -T   specifies the package type: bin, dev, doc, drv, gir, lib, loc
  -V   the specific version of a package to install
  -X   obtain packages via proxy using another device
  -Y   performs a dry run of the action
  -Z   add color to the output




.SH TOC
1.  DESCRIPTION
2.  CONFIG
3.  PARAMETERS
4.  ACTIONS
5.  OPTIONS
6.  SOCKET			examples?
7.  BUGS
8.  ACKNOWLEDGEMENTS
9.  COPYRIGHT
10. AUTHORS




.SH DESCRIPTION
.I pax
is a lightweight, robust, and versatile package manager for Linux distros.
While not quite as feature rich as the apt/dpkg Debian system, pax also is
a fraction of its size (almost a 10th at 200kb)! The development of this
project will continue so that all commonly used functions will eventually
be incorporated, along with several that are unique. There are also plans
to have this package manager work with non-native package formats such as
.deb and .rpm, allowing users and admins another (standardized) option in
their network of devices.

Currently this project can perform a variety of operations including:
  o Copying packages (and dependencies) from one location to another
  o Extracting packages (and dependencies) to a specified location
  o Downloading packages (and dependencies) to a specified location
  o Finding local packages that one or more files belong to
  o (Un)installing packages (and dependencies)
  o (Un)installing different versions of packages
  o List installed packages
  o Make and package software for distribution
  o Open a fifo for network client operation
  o Display dependency trees for packages
  o Validate and repair installed software
  o Output can be displayed in various formats
  o Proxy several actions from an offline to an online device

Common outstanding features include:
  o Ability to search online repos
  o Automated package checking/downloading/updating
  o A graphical user interface

Unique outstanding features include:
  o Ability to process .deb (and other) package types
  o Expand output to include an 'html' and 'json' option
  o More proxy actions
  o A centralized update server
  o A network server to manipulate packages on clients




.SH CONFIG
There are a variety of values that can be modified so that pax can work
with any Linux distro. This ranges from package storage locations and
operational directories, to package extensions and schemas. Each value
will be covered below, but first lets discuss config file placements.
There are three locations that pax searches for its configuration. The
first is the system-wide settings found in /etc/pax/config. The second
and third locations are for personal configurations and are found in
~/.etc/pax/config (XSB) and ~/.pax/config (LSB). The search order is
completed by the passed values during execution, each instance taking
precedence over its predecessor.

To summarize:
  o The search order: /etc/pax, ~/.[etc/]pax, passed values

We will now cover each variable available for adjustment in the config
file.

.I Local Repo Values

.B REPO_PREFIX
This directory contains the file lists (LIST_BOOT and LIST_LIVE) as well
as the directories containing your downloaded software packages. So just
as the name suggests, its the prefix to your local repo.

.B REPO_OPTION
A sub-directory of REPO_PREFIX, this directory stores all the optional
software that is added to a basic operating system.

.B REPO_SYSTEM
Like the previous variable, this one also stores additional software.
However, this directory would contain packages to expand a default OS.
For example, XiniX VE stores all the X11 packages in here to load during
the device bootup. This can also contain packages like NTFS so that
filesystems of that type are available for usage. Basically any software
that the base operating system would need, should be added here. Also of
note, this is the default directory processed when the -B switch is
passed.

.B REPO_RESTOR
Specific to pax, this package manager creates restore points when a user
uninstalls software by issuing a '-u delete', '-u purge', or '-u update'
switch.

.I Directory Values

.B DIR_INIT
This directory contains the daemon service scripts.

.B DIR_INST
This directory contains the package installation scripts.

.B DIR_LIST
This directory contains the additional package files for installed
software.

.B DIR_LIVE
Once a device has booted, this is the default directory where packages
get installed. On most distro's this will simply be root (/). However,
XiniX defaults to the /Users/Public directory (which is similar to the
/usr tree in LSB). An interesting feature of this variable allows its
value to end with a dot (.) that will replace the initial slash of
the packaged files. So, for example, if a package contains a file in
the /etc directory, it would then become /Users/Public/.etc in the
XiniX OS (or any other using that notation).

.B DIR_LOGS
This directory contains the softwares logs.

.B DIR_LOOP
This directory contains the mount points for symlinked packages.

.B DIR_TEMP
This directory contains temp files used by the software.

.I Package Extensions

.B EXT_CORE
[text file] Used to mark a package as part of the base OS

.B EXT_CODE
[tgz file] The file extension used for a packages' source code

.B EXT_DEPS
[text file] The file extension used for the package dependency list

.B EXT_HASH
[text file] The file extension used for the package validation hash

.B EXT_INFO
[text file] The file extension used for the package details info

.B EXT_LIST
[text file] The file extension used for the package manifest info

.B EXT_MAKE
[text file] The file extension used for the package make commands

.B EXT_SOFT
[mksquashfs file] The file extension of the actual packaged software

.I Log Files

.B LOG_DBUG
The log file for debug output

.B LOG_ERRS
The log file for (error) output

.I Ownership and Permissions

.B OWN_GROUP
The default group that all users are members of

.B OWN_SYSTEM
The full ownership (user and group) of REPO_SYSTEM directory

.B PRM_SYSTEM
The permissions that the REPO_SYSTEM directory must have (for security)

.I Value Definitions

.B FIFO_SERVER
The default name for the -o action fifo

.B ARCH_VALUES
The valid values for the -C option

.I Schema Values

Since schema's are used as templates, these values can incorporate the
use of several variables. When using these variables, be sure to use
them in the fashion they are shown below. With the exception of the
ARCH_SCHEMA and KRNL_SCHEMA values, all the others should be enclosed
with single quotes (') as they are interprited at specific times instead
of once during the initial execution of the script. The variables are:
  ${PACKAGE} - the package name
  ${ARCH}    - the devices' CPU architecture
  ${TYPE}    - package type
  ${VERSION} - any included package version

.B ARCH_SCHEMA
The command executed to determine which CPU architecture the device falls
under, and relates to one of the values in ARCH_VALUES. This should be
encapsulated with double quotes (").

.B FILE_SCHEMA
This is the schema for the local package filenames and should be enclosed
in single quotes ('). This value should NOT include a file extension!

.B KRNL_SCHEMA
The currently used kernel string that gets appended to Linux kernel driver
packages. Typically this is just "$(uname -r)".

.B REPO_SCHEMA
This is the URL for the distro's online repo, and should be within single
quotes ('). This value should include the 'http' prefix!

.B VERS_SCHEMA
This variable indicates the package naming convention within the online
source repo, using the schema variables to provide the most flexibility
for the distro. For example, if the distro wants to place all associated
files in a single package directory, they can utilize multiple variables
to do so. Contrarily, if the distro wants to separate the various packages
by different URL's, then they can do so as well by using the REPO_SCHEMA
variable. Of course, both values can be simultaneously used for even
greater flexibility. This value should be enclosed with single quotes (')
and WITHOUT a file extension!

.B VERT_SCHEMA
Working alongside VERS_SCHEMA, this variable indicates the target filename
that should be used locally. The '${VERSION}' schema variable usually is
part of this value, but is not mandatory. This value should NOT include a
file extension!

.I Lists and Flags

There are two package lists and four flag files that define which packages
are loaded at the different stages of device operation. The lists should
be considered which packages are desired, whereas the flag files designate
which packages are forbidden - even if they are dependencies of packages
in the list files! Each of these variables should have their values
encapsulated in single quotes (') as they are interprited ondemand.

These variables also have access to a shell function called 'getBootcode'
that allows the value to change depending on the passage of a value from
the boot loader such as grub or syslinux. This way a user can define an
alternative value to use, or the distro default otherwise. An example of
a value could be:
  '$( V=$(getBootcode code); [ "$V" ] && echo $V || echo default )'

.B LIST_BOOT
This list defines which packages are loaded during the device bootup. A
unique feature of pax is that the package loading can be split into two
phases to speed up this process. Packages contained within this list
get loaded in the foreground, causing the bootup to wait until all have
been loaded before continuing. For this reason, kernel drivers and other
necessary packages should be placed here. User applications like an email
and an office suite should be placed in LIST_LIVE.

To enable this dual-phase process, this file must exist, even if it is
blank. Its absense will indicate that all packages need to be processed
in the traditional way, with a longer bootup.

.B LIST_LIVE
A value for this list is mandatory. Unlike LIST_BOOT, this file must
exist as it is used to load packages whether the dual-stage booting is
enabled or not. In fact, to manually switch to a single-stage bootup,
simply move the packages from LIST_BOOT into this list and erase the
other file. And unless an alternate list is specified with the -L
switch, this one is used to know which packages need to be loaded by
default versus which ones should be reserved for ondemand loading.

.B FLAG_BOOT
The complement flag file to LIST_BOOT that contains packages that should
not be loaded during bootup. The list can even contain dependency files.
In essence, this is a blacklist to LIST_BOOT.

.B FLAG_LIVE
The complement flag file to LIST_LIVE that contains packages that should
skipped during the processing of automatically loaded software. This is a
blacklist to LIST_LIVE.

.B FLAG_COPY
Unlike the prior two flag files, the mere presence of this file is the
only requirement to indicate that ALL packages need to be copied instead
of symlinked. This can be overwritten by passing the '-M link' switch when
calling pax though.

.B FLAG_FIRM
Also indicating that packages need to be copied instead of symlinked, but
this flag only pertains to the base OS packages found in REPO_SYSTEM and
LIST_BOOT.

.I Miscellaneous Definitions

.B FOLLOWUP
This variable includes any unique command for the distro that needs to be
called after all packages are loaded. If the value contains the variable
${PACKAGE}, then it will be called once for every package passed into pax.
In its absence, the command will be called once.




.SH PARAMETERS
To maintain consistency, there are several parameters to note. The first
that we'll cover is PACKAGE(S). Normally this value will consist of a
space separated list of package names. However, a text file containing
one package per line can also be used as an alternative. This can come
in handy if automating any process by moving a variable list of packages
into a text file while calling a uniformed pax command.

The final value that can be used is a directory itself, and will process
all contained packages. The downside to this is that the DIRECTORY value
can no longer be used. An alternative to this method while retaining the
ability to use the DIRECTORY value, is to use -S for the source location.

To summarize, the PACKAGE(S) value can be:
  o A space separated list of package names
  o A file containing a list (one package per line)
  o Or directory containing the package(s)

The last parameter pax can accept is DIRECTORY. Typically it operates as
the target location for the passed action (with the exception outlined
above), and is optional. To provide flexibility for the user, there are
several different syntaxes that are permitted. Both full and relative
paths are permissible, but the value must contain a forward slash (/) to
indicate it's a directory instead of a package name. This will not be a
problem with full paths as they obviously start with one. Relative paths
can either begin with a './', end with a '/', or contain a slash within
the value (e.g. 'some/dir').

To summarize, the DIRECTORY value can be:
  o A full path: /tmp/pax/
  o Or a relative path: ./pax
    Containing a slash: dir/pax
    With a trailing slash: pax/




.SH ACTIONS
As with virtually all software, switches can be passed to modify its
operation. The below section covers each switch in detail, separating
the actions from the options. It is important to note that the options
actually need to proceed the actions when calling pax.

.B --help
Shows helpful information about the program

.B --install
Installs pax as the default package manager in non-XiniX Linux distros. In
this process, there is an option to configure dual or single-stage device
bootup that can speed up the time it takes to get into the OS. See the
'Lists and Flags' section above for more information.

.B --uninstall
Uninstalls pax as the default package manager in non-XiniX Linux distros.

.B --version
Displays the software version and exits.

.B -c
Users can simply use a graphical file manager, or the 'cp' command at a
shell prompt to copy files. However, this would require manually tracing
dependency trees to copy all the necessary packages required to make a
program work correctly. This action reduces all that work into a single,
convenient command. If no PACKAGE(S) value is passed, then all packages
in the DIR_OPTION (or -S location) will be processed.

.B -d
There may be times when a package just needs to be downloaded so it can
be processed in the future. This could include network update servers,
software testing, or even pre-installed ondemand software for (device)
deployment scenarios. Using this action allows the packages to be
obtained before they are required.

.B -e
Similar to the -d ACTION, this switch will extract the contents of one or
more packages to a specified location. This can be useful in situations
where packages need to be (forensically) compared, imaging devices, or any
other situation requiring the extraction of package files. Without passing
a PACKAGE(S) value, all packages in the DIR_OPTION (or -S location) will
be processed.

It is important to note that this action will always overwrite data due to
the underlying binary being used.

.B -f FILES
While not a routine task, there may be times when it is useful to find the
package that a particular file belongs to. This action will allow you to
enter one or more files and search which local packages contains them.

.B -i
The cornerstone of all packages managers, this switch performs the actual
installation of packages so that users don't have to find, compile, and
install software themselves. The packages, or dependencies, can be local
or remote. If no PACKAGE(S) value is passed, then all packages in the
DIR_OPTION (or -S location) will be processed.
If speed is a necessity, and all packages and their dependencies are in
source directory, a '-D none' switch can be included to skip that check.

.B -l
To list the packages currently installed, use this switch. Currently the
output uses a verbose 2 line per package layout containing a plethora of
information about each package - provided the .info files are also present
in the DIR_INST directory. Users can pass specific packages to list, or
process all installed software without a PACKAGE(S) value.
NOTE: There are plans to reduce this to one line in a future version.

.B -m NAME DIRECTORY
This switch can be used to create a package file for distribution and will
bundle all the files in a passed directory. With the presence of a .make
file, pax will execute it to compile software before the packaging phase
takes place. This will enable package maintainers to include their .make
file alongside the packaged software so anyone can easily build from
source.

Unlike other switches, this one can only process one package at a time,
with the PACKAGE(S) value being used as the name of the created package.
This value can still be given in a text file, but only one name can be
included per execution. The other mandatory value is a DIRECTORY (or -S)
value to indicate the location of the files/source code to process.

If no .make file is present, then the passed directory will be considered
the root level for the package being created. If a .make file does exist,
then it needs to be named using the FILE_SCHEMA syntax with a .make file
extension, and placed directly inside the passed directory. Likewise, the
source code directory needs to be in the same location. Its name, however,
if of no value to pax since that will be handled by the .make script. The
compile process must install the created software into a staging directory
named 'project'. The layout should look like:
   /tmp/staging/
           PACKAGE.make
           PACKAGE-source-code-dir/
           project/

.B -o [NAME] [clear]
While there is not a package server manager yet, this switch will be used
by client devices to enable remote administration of packages. This will
enable network admins to remotely manage packages installed on devices
under their control, including the (un)installation, updating, and repair
of any software.
To give the fifo a different name, you can either modify the FIFO_SERVER
value in the config file, or pass a new name as a value to the -o switch.
In the event that a fifo was left behind due to some type of error, a
cleanup can be made by passing a trailing 'clear' to the pax command.

.B -t VALUE
Sometimes it is helpful to see dependency trees to packages. This switch
offers two different modes to show you this information. Using a value of
'relies' will display the dependencies that the passed package(s) rely on.
Contrarily, a value of 'reliant' will show all the packages that rely on
the ones passed.

.B -u VALUE
This action offers a range of uninstallation modes to handle your needs.
The first mode, 'unload', simply uninstalls the software files from your
device, leaving behind the config and package files for a quick reinstall.
The 'unlist' value performs the same tasks as 'unload', but additionally
removes the package from the LIST_LIVE (or -L list). If the software will
no longer be used, passing a 'delete' command will unlist and delete the
associated package files, leaving the configs untouched. To remove even
the package config files, use a 'purge' value to completely remove all
traces of the software from the device. Keep in mind that none of these
commands affect any data generated by the software, only the software
itself.

The last mode, is 'update', and as the name implies it's for updating
currently installed software to a new version. Unless overwritten, a
restore point is generated for the old version before the new one gets
installed. When performing this action, you need to be in the directory
containing the update so that the -S and DIRECTORY values can operate
as designed (the former being where the existing package file is located
and the latter being the path were the package is installed to).

To summarize:
  o 'unload' - removes application files
  o 'unlist' - unloads and removes LIST_LIVE (or -L) entry
  o 'delete' - unlists and removes package files
  o 'purge'  - deletes and removes config files
  o 'update' - unloads current version, installs new version

.B -v VALUE
There may be times when validating package data is necessary, especially
if software is malfunctioning. This action will enable you to validate the
package dependencies are installed by issuing a 'deps' value. It can also
validate that the files in a package are installed, have the appropriate
ownership/permissions, and either symlinked to the correct target, or that
each installed file is legitimate. Both tasks can be accomplished with a
'data' value, however, using 'hash' will extend validation of each copied
(not symlinked) file via hashes instead of the quicker comparison using
file sizes. The latter mode will take a bit longer to complete. If any
issues are found, you can use a 'fix' value to resolve them.

.B -z
This action is only useful when pax is installed in a distro using several
package managers, but it's not configured as the exclusive default. This
switch will sync the necessary cache files so that it can operate properly
in the OS. Even with this switch, alternating between various managers is
highly discouraged outside of testing environments.




.SH OPTIONS
To adjust the behavior of actions, you can pass one or more options with
each execution of pax. Remember that these actually need to proceed the
action switch!

.B -B
Used to indicate the device is booting so that packages can be processed
as configured using either a single or dual-phase installation. This also
sets DIRECTORY='/' and checks only REPO_SYSTEM. Users should never pass
this flag in a live environment.

.B -C VALUE
Specifies an alternative CPU architecture to process. This could be useful
for mixed 32/64 bit environments, or for building the OS for a different
target device.

.B -D VALUE
This switch controls how dependencies are processed. A value of 'none'
will prevent this step and affect only the packages pax is instructed to
process via a list, file, or directory. The 'default' value is the normal
mode of operation and will process dependencies. Some packages have
optional dependencies (e.g. documentation) that will also be processed by
using 'all' as the value. There is an additional mode, 'source', which
will work like 'default', but mandates that all the dependencies reside
in the passed -S location. It is impossible to combine the functionality
of 'all' and 'source' - at least presently.

To list packages as optional in the .deps file, use the following syntax:
   [OPTIONAL.EXT_SOFT|INSTALLLED.EXT_SOFT]

Unless '-D none' is used, the search order for dependencies is:
   REPO_SOURCE (-S), REPO_OPTION, REPO_SYSTEM, [REPO_SCHEMA]

.B -E VALUE[,VALUE,...]
In some cases a user might want more than the package files necessary
for an installation. For example, they may want a .make file to build
the package from source, or the .cpio file to include as part of the
base OS. Even downloading the .info file will provide extra package
info when using the -l action. Possible values include:
   all  - download all additional package files
   code - package source code
   cpio - initial ramdisk inclusion file
   info - package information
   list - package manifest listing
   make - package compile script

.B -F
Be careful with the inclusion of this option as it will force the action
to take place, even if dire consequences result!

.B -I VALUE[,VALUE,...]
In rare cases, there may be a need to ignore a dependency from getting
processed. For example, there may be a dependency that is still desired
to retain after another program that relies on it has been uninstalled.
Instead of adding a package to a flag file, this value can be passed
during the execution of pax.

.B -K VALUE
During normal operation, this flag would never be used since it changes
the kernel string attached to driver packages. However, if a kernel update
or an OS build for another device were required, this switch would become
useful.

.B -L VALUE
When installing a package, the default process adds the package to the
LIST_LIVE list. This can be foregone with a value of 'none', or placed
in the LIST_BOOT with a 'boot' value.

.B -M VALUE
Sets the mode for the installation of the package contents. The only two
values are 'copy' and 'link', with the latter referring to maintaining a
loopback mount to the package and symlinking its contents into the OS.
There are several advantages with this method including conservation of
storage space and the inability to manipulate a readonly file system.
This doesn't mean malicious activity can't take place, since symlinks can
be redirected, or replaced with an actual binary. But it does add some
more barriers.

If speed of operation is your primary goal, then you would want to use
the 'copy' value here, which is the default. If the OS uses a ramdisk,
then the speed is even greater than with attached storage.

.B -N VALUE[,VALUE,...]
For instances where storage space is at a premium, security is critical
(by miniming the attack vectors), or those that simply want the smallest
footprint possible, this option will allow only desired files to be
installed instead of the entire package.

This can also be implemented within the .deps files themselves using the
following syntax:
   PACKAGE.EXT_SOFT{file1,file2,file3,...}

.B -O VALUE
Another unique feature of pax is that the output can be more than just the
default 'text'. Currently there are three other options with two of them
related to XML. The first is just 'xml' and will display the entire result
of the call at the end of execution. This means that the output will be
inside either a '<s>' (success) or '<f>' (failure) tag. The second is the
'xmLive' value that will display output as it is being processed, adding a
'<failure>' tag in the event of a problem being encountered.

The third additional option is 'fifo' that will output text to a named
pipe file. The long term goal is to build a server/client framework for
networks so that devices can be managed by an admin team.

There are plans to also add 'json' and 'html' values in a future release.

.B -P
This switch simply prompts the user before implementing the requested
action, showing what is going to occur in the existing output.

.B -Q VALUE
Like most software that has the option to control verbosity, this switch
modifies the quietness of the output. Therefore, a value of 'all' will
actually produce no output, whereas a value of 'none' would make it the
most verbose it could be. Use 'errors' to reduce the output to only show
encountered problems, or 'verbose' to show slightly more than the default.

.B -R

  -R   the action applies to restore points
  -S   changes the source directory/repo to obtain software from			# mainly used when creating installation media to pull the files from an existing BOOT instead of an online repo
  -T   specifies the package type: bin, dev, doc, drv, gir, lib, loc
# DEV NOTE: can use -S and DIRECTORY to validate files on a separate hard drive (e.g. diagnostics using one computer for another computers' hard drive via USB)
  -V   the specific version of a package to install
#		dependency.i32.lib.soft[1.2.3]
  -X   obtain packages via proxy using another device				# Can be used when one location has little or no Internet access. For example, @home has bad internet connection, but work is good, can dl @work for @home.
  -Y   performs a dry run of the action
  -Z   add color to the output

.B -f[ullscreen]
Unlike all the other switches, this one does not take a complementary
value and specifies that all application windows will operate in
fullscreen mode (no titlebar). This is helpful when fxWM is used as the
window manager on smaller devices such as smart phones and tablets that
do not allow windows to be dragged around the screen.

.B -m[aximized]
As the name suggests, this switch will force each application window to
run in a maximized state. The difference between this switch and -f is
that each application window will contain a titlebar.

.B -i[con] DIR
When the user presses the Alt+Tab buttons, a window will popup showing
all the running applications. Using this switch, you can let fxWM know
the directory that should be used to locate the appropriate application
icon. By default, a sub-directory with the requested icon size (rounded
up) is checked and if no matching icon is found, it will check in the
root of the DIR directory for a match. In the absense of that icon, a
generic icon will be used in its place. So, for example, if the icon
size was specified as 90px, then the window manager will check for a
"128x128/?.png" graphic (since 128x128 is the closest, rounded up size)
and then for a "./?.png" file. If neither exist, then a generic icon
will be used as a last resort.

.B -s[ocket] FILE
By default, a socket file to manipulate this window manager is created
and found at /tmp/.fxwm-control. If you would like to use a different
path and filename, you can use this switch to specify that information.

.B -p[ipe] FILE
Similar to the socket file mentioned above, this fifo enables you to
monitor the window manager for events that get triggered by the user
so that the system can optionally perform certain desired tasks. Using
this switch, you can control the location and name of the file which
is /tmp/.fxwm-monitor by default.




.SH SOCKET

This window manager does allow interaction through the use of sockets
and will allow you manipulate various aspects of the environment using
software like socat or netcat. We will cover all the available actions
below but wanted to demonstrate two examples:
	echo 'list' | ncat -U /tmp/.fxwm-control
	echo 'activate 0x80024c' | socat - /tmp/.fxwm-control

Single Actions

.B list
Passing this action will provide a list of all the software currently
opened in the graphical environment and will be in the following format
that is separated by tabs:

<Window ID>[<Active>] <Desktop ID> <Host> <Binary> <Window Title>

It is important to note that the active window will have an asterisk
character (*) following its <Window ID>.

.B activate <Window ID>
To bring a desired window into the foreground with focus, pass this
action through the current socket file.

.B close <Window ID>
As the name suggests, this will close the window associated with the
passed ID.

.B resize <Window ID> WxH
Resize any window with this command while passing the new width and
height desired.

.B move <Window ID> 0+0
This action will allow you to move a window around the screen via the
X and Y coordinates passed.

.B BG <Window ID>
Issuing this command will keep the specified window in the background.

.B FG <Window ID>
This action works just like the 'BG' command, but will foreground.

.B chrome
To update chrome adjustments without having to restart fxWM, simply
issue this command to the socket.

.B disable
Used to disable all window manager functionality (e.g. screen locking).

.B enable
Re-enables all the window manager functionality from a 'disable' call.

.B alert "Closable|Icon Path|App Name|Alert Title|Alert Message|Command"
Sends a popup notification to the user so they can be informed of events
or to quickly perform some type of pre-defined action. It is important
to note that you can pass null values to prevent usage or to use default
values. Also, valid 'closable' values are: 0 or false, 1 or true.

Multi-Actions

.B get/set offset [<0:0:0:0>]
Allows you to get or set the global window offset.

.B get/set limit [<WxH>]
To limit the screen area available for windows, issue this action.

.B get/set confine [<0,1>]
Used to get or set the confine parameter.

.B get/set <Window ID> title [<String>]
To get or set a windows title, use this action. If you are setting the
title, you will need to pass the last value shown above.

.B get/set <Window ID> icon [<Path+Filename>]
Gets or sets the titlebar icon of the desired window.

.B get/set <Window ID> titlebar [<Path+Filename> <String>]
You can get or set both of the afore mentioned actions in a single
attempt with this command.

.B get/set <Window ID> state [<String>]
State changes are accomplished using this command. Possible values are
minimized, maximized, unmaximized, and fullscreen.




.SH BUGS

There are no known bugs as of January 2026.

Please visit our website for the latest list of opened bug reports for
this software project - http://www.cliquesoft.org.




.SH ACKNOWLEDGEMENTS

This program is based on the various package managers currently in use
for the many Linux distros available today. We use them as a guide to
incorporate new features to expand the project.




.SH COPYRIGHT

Copyright (C) 2016-2026 Cliquesoft

Unless a valid Cliquesoft Private License (CPLv1) has been purchased for your
device, this software is licensed under the Cliquesoft Public License (CPLv2)
as found on the Cliquesoft website at www.cliquesoft.org.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the appropriate Cliquesoft License for details.

You should have received a copy of the Cliquesoft Public License v2 with the
software itself; if not, please visit our website for the complete document:

   https://www.cliquesoft.org




.SH AUTHORS

Dave Henderson

